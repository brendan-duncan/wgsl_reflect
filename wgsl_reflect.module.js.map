{"version":3,"file":"wgsl_reflect.module.js","sources":["src/reflect/info.ts","src/utils/float.ts","src/utils/texture_sample.ts","src/utils/texture_format_info.ts","src/wgsl_ast.ts","src/wgsl_scanner.ts","src/utils/cast.ts","src/reflect/reflect.ts","src/exec/exec_context.ts","src/exec/exec_interface.ts","src/exec/builtin_functions.ts","src/utils/matrix.ts","src/wgsl_exec.ts","src/ast/parse_context.ts","src/wgsl_parser.ts","src/wgsl_reflect.ts","src/exec/command.ts","src/exec/stack_frame.ts","src/exec/exec_stack.ts","src/wgsl_debug.ts"],"sourcesContent":["import { Attribute } from \"../wgsl_ast.js\";\r\n\r\nexport class TypeInfo {\r\n  name: string;\r\n  attributes: Attribute[] | null;\r\n  size: number;\r\n\r\n  constructor(name: string, attributes: Attribute[] | null) {\r\n    this.name = name;\r\n    this.attributes = attributes;\r\n    this.size = 0;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return false;\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return false;\r\n  }\r\n\r\n  get isTemplate(): boolean {\r\n    return false;\r\n  }\r\n\r\n  get isPointer(): boolean {\r\n    return false;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    return this.name;\r\n  }\r\n}\r\n\r\nexport class MemberInfo {\r\n  name: string;\r\n  type: TypeInfo;\r\n  attributes: Attribute[] | null;\r\n  offset: number;\r\n  size: number;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo,\r\n    attributes: Attribute[] | null\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n    this.offset = 0;\r\n    this.size = 0;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return this.type.isArray;\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return this.type.isStruct;\r\n  }\r\n\r\n  get isTemplate(): boolean {\r\n    return this.type.isTemplate;\r\n  }\r\n\r\n  get align(): number {\r\n    return this.type.isStruct ? (this.type as StructInfo).align : 0;\r\n  }\r\n\r\n  get members(): MemberInfo[] | null {\r\n    return this.type.isStruct ? (this.type as StructInfo).members : null;\r\n  }\r\n\r\n  get format(): TypeInfo | null {\r\n    return this.type.isArray\r\n      ? (this.type as ArrayInfo).format\r\n      : this.type.isTemplate\r\n      ? (this.type as TemplateInfo).format\r\n      : null;\r\n  }\r\n\r\n  get count(): number {\r\n    return this.type.isArray ? (this.type as ArrayInfo).count : 0;\r\n  }\r\n\r\n  get stride(): number {\r\n    return this.type.isArray ? (this.type as ArrayInfo).stride : this.size;\r\n  }\r\n}\r\n\r\nexport class StructInfo extends TypeInfo {\r\n  members: MemberInfo[] = [];\r\n  align: number = 0;\r\n  startLine: number = -1;\r\n  endLine: number = -1;\r\n  inUse: boolean = false;\r\n\r\n  constructor(name: string, attributes: Attribute[] | null) {\r\n    super(name, attributes);\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class ArrayInfo extends TypeInfo {\r\n  format: TypeInfo;\r\n  count: number;\r\n  stride: number;\r\n\r\n  constructor(name: string, attributes: Attribute[] | null) {\r\n    super(name, attributes);\r\n    this.count = 0;\r\n    this.stride = 0;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return true;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    return `array<${this.format.getTypeName()}, ${this.count}>`;\r\n  }\r\n}\r\n\r\nexport class PointerInfo extends TypeInfo {\r\n  format: TypeInfo;\r\n  constructor(name: string, format: TypeInfo, attributes: Attribute[] | null) {\r\n    super(name, attributes);\r\n    this.format = format;\r\n  }\r\n\r\n  get isPointer(): boolean {\r\n    return true;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    return `&${this.format.getTypeName()}`;\r\n  }\r\n}\r\n\r\nexport class TemplateInfo extends TypeInfo {\r\n  format: TypeInfo | null;\r\n  access: string;\r\n  constructor(\r\n    name: string,\r\n    format: TypeInfo | null,\r\n    attributes: Attribute[] | null,\r\n    access: string\r\n  ) {\r\n    super(name, attributes);\r\n    this.format = format;\r\n    this.access = access;\r\n  }\r\n\r\n  get isTemplate(): boolean {\r\n    return true;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    let name = this.name;\r\n    if (this.format !== null) {\r\n      if (name === \"vec2\" || name === \"vec3\" || name === \"vec4\" ||\r\n          name === \"mat2x2\" || name === \"mat2x3\" || name === \"mat2x4\" ||\r\n          name === \"mat3x2\" || name === \"mat3x3\" || name === \"mat3x4\" ||\r\n          name === \"mat4x2\" || name === \"mat4x3\" || name === \"mat4x4\") {\r\n        if (this.format.name === \"f32\") {\r\n          name += \"f\";\r\n          return name;\r\n        } else if (this.format.name === \"i32\") {\r\n          name += \"i\";\r\n          return name;\r\n        } else if (this.format.name === \"u32\") {\r\n          name += \"u\";\r\n          return name;\r\n        } else if (this.format.name === \"bool\") {\r\n          name += \"b\";\r\n          return name;\r\n        } else if (this.format.name === \"f16\") {\r\n          name += \"h\";\r\n          return name;\r\n        }\r\n      }\r\n      name += `<${this.format.name}>`;\r\n    } else {\r\n      if (name === \"vec2\" || name === \"vec3\" || name === \"vec4\") {\r\n        return name;\r\n      }\r\n      //console.error(\"Template format is null.\");\r\n    }\r\n    return name;\r\n  }\r\n}\r\n\r\nexport enum ResourceType {\r\n  Uniform,\r\n  Storage,\r\n  Texture,\r\n  Sampler,\r\n  StorageTexture,\r\n}\r\n\r\nexport class VariableInfo {\r\n  attributes: Attribute[] | null;\r\n  name: string;\r\n  type: TypeInfo;\r\n  group: number;\r\n  binding: number;\r\n  resourceType: ResourceType;\r\n  access: string;\r\n  relations: Array<VariableInfo> | null = null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo,\r\n    group: number,\r\n    binding: number,\r\n    attributes: Attribute[] | null,\r\n    resourceType: ResourceType,\r\n    access: string\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.group = group;\r\n    this.binding = binding;\r\n    this.attributes = attributes;\r\n    this.resourceType = resourceType;\r\n    this.access = access;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return this.type.isArray;\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return this.type.isStruct;\r\n  }\r\n\r\n  get isTemplate(): boolean {\r\n    return this.type.isTemplate;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.type.size;\r\n  }\r\n\r\n  get align(): number {\r\n    return this.type.isStruct ? (this.type as StructInfo).align : 0;\r\n  }\r\n\r\n  get members(): MemberInfo[] | null {\r\n    return this.type.isStruct ? (this.type as StructInfo).members : null;\r\n  }\r\n\r\n  get format(): TypeInfo | null {\r\n    return this.type.isArray\r\n      ? (this.type as ArrayInfo).format\r\n      : this.type.isTemplate\r\n      ? (this.type as TemplateInfo).format\r\n      : null;\r\n  }\r\n\r\n  get count(): number {\r\n    return this.type.isArray ? (this.type as ArrayInfo).count : 0;\r\n  }\r\n\r\n  get stride(): number {\r\n    return this.type.isArray ? (this.type as ArrayInfo).stride : this.size;\r\n  }\r\n}\r\n\r\nexport class AliasInfo {\r\n  name: string;\r\n  type: TypeInfo;\r\n\r\n  constructor(name: string, type: TypeInfo) {\r\n    this.name = name;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nexport class InputInfo {\r\n  name: string;\r\n  type: TypeInfo | null;\r\n  locationType: string;\r\n  location: number | string;\r\n  interpolation: string | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo | null,\r\n    locationType: string,\r\n    location: number | string\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.locationType = locationType;\r\n    this.location = location;\r\n    this.interpolation = null;\r\n  }\r\n}\r\n\r\nexport class OutputInfo {\r\n  name: string;\r\n  type: TypeInfo | null;\r\n  locationType: string;\r\n  location: number | string;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo | null,\r\n    locationType: string,\r\n    location: number | string\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.locationType = locationType;\r\n    this.location = location;\r\n  }\r\n}\r\n\r\nexport class OverrideInfo {\r\n  name: string;\r\n  type: TypeInfo | null;\r\n  attributes: Attribute[] | null;\r\n  id: number;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo | null,\r\n    attributes: Attribute[] | null,\r\n    id: number\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n    this.id = id;\r\n  }\r\n}\r\n\r\nexport class ArgumentInfo {\r\n  name: string;\r\n  type: TypeInfo;\r\n  attributes: Attribute[] | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: TypeInfo,\r\n    attributes: Attribute[] | null\r\n  ) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n  }\r\n}\r\n\r\nexport class FunctionInfo {\r\n  name: string;\r\n  stage: string | null = null;\r\n  inputs: InputInfo[] = [];\r\n  outputs: OutputInfo[] = [];\r\n  arguments: ArgumentInfo[] = [];\r\n  returnType: TypeInfo | null = null;\r\n  resources: VariableInfo[] = [];\r\n  overrides: OverrideInfo[] = [];\r\n  attributes: Attribute[] | null;\r\n  startLine: number = -1;\r\n  endLine: number = -1;\r\n  inUse: boolean = false;\r\n  calls: Set<FunctionInfo> = new Set();\r\n\r\n  constructor(name: string, stage: string | null = null, attributes: Attribute[] | null) {\r\n    this.name = name;\r\n    this.stage = stage;\r\n    this.attributes = attributes;\r\n  }\r\n}\r\n\r\nexport class EntryFunctions {\r\n  vertex: FunctionInfo[] = [];\r\n  fragment: FunctionInfo[] = [];\r\n  compute: FunctionInfo[] = [];\r\n}\r\n","// From https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\r\nexport function float16ToFloat32(float16: number): number {\r\n    var s = (float16 & 0x8000) >> 15;\r\n    var e = (float16 & 0x7C00) >> 10;\r\n    var f = float16 & 0x03FF;\r\n\r\n    if (e == 0) {\r\n      return (s ? -1:1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1F) {\r\n      return f ? NaN : ((s ? -1 : 1) * Infinity);\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + (f / Math.pow(2, 10)));\r\n}\r\n\r\nconst float32View = new Float32Array(1);\r\nconst int32View = new Int32Array(float32View.buffer);\r\nconst float16View = new Uint16Array(1);\r\n\r\nexport function float32ToFloat16(float32: number): number {\r\n  float32View[0] = float32;\r\n\r\n  const f32 = int32View[0];\r\n  const sign = (f32 >> 31) & 1;\r\n  let exponent = (f32 >> 23) & 0xff;\r\n  let fraction = f32 & 0x7fffff;\r\n\r\n  if (exponent === 0xff) { // Infinity or NaN\r\n    float16View[0] = (sign << 15) | 0x7c00 | (fraction !== 0 ? 0x0200 : 0);\r\n    return float16View[0];\r\n  }\r\n\r\n  if (exponent === 0) { // Zero or subnormal\r\n    if (fraction === 0) { // Zero\r\n      float16View[0] = sign << 15;\r\n      return float16View[0];\r\n    }\r\n    // Subnormal\r\n    fraction |= 0x800000;\r\n    let shift = 113;\r\n    while ((fraction & 0x800000) === 0) {\r\n      fraction <<= 1;\r\n      shift--;\r\n    }\r\n    exponent = 127 - shift;\r\n    fraction &= 0x7fffff;\r\n    if (exponent > 0) {\r\n      fraction = (fraction >> (126 - exponent)) + ((fraction >> (127 - exponent)) & 1);\r\n      float16View[0] = (sign << 15) | (exponent << 10) | (fraction >> 13);\r\n      return float16View[0];\r\n    } else {\r\n      float16View[0] = sign << 15;\r\n      return float16View[0];\r\n    }\r\n  }\r\n\r\n  // Normalized\r\n  exponent = exponent - 127 + 15;\r\n  if (exponent >= 31) { // Overflow\r\n    float16View[0] = (sign << 15) | 0x7c00;\r\n    return float16View[0];\r\n  }\r\n  if (exponent <= 0) { // Underflow\r\n    if (exponent < -10) {\r\n      float16View[0] = sign << 15;\r\n      return float16View[0];\r\n    }\r\n    fraction = (fraction | 0x800000) >> (1 - exponent);\r\n    float16View[0] = (sign << 15) | (fraction >> 13);\r\n    return float16View[0];\r\n  }\r\n\r\n  fraction = fraction >> 13;\r\n  float16View[0] = (sign << 15) | (exponent << 10) | fraction;\r\n  return float16View[0];\r\n}\r\n\r\nconst uint32 = new Uint32Array(1);\r\nconst uint32ToFloat32 = new Float32Array(uint32.buffer, 0, 1);\r\n\r\nexport function float11ToFloat32(f11: number): number {\r\n  const u32 = (((((f11) >> 6) & 0x1F) + (127 - 15)) << 23) | (((f11) & 0x3F) << 17);\r\n  uint32[0] = u32;\r\n  return uint32ToFloat32[0];\r\n}\r\n\r\nexport function float10ToFloat32(f10: number): number {\r\n  const u32 = (((((f10) >> 5) & 0x1F) + (127 - 15)) << 23) | (((f10) & 0x1F) << 18);\r\n  uint32[0] = u32;\r\n  return uint32ToFloat32[0];\r\n}\r\n","import { float16ToFloat32, float32ToFloat16, float10ToFloat32, float11ToFloat32 } from \"./float.js\";\r\n\r\nexport function setTexturePixel(imageData: Uint8Array, x: number, y: number, z: number, mipLevel: number,\r\n        height: number, bytesPerRow: number, texelByteSize: number, format: string, value: number[]): void {\r\n    bytesPerRow = bytesPerRow >> mipLevel;\r\n    height = height >> mipLevel;\r\n\r\n    const offset = (z * bytesPerRow * height) + y * bytesPerRow + x * texelByteSize;\r\n\r\n    switch (format) {\r\n        case \"r8unorm\": {\r\n            setPixelValue(imageData, offset, \"8unorm\", 1, value);\r\n            return;\r\n        }\r\n        case \"r8snorm\": {\r\n            setPixelValue(imageData, offset, \"8snorm\", 1, value);\r\n            return;\r\n        }\r\n        case \"r8uint\": {\r\n            setPixelValue(imageData, offset, \"8uint\", 1, value);\r\n            return;\r\n        }\r\n        case \"r8sint\": {\r\n            setPixelValue(imageData, offset, \"8sint\", 1, value);\r\n            return;\r\n        }\r\n\r\n        case \"rg8unorm\": {\r\n            setPixelValue(imageData, offset, \"8unorm\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg8snorm\": {\r\n            setPixelValue(imageData, offset, \"8snorm\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg8uint\": {\r\n            setPixelValue(imageData, offset, \"8uint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg8sint\": {\r\n            setPixelValue(imageData, offset, \"8sint\", 2, value);\r\n            return;\r\n        }\r\n\r\n        case \"rgba8unorm-srgb\":\r\n        case \"rgba8unorm\": {\r\n            setPixelValue(imageData, offset, \"8unorm\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba8snorm\": {\r\n            setPixelValue(imageData, offset, \"8snorm\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba8uint\": {\r\n            setPixelValue(imageData, offset, \"8uint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba8sint\": {\r\n            setPixelValue(imageData, offset, \"8sint\", 4, value);\r\n            return;\r\n        }\r\n\r\n        case \"bgra8unorm-srgb\":\r\n        case \"bgra8unorm\": {\r\n            setPixelValue(imageData, offset, \"8unorm\", 4, value);\r\n            return;\r\n        }\r\n\r\n        case \"r16uint\": {\r\n            setPixelValue(imageData, offset, \"16uint\", 1, value);\r\n            return;\r\n        }\r\n        case \"r16sint\": {\r\n            setPixelValue(imageData, offset, \"16sint\", 1, value);\r\n            return;\r\n        }\r\n        case \"r16float\": {\r\n            setPixelValue(imageData, offset, \"16float\", 1, value);\r\n            return;\r\n        }\r\n\r\n        case \"rg16uint\": {\r\n            setPixelValue(imageData, offset, \"16uint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg16sint\": {\r\n            setPixelValue(imageData, offset, \"16sint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg16float\": {\r\n            setPixelValue(imageData, offset, \"16float\", 2, value);\r\n            return;\r\n        }\r\n\r\n        case \"rgba16uint\": {\r\n            setPixelValue(imageData, offset, \"16uint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba16sint\": {\r\n            setPixelValue(imageData, offset, \"16sint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba16float\": {\r\n            setPixelValue(imageData, offset, \"16float\", 4, value);\r\n            return;\r\n        }\r\n\r\n        case \"r32uint\": {\r\n            setPixelValue(imageData, offset, \"32uint\", 1, value);\r\n            return;\r\n        }\r\n        case \"r32sint\": {\r\n            setPixelValue(imageData, offset, \"32sint\", 1, value);\r\n            return;\r\n        }\r\n        case \"depth16unorm\": // depth formats get conerted to r32float\r\n        case \"depth24plus\":\r\n        case \"depth24plus-stencil8\":\r\n        case \"depth32float\":\r\n        case \"depth32float-stencil8\":\r\n        case \"r32float\": {\r\n            setPixelValue(imageData, offset, \"32float\", 1, value);\r\n            return;\r\n        }\r\n        case \"rg32uint\": {\r\n            setPixelValue(imageData, offset, \"32uint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg32sint\": {\r\n            setPixelValue(imageData, offset, \"32sint\", 2, value);\r\n            return;\r\n        }\r\n        case \"rg32float\": {\r\n            setPixelValue(imageData, offset, \"32float\", 2, value);\r\n            return;\r\n        }\r\n        case \"rgba32uint\": {\r\n            setPixelValue(imageData, offset, \"32uint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba32sint\": {\r\n            setPixelValue(imageData, offset, \"32sint\", 4, value);\r\n            return;\r\n        }\r\n        case \"rgba32float\": {\r\n            setPixelValue(imageData, offset, \"32float\", 4, value);\r\n            return;\r\n        }\r\n\r\n        case \"rg11b10ufloat\": {\r\n            console.error(\"TODO: rg11b10ufloat not supported for writing\");\r\n            /*const uintValue = new Uint32Array(imageData.buffer, offset, 1)[0];\r\n            const ri = uintValue & 0x7FF;\r\n            const gi = (uintValue & 0x3FF800) >> 11;\r\n            const bi = (uintValue & 0xFFC00000) >> 22;\r\n            const rf = float11ToFloat32(ri);\r\n            const gf = float11ToFloat32(gi);\r\n            const bf = float10ToFloat32(bi);\r\n            return [rf, gf, bf, 1.0];*/\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getTexturePixel(imageData: Uint8Array, x: number, y: number, z: number, mipLevel: number,\r\n        height: number, bytesPerRow: number, texelByteSize: number, format: string): number[] | null {\r\n    bytesPerRow = bytesPerRow >> mipLevel;\r\n    height = height >> mipLevel;\r\n\r\n    const offset = (z * bytesPerRow * height) + y * bytesPerRow + x * texelByteSize;\r\n\r\n    switch (format) {\r\n        case \"r8unorm\": {\r\n            const value = pixelValue(imageData, offset, \"8unorm\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r8snorm\": {\r\n            const value = pixelValue(imageData, offset, \"8snorm\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r8uint\": {\r\n            const value = pixelValue(imageData, offset, \"8uint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r8sint\": {\r\n            const value = pixelValue(imageData, offset, \"8sint\", 1);\r\n            return [value[0]];\r\n        }\r\n\r\n        case \"rg8unorm\": {\r\n            const value = pixelValue(imageData, offset, \"8unorm\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg8snorm\": {\r\n            const value = pixelValue(imageData, offset, \"8snorm\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg8uint\": {\r\n            const value = pixelValue(imageData, offset, \"8uint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg8sint\": {\r\n            const value = pixelValue(imageData, offset, \"8sint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n\r\n        case \"rgba8unorm-srgb\":\r\n        case \"rgba8unorm\": {\r\n            const value = pixelValue(imageData, offset, \"8unorm\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba8snorm\": {\r\n            const value = pixelValue(imageData, offset, \"8snorm\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba8uint\": {\r\n            const value = pixelValue(imageData, offset, \"8uint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba8sint\": {\r\n            const value = pixelValue(imageData, offset, \"8sint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n\r\n        case \"bgra8unorm-srgb\":\r\n        case \"bgra8unorm\": {\r\n            const value = pixelValue(imageData, offset, \"8unorm\", 4);\r\n            return [value[2], value[1], value[0], value[3]];\r\n        }\r\n\r\n        case \"r16uint\": {\r\n            const value = pixelValue(imageData, offset, \"16uint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r16sint\": {\r\n            const value = pixelValue(imageData, offset, \"16sint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r16float\": {\r\n            const value = pixelValue(imageData, offset, \"16float\", 1);\r\n            return [value[0]];\r\n        }\r\n\r\n        case \"rg16uint\": {\r\n            const value = pixelValue(imageData, offset, \"16uint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg16sint\": {\r\n            const value = pixelValue(imageData, offset, \"16sint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg16float\": {\r\n            const value = pixelValue(imageData, offset, \"16float\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n\r\n        case \"rgba16uint\": {\r\n            const value = pixelValue(imageData, offset, \"16uint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba16sint\": {\r\n            const value = pixelValue(imageData, offset, \"16sint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba16float\": {\r\n            const value = pixelValue(imageData, offset, \"16float\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n\r\n        case \"r32uint\": {\r\n            const value = pixelValue(imageData, offset, \"32uint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"r32sint\": {\r\n            const value = pixelValue(imageData, offset, \"32sint\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"depth16unorm\": // depth formats get conerted to r32float\r\n        case \"depth24plus\":\r\n        case \"depth24plus-stencil8\":\r\n        case \"depth32float\":\r\n        case \"depth32float-stencil8\":\r\n        case \"r32float\": {\r\n            const value = pixelValue(imageData, offset, \"32float\", 1);\r\n            return [value[0]];\r\n        }\r\n        case \"rg32uint\": {\r\n            const value = pixelValue(imageData, offset, \"32uint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg32sint\": {\r\n            const value = pixelValue(imageData, offset, \"32sint\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rg32float\": {\r\n            const value = pixelValue(imageData, offset, \"32float\", 2);\r\n            return [value[0], value[1]];\r\n        }\r\n        case \"rgba32uint\": {\r\n            const value = pixelValue(imageData, offset, \"32uint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba32sint\": {\r\n            const value = pixelValue(imageData, offset, \"32sint\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n        case \"rgba32float\": {\r\n            const value = pixelValue(imageData, offset, \"32float\", 4);\r\n            return [value[0], value[1], value[2], value[3]];\r\n        }\r\n\r\n        case \"rg11b10ufloat\": {\r\n            const uintValue = new Uint32Array(imageData.buffer, offset, 1)[0];\r\n            const ri = uintValue & 0x7FF;\r\n            const gi = (uintValue & 0x3FF800) >> 11;\r\n            const bi = (uintValue & 0xFFC00000) >> 22;\r\n            const rf = float11ToFloat32(ri);\r\n            const gf = float11ToFloat32(gi);\r\n            const bf = float10ToFloat32(bi);\r\n            return [rf, gf, bf, 1.0];\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction pixelValue(imageData: Uint8Array, offset: number, format: string, numChannels: number) {\r\n    const value = [0, 0, 0, 0];\r\n    for (let i = 0; i < numChannels; ++i) {\r\n      switch (format) {\r\n        case \"8unorm\":\r\n          value[i] = imageData[offset] / 255;\r\n          offset++;\r\n          break;\r\n        case \"8snorm\":\r\n          value[i] = (imageData[offset] / 255) * 2 - 1;\r\n          offset++;\r\n          break;\r\n        case \"8uint\":\r\n          value[i] = imageData[offset];\r\n          offset++;\r\n          break;\r\n        case \"8sint\":\r\n          value[i] = imageData[offset] - 127;\r\n          offset++;\r\n          break;\r\n        case \"16uint\":\r\n          value[i] = imageData[offset] | (imageData[offset + 1] << 8);\r\n          offset += 2;\r\n          break;\r\n        case \"16sint\":\r\n          value[i] = (imageData[offset] | (imageData[offset + 1] << 8)) - 32768;\r\n          offset += 2;\r\n          break;\r\n        case \"16float\":\r\n          value[i] = float16ToFloat32(imageData[offset] | (imageData[offset + 1] << 8));\r\n          offset += 2;\r\n          break;\r\n        case \"32uint\":\r\n          value[i] = imageData[offset] | (imageData[offset + 1] << 8) | (imageData[offset + 2] << 16) | (imageData[offset + 3] << 24);\r\n          offset += 4;\r\n          break;\r\n        case \"32sint\":\r\n          value[i] = (imageData[offset] | (imageData[offset + 1] << 8) | (imageData[offset + 2] << 16) | (imageData[offset + 3] << 24)) | 0;\r\n          offset += 4;\r\n          break;\r\n        case \"32float\":\r\n          value[i] = new Float32Array(imageData.buffer, offset, 1)[0];\r\n          offset += 4;\r\n          break;\r\n      }\r\n    }\r\n    return value;\r\n}\r\n\r\nfunction setPixelValue(imageData: Uint8Array, offset: number, format: string, numChannels: number, value: number[]) {\r\n    for (let i = 0; i < numChannels; ++i) {\r\n      switch (format) {\r\n        case \"8unorm\":\r\n          imageData[offset] = value[i] * 255;\r\n          offset++;\r\n          break;\r\n        case \"8snorm\":\r\n          imageData[offset] = ((value[i] + 1.0) * 0.5) * 255;\r\n          offset++;\r\n          break;\r\n        case \"8uint\":\r\n          imageData[offset] = value[i];\r\n          offset++;\r\n          break;\r\n        case \"8sint\":\r\n          imageData[offset] = value[i] + 127;\r\n          offset++;\r\n          break;\r\n        case \"16uint\":\r\n          new Uint16Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 2;\r\n          break;\r\n        case \"16sint\":\r\n          new Int16Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 2;\r\n          break;\r\n        case \"16float\": {\r\n          const f16 = float32ToFloat16(value[i]);\r\n          new Uint16Array(imageData.buffer, offset, 1)[0] = f16;\r\n          offset += 2;\r\n          break;\r\n        }\r\n        case \"32uint\":\r\n          new Uint32Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 4;\r\n          break;\r\n        case \"32sint\":\r\n          new Int32Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 4;\r\n          break;\r\n        case \"32float\":\r\n          new Float32Array(imageData.buffer, offset, 1)[0] = value[i];\r\n          offset += 4;\r\n          break;\r\n      }\r\n    }\r\n    return value;\r\n}\r\n","\r\nexport const TextureFormatInfo = {\r\n    \"r8unorm\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r8snorm\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r8uint\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r8sint\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"rg8unorm\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg8snorm\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg8uint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg8sint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n\r\n    \"rgba8unorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba8unorm-srgb\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba8snorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba8uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba8sint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"bgra8unorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"bgra8unorm-srgb\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n\r\n    \"r16uint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r16sint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r16float\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n\r\n    \"rg16uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg16sint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg16float\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n\r\n    \"rgba16uint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba16sint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba16float\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n\r\n    \"r32uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r32sint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n    \"r32float\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 1 },\r\n\r\n    \"rg32uint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg32sint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n    \"rg32float\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 2 },\r\n\r\n    \"rgba32uint\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba32sint\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgba32float\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgb10a2uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rgb10a2unorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n    \"rg11b10ufloat\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n\r\n    // Depth Stencil Formats\r\n    \"stencil8\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": false, \"hasStencil\": true, \"channels\": 1 }, // bytesPerBlock is actually 1-4\r\n    \"depth16unorm\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": false, \"channels\": 1 },\r\n    \"depth24plus\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": false, \"depthOnlyFormat\": \"depth32float\", \"channels\": 1 },\r\n    \"depth24plus-stencil8\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": true, \"depthOnlyFormat\": \"depth32float\", \"channels\": 1 }, // bytesPerBlock is actually 4-8\r\n    \"depth32float\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": false, \"channels\": 1 },\r\n    \"depth32float-stencil8\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": true, \"stencilOnlyFormat\": \"depth32float\", \"channels\": 1 }, // bytesPerBlock is actually 5-8\r\n\r\n    // Packed Formats\r\n    \"rgb9e5ufloat\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"channels\": 4 },\r\n\r\n    // Compressed Formats\r\n    \"bc1-rgba-unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc1-rgba-unorm-srgb\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc2-rgba-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc2-rgba-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc3-rgba-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc3-rgba-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n\r\n    \"bc4-r-unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 1 },\r\n    \"bc4-r-snorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 1 },\r\n\r\n    \"bc5-rg-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 2 },\r\n    \"bc5-rg-snorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 2 },\r\n\r\n    \"bc6h-rgb-ufloat\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc6h-rgb-float\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc7-rgba-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"bc7-rgba-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \r\n    \"etc2-rgb8unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgb8unorm-srgb\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgb8a1unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgb8a1unorm-srgb\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgba8unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"etc2-rgba8unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \r\n    \"eac-r11unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true, \"channels\": 1 },\r\n    \"eac-r11snorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true, \"channels\": 1 },\r\n\r\n    \"eac-rg11unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true, \"channels\": 2 },\r\n    \"eac-rg11snorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true, \"channels\": 2 },\r\n\r\n    \"astc-4x4-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-4x4-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-5x4-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-5x4-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 4, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-5x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-5x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-6x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-6x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-6x6-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-6x6-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x6-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x6-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x8-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 8, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-8x8-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 8, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 5, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x6-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x6-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 6, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x8-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 8, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x8-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 8, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x10-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 10, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-10x10-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 10, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-12x10-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 10, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-12x10-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 10, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-12x12-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 12, \"isCompressed\": true, \"channels\": 4 },\r\n    \"astc-12x12-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 12, \"isCompressed\": true, \"channels\": 4 },\r\n};\r\n","import { WgslExec } from \"./wgsl_exec.js\";\r\nimport { TypeInfo, PointerInfo, TemplateInfo, ArrayInfo, StructInfo } from \"./reflect/info.js\";\r\nimport { ExecContext } from \"./exec/exec_context.js\";\r\nimport { ExecInterface } from \"./exec/exec_interface.js\";\r\nimport { setTexturePixel, getTexturePixel } from \"./utils/texture_sample.js\";\r\nimport { TextureFormatInfo } from \"./utils/texture_format_info.js\";\r\n\r\n/**\r\n * @class Node\r\n * @category AST\r\n * Base class for AST nodes parsed from a WGSL shader.\r\n */\r\nexport class Node {\r\n  static _id = 0;\r\n\r\n  id: number;\r\n  line: number;\r\n\r\n  constructor() {\r\n    this.id = Node._id++;\r\n    this.line = 0;\r\n  }\r\n\r\n  get isAstNode(): boolean {\r\n    return true;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n  }\r\n\r\n  searchBlock(block: Node[] | null, callback: (node: Node) => void): void {\r\n    if (block) {\r\n      callback(_BlockStart.instance);\r\n      for (const node of block) {\r\n        if (node instanceof Array) {\r\n          this.searchBlock(node as Node[], callback);\r\n        } else {\r\n          node.search(callback);\r\n        }\r\n      }\r\n      callback(_BlockEnd.instance);\r\n    }\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    throw new Error(\"Cannot evaluate node\");\r\n  }\r\n\r\n  constEvaluateString(context: WgslExec): string {\r\n    return this.constEvaluate(context).toString();\r\n  } \r\n}\r\n\r\n// For internal use only\r\nexport class _BlockStart extends Node {\r\n  static instance = new _BlockStart();\r\n}\r\n\r\n // For internal use only\r\nexport class _BlockEnd extends Node {\r\n  static instance = new _BlockEnd();\r\n}\r\n\r\nconst BuiltinFunctionNames = new Set([\r\n  \"all\",\r\n  \"all\",\r\n  \"any\",\r\n  \"select\",\r\n  \"arrayLength\",\r\n  \"abs\",\r\n  \"acos\",\r\n  \"acosh\",\r\n  \"asin\",\r\n  \"asinh\",\r\n  \"atan\",\r\n  \"atanh\",\r\n  \"atan2\",\r\n  \"ceil\",\r\n  \"clamp\",\r\n  \"cos\",\r\n  \"cosh\",\r\n  \"countLeadingZeros\",\r\n  \"countOneBits\",\r\n  \"countTrailingZeros\",\r\n  \"cross\",\r\n  \"degrees\",\r\n  \"determinant\",\r\n  \"distance\",\r\n  \"dot\",\r\n  \"dot4U8Packed\",\r\n  \"dot4I8Packed\",\r\n  \"exp\",\r\n  \"exp2\",\r\n  \"extractBits\",\r\n  \"faceForward\",\r\n  \"firstLeadingBit\",\r\n  \"firstTrailingBit\",\r\n  \"floor\",\r\n  \"fma\",\r\n  \"fract\",\r\n  \"frexp\",\r\n  \"insertBits\",\r\n  \"inverseSqrt\",\r\n  \"ldexp\",\r\n  \"length\",\r\n  \"log\",\r\n  \"log2\",\r\n  \"max\",\r\n  \"min\",\r\n  \"mix\",\r\n  \"modf\",\r\n  \"normalize\",\r\n  \"pow\",\r\n  \"quantizeToF16\",\r\n  \"radians\",\r\n  \"reflect\",\r\n  \"refract\",\r\n  \"reverseBits\",\r\n  \"round\",\r\n  \"saturate\",\r\n  \"sign\",\r\n  \"sin\",\r\n  \"sinh\",\r\n  \"smoothStep\",\r\n  \"sqrt\",\r\n  \"step\",\r\n  \"tan\",\r\n  \"tanh\",\r\n  \"transpose\",\r\n  \"trunc\",\r\n  \"dpdx\",\r\n  \"dpdxCoarse\",\r\n  \"dpdxFine\",\r\n  \"dpdy\",\r\n  \"dpdyCoarse\",\r\n  \"dpdyFine\",\r\n  \"fwidth\",\r\n  \"fwidthCoarse\",\r\n  \"fwidthFine\",\r\n  \"textureDimensions\",\r\n  \"textureGather\",\r\n  \"textureGatherCompare\",\r\n  \"textureLoad\",\r\n  \"textureNumLayers\",\r\n  \"textureNumLevels\",\r\n  \"textureNumSamples\",\r\n  \"textureSample\",\r\n  \"textureSampleBias\",\r\n  \"textureSampleCompare\",\r\n  \"textureSampleCompareLevel\",\r\n  \"textureSampleGrad\",\r\n  \"textureSampleLevel\",\r\n  \"textureSampleBaseClampToEdge\",\r\n  \"textureStore\",\r\n  \"atomicLoad\",\r\n  \"atomicStore\",\r\n  \"atomicAdd\",\r\n  \"atomicSub\",\r\n  \"atomicMax\",\r\n  \"atomicMin\",\r\n  \"atomicAnd\",\r\n  \"atomicOr\",\r\n  \"atomicXor\",\r\n  \"atomicExchange\",\r\n  \"atomicCompareExchangeWeak\",\r\n  \"pack4x8snorm\",\r\n  \"pack4x8unorm\",\r\n  \"pack4xI8\",\r\n  \"pack4xU8\",\r\n  \"pack4x8Clamp\",\r\n  \"pack4xU8Clamp\",\r\n  \"pack2x16snorm\",\r\n  \"pack2x16unorm\",\r\n  \"pack2x16float\",\r\n  \"unpack4x8snorm\",\r\n  \"unpack4x8unorm\",\r\n  \"unpack4xI8\",\r\n  \"unpack4xU8\",\r\n  \"unpack2x16snorm\",\r\n  \"unpack2x16unorm\",\r\n  \"unpack2x16float\",\r\n  \"storageBarrier\",\r\n  \"textureBarrier\",\r\n  \"workgroupBarrier\",\r\n  \"workgroupUniformLoad\",\r\n  \"subgroupAdd\",\r\n  \"subgroupExclusiveAdd\",\r\n  \"subgroupInclusiveAdd\",\r\n  \"subgroupAll\",\r\n  \"subgroupAnd\",\r\n  \"subgroupAny\",\r\n  \"subgroupBallot\",\r\n  \"subgroupBroadcast\",\r\n  \"subgroupBroadcastFirst\",\r\n  \"subgroupElect\",\r\n  \"subgroupMax\",\r\n  \"subgroupMin\",\r\n  \"subgroupMul\",\r\n  \"subgroupExclusiveMul\",\r\n  \"subgroupInclusiveMul\",\r\n  \"subgroupOr\",\r\n  \"subgroupShuffle\",\r\n  \"subgroupShuffleDown\",\r\n  \"subgroupShuffleUp\",\r\n  \"subgroupShuffleXor\",\r\n  \"subgroupXor\",\r\n  \"quadBroadcast\",\r\n  \"quadSwapDiagonal\",\r\n  \"quadSwapX\",\r\n  \"quadSwapY\",\r\n]);\r\n\r\n/**\r\n * @class Statement\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Statement extends Node {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * @class Function\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Function extends Statement {\r\n  name: string;\r\n  args: Argument[];\r\n  returnType: Type | null;\r\n  body: Statement[];\r\n  attributes: Attribute[] | null;\r\n  startLine: number;\r\n  endLine: number;\r\n  calls: Set<Function> = new Set();\r\n\r\n  constructor(\r\n    name: string,\r\n    args: Argument[],\r\n    returnType: Type | null,\r\n    body: Statement[],\r\n    startLine: number,\r\n    endLine: number\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.args = args;\r\n    this.returnType = returnType;\r\n    this.body = body;\r\n    this.startLine = startLine;\r\n    this.endLine = endLine;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"function\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    if (this.attributes) {\r\n      for (const attr of this.attributes) {\r\n        callback(attr);\r\n      }\r\n    }\r\n    callback(this);\r\n    for (const arg of this.args) {\r\n      callback(arg);\r\n    }\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class StaticAssert\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class StaticAssert extends Statement {\r\n  expression: Expression;\r\n\r\n  constructor(expression: Expression) {\r\n    super();\r\n    this.expression = expression;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"staticAssert\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.expression.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class While\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class While extends Statement {\r\n  condition: Expression;\r\n  body: Statement[];\r\n\r\n  constructor(condition: Expression, body: Statement[]) {\r\n    super();\r\n    this.condition = condition;\r\n    this.body = body;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"while\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.condition.search(callback);\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Continuing\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Continuing extends Statement {\r\n  body: Statement[];\r\n  loopId: number;\r\n\r\n  constructor(body: Statement[], loopId: number) {\r\n    super();\r\n    this.body = body;\r\n    this.loopId = loopId;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"continuing\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class For\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class For extends Statement {\r\n  init: Statement | null;\r\n  condition: Expression | null;\r\n  increment: Statement | null;\r\n  body: Statement[];\r\n\r\n  constructor(\r\n    init: Statement | null,\r\n    condition: Expression | null,\r\n    increment: Statement | null,\r\n    body: Statement[]\r\n  ) {\r\n    super();\r\n    this.init = init;\r\n    this.condition = condition;\r\n    this.increment = increment;\r\n    this.body = body;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"for\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.init?.search(callback);\r\n    this.condition?.search(callback);\r\n    this.increment?.search(callback);\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Var\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Var extends Statement {\r\n  name: string;\r\n  type: Type | null;\r\n  storage: string | null;\r\n  access: string | null;\r\n  value: Expression | null;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: Type | null,\r\n    storage: string | null,\r\n    access: string | null,\r\n    value: Expression | null\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.storage = storage;\r\n    this.access = access;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"var\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Override\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Override extends Statement {\r\n  name: string;\r\n  type: Type | null;\r\n  value: Expression | null;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(name: string, type: Type | null, value: Expression | null) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"override\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Let\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Let extends Statement {\r\n  name: string;\r\n  type: Type | null;\r\n  storage: string | null;\r\n  access: string | null;\r\n  value: Expression | null;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: Type | null,\r\n    storage: string | null,\r\n    access: string | null,\r\n    value: Expression | null\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.storage = storage;\r\n    this.access = access;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"let\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Const\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Const extends Statement {\r\n  name: string;\r\n  type: Type | null;\r\n  storage: string | null;\r\n  access: string | null;\r\n  value: Expression;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: Type | null,\r\n    storage: string | null,\r\n    access: string | null,\r\n    value: Expression\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.storage = storage;\r\n    this.access = access;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"const\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    return this.value.constEvaluate(context, type);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\nexport enum IncrementOperator {\r\n  increment = \"++\",\r\n  decrement = \"--\",\r\n}\r\n\r\nexport namespace IncrementOperator {\r\n  export function parse(val: string): IncrementOperator {\r\n    const key = val as keyof typeof IncrementOperator;\r\n    if (key == \"parse\") throw new Error(\"Invalid value for IncrementOperator\");\r\n    return IncrementOperator[key];\r\n  }\r\n}\r\n\r\n/**\r\n * @class Increment\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Increment extends Statement {\r\n  operator: IncrementOperator;\r\n  variable: Expression;\r\n\r\n  constructor(operator: IncrementOperator, variable: Expression) {\r\n    super();\r\n    this.operator = operator;\r\n    this.variable = variable;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"increment\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.variable.search(callback);\r\n  }\r\n}\r\n\r\nexport enum AssignOperator {\r\n  assign = \"=\",\r\n  addAssign = \"+=\",\r\n  subtractAssin = \"-=\",\r\n  multiplyAssign = \"*=\",\r\n  divideAssign = \"/=\",\r\n  moduloAssign = \"%=\",\r\n  andAssign = \"&=\",\r\n  orAssign = \"|=\",\r\n  xorAssign = \"^=\",\r\n  shiftLeftAssign = \"<<=\",\r\n  shiftRightAssign = \">>=\",\r\n}\r\n\r\nexport namespace AssignOperator {\r\n  export function parse(val: string): AssignOperator {\r\n    const key = val as keyof typeof AssignOperator;\r\n    if (key == \"parse\") {\r\n      throw new Error(\"Invalid value for AssignOperator\");\r\n    }\r\n    //return AssignOperator[key];\r\n    return key as AssignOperator;\r\n  }\r\n}\r\n\r\n/**\r\n * @class Assign\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Assign extends Statement {\r\n  operator: AssignOperator;\r\n  variable: Expression;\r\n  value: Expression;\r\n\r\n  constructor(\r\n    operator: AssignOperator,\r\n    variable: Expression,\r\n    value: Expression\r\n  ) {\r\n    super();\r\n    this.operator = operator;\r\n    this.variable = variable;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"assign\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.variable.search(callback);\r\n    this.value.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Call\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Call extends Statement {\r\n  name: string;\r\n  args: Expression[];\r\n\r\n  constructor(name: string, args: Expression[]) {\r\n    super();\r\n    this.name = name;\r\n    this.args = args;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"call\";\r\n  }\r\n\r\n  isBuiltin(): boolean {\r\n    return BuiltinFunctionNames.has(this.name);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    for (const node of this.args) {\r\n      node.search(callback);\r\n    }\r\n    callback(this);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Loop\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Loop extends Statement {\r\n  body: Statement[];\r\n  continuing: Continuing | null;\r\n\r\n  constructor(body: Statement[], continuing: Continuing | null) {\r\n    super();\r\n    this.body = body;\r\n    this.continuing = continuing;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"loop\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.body, callback);\r\n    this.continuing?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Switch\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Switch extends Statement {\r\n  condition: Expression;\r\n  cases: SwitchCase[];\r\n\r\n  constructor(condition: Expression, cases: SwitchCase[]) {\r\n    super();\r\n    this.condition = condition;\r\n    this.cases = cases;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"switch\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    for (const node of this.cases) {\r\n      node.search(callback);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @class If\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class If extends Statement {\r\n  condition: Expression;\r\n  body: Statement[];\r\n  elseif: ElseIf[] | null;\r\n  else: Statement[] | null;\r\n\r\n  constructor(\r\n    condition: Expression,\r\n    body: Statement[],\r\n    elseif: ElseIf[] | null,\r\n    _else: Statement[] | null\r\n  ) {\r\n    super();\r\n    this.condition = condition;\r\n    this.body = body;\r\n    this.elseif = elseif;\r\n    this.else = _else;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"if\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.condition.search(callback);\r\n    this.searchBlock(this.body, callback);\r\n    this.searchBlock(this.elseif, callback);\r\n    this.searchBlock(this.else, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Return\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Return extends Statement {\r\n  value: Expression;\r\n\r\n  constructor(value: Expression) {\r\n    super();\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"return\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.value?.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Enable\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Enable extends Statement {\r\n  name: string;\r\n\r\n  constructor(name: string) {\r\n    super();\r\n    this.name = name;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"enable\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Requires\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Requires extends Statement {\r\n  extensions: string[];\r\n\r\n  constructor(extensions: string[]) {\r\n    super();\r\n    this.extensions = extensions;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"requires\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Diagnostic\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Diagnostic extends Statement {\r\n  severity: string;\r\n  rule: string;\r\n\r\n  constructor(severity: string, rule: string) {\r\n    super();\r\n    this.severity = severity;\r\n    this.rule = rule;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"diagnostic\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Alias\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Alias extends Statement {\r\n  name: string;\r\n  type: Type;\r\n\r\n  constructor(name: string, type: Type) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"alias\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Discard\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Discard extends Statement {\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"discard\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Break\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Break extends Statement {\r\n  condition: Expression | null = null;\r\n  loopId: number = -1;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"break\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Continue\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Continue extends Statement {\r\n  loopId: number = -1;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"continue\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Type\r\n * @extends Statement\r\n * @category AST\r\n */\r\nexport class Type extends Statement {\r\n  name: string;\r\n  attributes: Attribute[] | null = null;\r\n\r\n  constructor(name: string) {\r\n    super();\r\n    this.name = name;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"type\";\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return false;\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return false;\r\n  }\r\n\r\n  static x32 = new Type(\"x32\");\r\n  static f32 = new Type(\"f32\");\r\n  static i32 = new Type(\"i32\");\r\n  static u32 = new Type(\"u32\");\r\n  static f16 = new Type(\"f16\");\r\n  static bool = new Type(\"bool\");\r\n  static void = new Type(\"void\");\r\n\r\n  static _priority = new Map<string, number>([[\"f32\", 0], [\"f16\", 1], [\"u32\", 2], [\"i32\", 3], [\"x32\", 3]]);\r\n\r\n  static maxFormatType(x: Type[]): Type {\r\n    let t = x[0];\r\n    if (t.name === \"f32\") {\r\n      return t;\r\n    }\r\n    for (let i = 1; i < x.length; ++i) {\r\n      const tv = Type._priority.get(t.name);\r\n      const xv = Type._priority.get(x[i].name);\r\n      if (xv < tv) {\r\n        t = x[i];\r\n      }\r\n    }\r\n\r\n    if (t.name === \"x32\") {\r\n      return Type.i32;\r\n    }\r\n\r\n    return t;\r\n  }\r\n\r\n  getTypeName(): string {\r\n    return this.name;\r\n  }\r\n}\r\n\r\n/**\r\n * @class ForwardType\r\n * @extends Type\r\n * @category AST\r\n * Internal type used as a placeholder for a type being used before it has been defined.\r\n */\r\nexport class ForwardType extends Type {\r\n  constructor(name: string) {\r\n    super(name);\r\n  }\r\n}\r\n\r\n/**\r\n * @class StructType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class Struct extends Type {\r\n  members: Member[];\r\n  startLine: number;\r\n  endLine: number;\r\n\r\n  constructor(name: string, members: Member[], startLine: number, endLine: number) {\r\n    super(name);\r\n    this.members = members;\r\n    this.startLine = startLine;\r\n    this.endLine = endLine;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"struct\";\r\n  }\r\n\r\n  get isStruct(): boolean {\r\n    return true;\r\n  }\r\n\r\n  /// Return the index of the member with the given name, or -1 if not found.\r\n  getMemberIndex(name: string): number {\r\n    for (let i = 0; i < this.members.length; i++) {\r\n      if (this.members[i].name == name) return i;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    for (const member of this.members) {\r\n      callback(member);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @class TemplateType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class TemplateType extends Type {\r\n  format: Type | null;\r\n  access: string | null;\r\n\r\n  constructor(name: string, format: Type | null, access: string | null) {\r\n    super(name);\r\n    this.format = format;\r\n    this.access = access;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"template\";\r\n  }\r\n\r\n  getTypeName(): string {\r\n    let name = this.name;\r\n    if (this.format !== null) {\r\n      if (name === \"vec2\" || name === \"vec3\" || name === \"vec4\" ||\r\n          name === \"mat2x2\" || name === \"mat2x3\" || name === \"mat2x4\" ||\r\n          name === \"mat3x2\" || name === \"mat3x3\" || name === \"mat3x4\" ||\r\n          name === \"mat4x2\" || name === \"mat4x3\" || name === \"mat4x4\") {\r\n        if (this.format.name === \"f32\") {\r\n          name += \"f\";\r\n          return name;\r\n        } else if (this.format.name === \"i32\") {\r\n          name += \"i\";\r\n          return name;\r\n        } else if (this.format.name === \"u32\") {\r\n          name += \"u\";\r\n          return name;\r\n        } else if (this.format.name === \"bool\") {\r\n          name += \"b\";\r\n          return name;\r\n        } else if (this.format.name === \"f16\") {\r\n          name += \"h\";\r\n          return name;\r\n        }\r\n      }\r\n      name += `<${this.format.name}>`;\r\n    } else {\r\n      if (name === \"vec2\" || name === \"vec3\" || name === \"vec4\") {\r\n        return name;\r\n      }\r\n      //console.error(\"Template format is null.\");\r\n    }\r\n    return name;\r\n  }\r\n\r\n  static vec2f = new TemplateType(\"vec2\", Type.f32, null);\r\n  static vec3f = new TemplateType(\"vec3\", Type.f32, null);\r\n  static vec4f = new TemplateType(\"vec4\", Type.f32, null);\r\n  static vec2i = new TemplateType(\"vec2\", Type.i32, null);\r\n  static vec3i = new TemplateType(\"vec3\", Type.i32, null);\r\n  static vec4i = new TemplateType(\"vec4\", Type.i32, null);\r\n  static vec2u = new TemplateType(\"vec2\", Type.u32, null);\r\n  static vec3u = new TemplateType(\"vec3\", Type.u32, null);\r\n  static vec4u = new TemplateType(\"vec4\", Type.u32, null);\r\n  static vec2h = new TemplateType(\"vec2\", Type.f16, null);\r\n  static vec3h = new TemplateType(\"vec3\", Type.f16, null);\r\n  static vec4h = new TemplateType(\"vec4\", Type.f16, null);\r\n  static vec2b = new TemplateType(\"vec2\", Type.bool, null);\r\n  static vec3b = new TemplateType(\"vec3\", Type.bool, null);\r\n  static vec4b = new TemplateType(\"vec4\", Type.bool, null);\r\n\r\n  static mat2x2f = new TemplateType(\"mat2x2\", Type.f32, null);\r\n  static mat2x3f = new TemplateType(\"mat2x3\", Type.f32, null);\r\n  static mat2x4f = new TemplateType(\"mat2x4\", Type.f32, null);\r\n  static mat3x2f = new TemplateType(\"mat3x2\", Type.f32, null);\r\n  static mat3x3f = new TemplateType(\"mat3x3\", Type.f32, null);\r\n  static mat3x4f = new TemplateType(\"mat3x4\", Type.f32, null);\r\n  static mat4x2f = new TemplateType(\"mat4x2\", Type.f32, null);\r\n  static mat4x3f = new TemplateType(\"mat4x3\", Type.f32, null);\r\n  static mat4x4f = new TemplateType(\"mat4x4\", Type.f32, null);\r\n\r\n  static mat2x2h = new TemplateType(\"mat2x2\", Type.f16, null);\r\n  static mat2x3h = new TemplateType(\"mat2x3\", Type.f16, null);\r\n  static mat2x4h = new TemplateType(\"mat2x4\", Type.f16, null);\r\n  static mat3x2h = new TemplateType(\"mat3x2\", Type.f16, null);\r\n  static mat3x3h = new TemplateType(\"mat3x3\", Type.f16, null);\r\n  static mat3x4h = new TemplateType(\"mat3x4\", Type.f16, null);\r\n  static mat4x2h = new TemplateType(\"mat4x2\", Type.f16, null);\r\n  static mat4x3h = new TemplateType(\"mat4x3\", Type.f16, null);\r\n  static mat4x4h = new TemplateType(\"mat4x4\", Type.f16, null);\r\n\r\n  static mat2x2i = new TemplateType(\"mat2x2\", Type.i32, null);\r\n  static mat2x3i = new TemplateType(\"mat2x3\", Type.i32, null);\r\n  static mat2x4i = new TemplateType(\"mat2x4\", Type.i32, null);\r\n  static mat3x2i = new TemplateType(\"mat3x2\", Type.i32, null);\r\n  static mat3x3i = new TemplateType(\"mat3x3\", Type.i32, null);\r\n  static mat3x4i = new TemplateType(\"mat3x4\", Type.i32, null);\r\n  static mat4x2i = new TemplateType(\"mat4x2\", Type.i32, null);\r\n  static mat4x3i = new TemplateType(\"mat4x3\", Type.i32, null);\r\n  static mat4x4i = new TemplateType(\"mat4x4\", Type.i32, null);\r\n\r\n  static mat2x2u = new TemplateType(\"mat2x2\", Type.u32, null);\r\n  static mat2x3u = new TemplateType(\"mat2x3\", Type.u32, null);\r\n  static mat2x4u = new TemplateType(\"mat2x4\", Type.u32, null);\r\n  static mat3x2u = new TemplateType(\"mat3x2\", Type.u32, null);\r\n  static mat3x3u = new TemplateType(\"mat3x3\", Type.u32, null);\r\n  static mat3x4u = new TemplateType(\"mat3x4\", Type.u32, null);\r\n  static mat4x2u = new TemplateType(\"mat4x2\", Type.u32, null);\r\n  static mat4x3u = new TemplateType(\"mat4x3\", Type.u32, null);\r\n  static mat4x4u = new TemplateType(\"mat4x4\", Type.u32, null);\r\n}\r\n\r\n/**\r\n * @class PointerType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class PointerType extends Type {\r\n  storage: string;\r\n  type: Type | null;\r\n  access: string | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    storage: string,\r\n    type: Type | null,\r\n    access: string | null\r\n  ) {\r\n    super(name);\r\n    this.storage = storage;\r\n    this.type = type;\r\n    this.access = access;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"pointer\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class ArrayType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class ArrayType extends Type {\r\n  attributes: Attribute[] | null;\r\n  format: Type | null;\r\n  count: number;\r\n\r\n  constructor(\r\n    name: string,\r\n    attributes: Attribute[] | null,\r\n    format: Type | null,\r\n    count: number\r\n  ) {\r\n    super(name);\r\n    this.attributes = attributes;\r\n    this.format = format;\r\n    this.count = count;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"array\";\r\n  }\r\n\r\n  get isArray(): boolean {\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @class SamplerType\r\n * @extends Type\r\n * @category AST\r\n */\r\nexport class SamplerType extends Type {\r\n  format: Type | string | null;\r\n  access: string | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    format: Type | string | null,\r\n    access: string | null\r\n  ) {\r\n    super(name);\r\n    this.format = format;\r\n    this.access = access;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"sampler\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Expression\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Expression extends Node {\r\n  postfix: Expression | null = null;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * @class StringExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class StringExpr extends Expression {\r\n  value: string;\r\n\r\n  constructor(value: string) {\r\n    super();\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"stringExpr\";\r\n  }\r\n\r\n  toString(): string {\r\n    return this.value;\r\n  }\r\n\r\n  constEvaluateString(): string {\r\n    return this.value;\r\n  }\r\n}\r\n\r\n/**\r\n * @class CreateExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class CreateExpr extends Expression {\r\n  type: Type | null;\r\n  args: Expression[] | null;\r\n\r\n  constructor(type: Type | null, args: Expression[] | null) {\r\n    super();\r\n    this.type = type;\r\n    this.args = args;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"createExpr\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    if (this.args) {\r\n      for (const node of this.args) {\r\n        node.search(callback);\r\n      }\r\n    }\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    if (type) {\r\n      type[0] = this.type;\r\n    }\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n}\r\n\r\n/**\r\n * @class CallExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class CallExpr extends Expression {\r\n  name: string;\r\n  args: Expression[] | null;\r\n  cachedReturnValue: any = null;\r\n\r\n  constructor(name: string, args: Expression[] | null) {\r\n    super();\r\n    this.name = name;\r\n    this.args = args;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"callExpr\";\r\n  }\r\n\r\n  setCachedReturnValue(value: any): void {\r\n    this.cachedReturnValue = value;\r\n  }\r\n\r\n  get isBuiltin(): boolean {\r\n    return BuiltinFunctionNames.has(this.name);\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n\r\n  search(callback: (node: Node) => void) {\r\n    for (const node of this.args) {\r\n      node.search(callback);\r\n    }\r\n    callback(this);\r\n  }\r\n}\r\n\r\n/**\r\n * @class VariableExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class VariableExpr extends Expression {\r\n  name: string;\r\n\r\n  constructor(name: string) {\r\n    super();\r\n    this.name = name;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"varExpr\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void) {\r\n    callback(this);\r\n    if (this.postfix) {\r\n      this.postfix.search(callback);\r\n    }\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n}\r\n\r\n/**\r\n * @class ConstExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class ConstExpr extends Expression {\r\n  name: string;\r\n  initializer: Expression;\r\n\r\n  constructor(name: string, initializer: Expression) {\r\n    super();\r\n    this.name = name;\r\n    this.initializer = initializer;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"constExpr\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    if (this.initializer) {\r\n      const data = context.evalExpression(this.initializer, context.context);\r\n      if (data !== null && this.postfix) {\r\n        return data.getSubData(context, this.postfix, context.context);\r\n      }\r\n      return data;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.initializer.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class LiteralExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class LiteralExpr extends Expression {\r\n  value: Data\r\n  type: Type;\r\n\r\n  constructor(value: Data, type: Type) {\r\n    super();\r\n    this.value = value;\r\n    this.type = type;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"literalExpr\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    if (type !== undefined) {\r\n      type[0] = this.type;\r\n    }\r\n    return this.value;\r\n  }\r\n\r\n  get isScalar(): boolean {\r\n    return this.value instanceof ScalarData;\r\n  }\r\n\r\n  get isVector(): boolean {\r\n    return this.value instanceof VectorData || this.value instanceof MatrixData;\r\n  }\r\n\r\n  get scalarValue(): number {\r\n    if (this.value instanceof ScalarData) {\r\n      return this.value.value;\r\n    }\r\n    console.error(\"Value is not scalar.\");\r\n    return 0.0;\r\n  }\r\n\r\n  get vectorValue(): Float32Array | Int32Array | Uint32Array {\r\n    if (this.value instanceof VectorData) {\r\n      return this.value.data;\r\n    }\r\n    if (this.value instanceof MatrixData) {\r\n      return this.value.data;\r\n    }\r\n    console.error(\"Value is not a vector or matrix.\");\r\n    return new Float32Array(0);\r\n  }\r\n}\r\n\r\n/**\r\n * @class BitcastExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class BitcastExpr extends Expression {\r\n  type: Type | null;\r\n  value: Expression;\r\n\r\n  constructor(type: Type | null, value: Expression) {\r\n    super();\r\n    this.type = type;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"bitcastExpr\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.value.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class TypecastExpr\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class TypecastExpr extends Expression {\r\n  type: Type | null;\r\n  args: Expression[] | null;\r\n\r\n  constructor(type: Type | null, args: Expression[] | null) {\r\n    super();\r\n    this.type = type;\r\n    this.args = args;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"typecastExpr\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.args, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class ArrayIndex\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class ArrayIndex extends Expression {\r\n  index: Expression;\r\n  constructor(index: Expression) {\r\n    super();\r\n    this.index = index;\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.index.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Operator\r\n * @extends Expression\r\n * @category AST\r\n */\r\nexport class Operator extends Expression {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * @class UnaryOperator\r\n * @extends Operator\r\n * @category AST\r\n * @property {string} operator +, -, !, ~\r\n */\r\nexport class UnaryOperator extends Operator {\r\n  operator: string;\r\n  right: Expression;\r\n\r\n  constructor(operator: string, right: Expression) {\r\n    super();\r\n    this.operator = operator;\r\n    this.right = right;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"unaryOp\";\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.right.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class BinaryOperator\r\n * @extends Operator\r\n * @category AST\r\n * @property {string} operator +, -, *, /, %, ==, !=, <, >, <=, >=, &&, ||\r\n */\r\nexport class BinaryOperator extends Operator {\r\n  operator: string;\r\n  left: Expression;\r\n  right: Expression;\r\n\r\n  constructor(operator: string, left: Expression, right: Expression) {\r\n    super();\r\n    this.operator = operator;\r\n    this.left = left;\r\n    this.right = right;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"binaryOp\";\r\n  }\r\n\r\n  _getPromotedType(t1: Type, t2: Type): Type {\r\n    if (t1.name === t2.name) {\r\n      return t1;\r\n    }\r\n    if (t1.name === \"f32\" || t2.name === \"f32\") {\r\n      return Type.f32;\r\n    }\r\n    if (t1.name === \"u32\" || t2.name === \"u32\") {\r\n      return Type.u32;\r\n    }\r\n    return Type.i32;\r\n  }\r\n\r\n  constEvaluate(context: WgslExec, type?: Type[]): Data | null {\r\n    return context.evalExpression(this, context.context);\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.left.search(callback);\r\n    this.right.search(callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class SwitchCase\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class SwitchCase extends Node {\r\n  body: Statement[];\r\n\r\n  constructor(body: Statement[]) {\r\n    super();\r\n    this.body = body;\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    callback(this);\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\nexport class DefaultSelector extends Expression {\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"default\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Case\r\n * @extends SwitchCase\r\n * @category AST\r\n */\r\nexport class Case extends SwitchCase {\r\n  selectors: Expression[];\r\n\r\n  constructor(selectors: Expression[], body: Statement[]) {\r\n    super(body);\r\n    this.selectors = selectors;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"case\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Default\r\n * @extends SwitchCase\r\n * @category AST\r\n */\r\nexport class Default extends SwitchCase {\r\n  constructor(body: Statement[]) {\r\n    super(body);\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"default\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Argument\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Argument extends Node {\r\n  name: string;\r\n  type: Type;\r\n  attributes: Attribute[] | null;\r\n\r\n  constructor(name: string, type: Type, attributes: Attribute[] | null) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"argument\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class ElseIf\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class ElseIf extends Node {\r\n  condition: Expression;\r\n  body: Statement[];\r\n\r\n  constructor(condition: Expression, body: Statement[]) {\r\n    super();\r\n    this.condition = condition;\r\n    this.body = body;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"elseif\";\r\n  }\r\n\r\n  search(callback: (node: Node) => void): void {\r\n    this.condition.search(callback);\r\n    this.searchBlock(this.body, callback);\r\n  }\r\n}\r\n\r\n/**\r\n * @class Member\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Member extends Node {\r\n  name: string;\r\n  type: Type | null;\r\n  attributes: Attribute[] | null;\r\n\r\n  constructor(\r\n    name: string,\r\n    type: Type | null,\r\n    attributes: Attribute[] | null\r\n  ) {\r\n    super();\r\n    this.name = name;\r\n    this.type = type;\r\n    this.attributes = attributes;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"member\";\r\n  }\r\n}\r\n\r\n/**\r\n * @class Attribute\r\n * @extends Node\r\n * @category AST\r\n */\r\nexport class Attribute extends Node {\r\n  name: string;\r\n  value: string | string[] | null;\r\n\r\n  constructor(name: string, value: string | string[] | null) {\r\n    super();\r\n    this.name = name;\r\n    this.value = value;\r\n  }\r\n\r\n  get astNodeType(): string {\r\n    return \"attribute\";\r\n  }\r\n}\r\n\r\n\r\n\r\nexport class Data {\r\n  static _id = 0;\r\n\r\n  typeInfo: TypeInfo;\r\n  parent: Data | null = null;\r\n  id: number;\r\n\r\n  constructor(typeInfo: TypeInfo, parent: Data | null) {\r\n      this.typeInfo = typeInfo;\r\n      this.parent = parent;\r\n      this.id = Data._id++;\r\n  }\r\n\r\n  clone(): Data {\r\n    throw `Clone: Not implemented for ${this.constructor.name}`;\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n      console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n      console.error(`GetDataValue: Not implemented for ${this.constructor.name}`);\r\n      return null;\r\n  }\r\n\r\n  toString(): string {\r\n      return `<${this.typeInfo.getTypeName()}>`;\r\n  }\r\n}\r\n\r\nexport class VoidData extends Data {\r\n  constructor() {\r\n      super(new TypeInfo(\"void\", null), null);\r\n  }\r\n\r\n  static void = new VoidData();\r\n\r\n  toString(): string {\r\n      return \"void\";\r\n  }\r\n}\r\n\r\nexport class PointerData extends Data {\r\n  reference: Data;\r\n\r\n  constructor(reference: Data) {\r\n    super(new PointerInfo(\"pointer\", reference.typeInfo, null), null);\r\n    this.reference = reference;\r\n  }\r\n\r\n  clone(): Data {\r\n    return this;\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    this.reference.setDataValue(exec, value, postfix, context);\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix) {\r\n      return this.reference.getSubData(exec, postfix, context);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  toString() {\r\n    return `&${this.reference.toString()}`;\r\n  }\r\n}\r\n\r\nexport class ScalarData extends Data {\r\n  data: Int32Array | Uint32Array | Float32Array;\r\n\r\n  constructor(value: number | Int32Array | Uint32Array | Float32Array, typeInfo: TypeInfo, parent: Data | null = null) {\r\n    super(typeInfo, parent);\r\n    if (value instanceof Int32Array || value instanceof Uint32Array || value instanceof Float32Array) {\r\n        this.data = value;\r\n    } else {\r\n      if (this.typeInfo.name === \"x32\") {\r\n        if (value - Math.floor(value) !== 0) {\r\n          this.data = new Float32Array([value]);\r\n        } else if (value >= 0) {\r\n            this.data = new Uint32Array([value]);\r\n        } else {\r\n            this.data = new Int32Array([value]);\r\n        } \r\n      } else if (this.typeInfo.name === \"i32\" || this.typeInfo.name === \"bool\") {\r\n          this.data = new Int32Array([value]);\r\n      } else if (this.typeInfo.name === \"u32\") {\r\n          this.data = new Uint32Array([value]);\r\n      } else if (this.typeInfo.name === \"f32\" || this.typeInfo.name === \"f16\") {\r\n          this.data = new Float32Array([value]);\r\n      } else {\r\n          console.error(`ScalarData2: Invalid type`, typeInfo);\r\n      }\r\n    }\r\n  }\r\n\r\n  clone(): Data {\r\n    if (this.data instanceof Float32Array) {\r\n        return new ScalarData(new Float32Array(this.data), this.typeInfo, null);\r\n    } else if (this.data instanceof Int32Array) {\r\n        return new ScalarData(new Int32Array(this.data), this.typeInfo, null);\r\n    } else if (this.data instanceof Uint32Array) {\r\n        return new ScalarData(new Uint32Array(this.data), this.typeInfo, null);\r\n    }\r\n    throw `ScalarData: Invalid data type`;\r\n  }\r\n\r\n  get value(): number {\r\n    return this.data[0];\r\n  }\r\n\r\n  set value(v: number) {\r\n    this.data[0] = v;\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    if (postfix) {\r\n      console.error(`SetDataValue: Scalar data does not support postfix`, postfix);\r\n      return;\r\n    }\r\n\r\n    if (!(value instanceof ScalarData)) {\r\n      console.error(`SetDataValue: Invalid value`, value);\r\n      return;\r\n    }\r\n\r\n    let v = value.data[0];\r\n\r\n    if (this.typeInfo.name === \"i32\" || this.typeInfo.name === \"u32\") {\r\n      v = Math.floor(v);\r\n    } else if (this.typeInfo.name === \"bool\") {\r\n      v = v ? 1 : 0;\r\n    }\r\n\r\n    this.data[0] = v;\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix) {\r\n      console.error(`getSubData: Scalar data does not support postfix`, postfix);\r\n      return null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  toString(): string {\r\n    return `${this.value}`;\r\n  }\r\n}\r\n\r\nfunction _getVectorData(exec: ExecInterface, values: number[], formatName: string): VectorData | null {\r\n  const size = values.length;\r\n  if (size === 2) {\r\n      if (formatName === \"f32\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec2f\")!);\r\n      } else if (formatName === \"i32\" || formatName === \"bool\") {\r\n          return new VectorData(new Int32Array(values), exec.getTypeInfo(\"vec2i\")!);\r\n      } else if (formatName === \"u32\") {\r\n          return new VectorData(new Uint32Array(values), exec.getTypeInfo(\"vec2u\")!);\r\n      } else if (formatName === \"f16\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec2h\")!);\r\n      } else {\r\n          console.error(`getSubData: Unknown format ${formatName}`);\r\n      }\r\n      return null;\r\n  }\r\n\r\n  if (size === 3) {\r\n      if (formatName === \"f32\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec3f\")!);\r\n      } else if (formatName === \"i32\" || formatName === \"bool\") {\r\n          return new VectorData(new Int32Array(values), exec.getTypeInfo(\"vec3i\")!);\r\n      } else if (formatName === \"u32\") {\r\n          return new VectorData(new Uint32Array(values), exec.getTypeInfo(\"vec3u\")!);\r\n      } else if (formatName === \"f16\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec3h\")!);\r\n      } else {\r\n          console.error(`getSubData: Unknown format ${formatName}`);\r\n      }\r\n      return null;\r\n  }\r\n\r\n  if (size === 4) {\r\n      if (formatName === \"f32\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec4f\")!);\r\n      } else if (formatName === \"i32\" || formatName === \"bool\") {\r\n          return new VectorData(new Int32Array(values), exec.getTypeInfo(\"vec4i\")!);\r\n      } else if (formatName === \"u32\") {\r\n          return new VectorData(new Uint32Array(values), exec.getTypeInfo(\"vec4u\")!);\r\n      } else if (formatName === \"f16\") {\r\n          return new VectorData(new Float32Array(values), exec.getTypeInfo(\"vec4h\")!);\r\n      }\r\n      console.error(`getSubData: Unknown format ${formatName}`);\r\n      return null;\r\n  }\r\n\r\n  console.error(`getSubData: Invalid vector size ${values.length}`);\r\n  return null;\r\n}\r\n\r\nexport class VectorData extends Data {\r\n  data: Int32Array | Uint32Array | Float32Array;\r\n\r\n  constructor(value: number[] | Float32Array | Uint32Array | Int32Array, typeInfo: TypeInfo, parent: Data | null = null) {\r\n    super(typeInfo, parent);\r\n    if (value instanceof Float32Array || value instanceof Uint32Array || value instanceof Int32Array) {\r\n      this.data = value;\r\n    } else {\r\n      const typename = this.typeInfo.name;\r\n      if (typename === \"vec2f\" || typename === \"vec3f\" || typename === \"vec4f\") {\r\n        this.data = new Float32Array(value);\r\n      } else if (typename === \"vec2i\" || typename === \"vec3i\" || typename === \"vec4i\") {\r\n        this.data = new Int32Array(value);\r\n      } else if (typename === \"vec2u\" || typename === \"vec3u\" || typename === \"vec4u\") {\r\n        this.data = new Uint32Array(value);\r\n      } else if (typename === \"vec2h\" || typename === \"vec3h\" || typename === \"vec4h\") {\r\n        this.data = new Float32Array(value);\r\n      } else if (typename === \"vec2b\" || typename === \"vec3b\" || typename === \"vec4b\") {\r\n        this.data = new Int32Array(value);\r\n      } else if (typename === \"vec2\" || typename === \"vec3\" || typename === \"vec4\") {\r\n        this.data = new Float32Array(value);\r\n      } else {\r\n        console.error(`VectorData: Invalid type ${typename}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  clone(): Data {\r\n    if (this.data instanceof Float32Array) {\r\n      return new VectorData(new Float32Array(this.data), this.typeInfo, null);\r\n    } else if (this.data instanceof Int32Array) {\r\n      return new VectorData(new Int32Array(this.data), this.typeInfo, null);\r\n    } else if (this.data instanceof Uint32Array) {\r\n      return new VectorData(new Uint32Array(this.data), this.typeInfo, null);\r\n    }\r\n    throw `VectorData: Invalid data type`;\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    if (postfix instanceof StringExpr) {\r\n      console.error(\"TODO: Set vector postfix\");\r\n      return;\r\n    }\r\n\r\n    if (!(value instanceof VectorData)) {\r\n      console.error(`SetDataValue: Invalid value`, value);\r\n      return\r\n    }\r\n\r\n    this.data = value.data;\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix === null) {\r\n      return this;\r\n    }\r\n\r\n    let format = exec.getTypeInfo(\"f32\");\r\n    if (this.typeInfo instanceof TemplateInfo) {\r\n        format = this.typeInfo.format || format;\r\n    } else {\r\n        const typeName = this.typeInfo.name;\r\n        if (typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\") {\r\n          format = exec.getTypeInfo(\"f32\");\r\n        } else if (typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\") {\r\n          format = exec.getTypeInfo(\"i32\");\r\n        } else if (typeName === \"vec2b\" || typeName === \"vec3b\" || typeName === \"vec4b\") {\r\n          format = exec.getTypeInfo(\"bool\");\r\n        } else if (typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\") {\r\n          format = exec.getTypeInfo(\"u32\");\r\n        } else if ( typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\") {\r\n          format = exec.getTypeInfo(\"f16\");\r\n        } else {\r\n          console.error(`GetSubData: Unknown type ${typeName}`);\r\n        }\r\n    }\r\n\r\n    let self: VectorData | null = this;\r\n    while (postfix !== null && self !== null) {\r\n      if (postfix instanceof ArrayIndex) {\r\n        const idx = postfix.index;\r\n        let i = -1;\r\n        if (idx instanceof LiteralExpr) {\r\n          if (idx.value instanceof ScalarData) {\r\n            i = idx.value.value;\r\n          } else {\r\n            console.error(`GetSubData: Invalid array index ${idx.value}`);\r\n            return null;\r\n          }\r\n        } else {\r\n          const d = exec.evalExpression(idx, context);\r\n          if (d instanceof ScalarData) {\r\n            i = d.value;\r\n          } else {\r\n            console.error(`GetSubData: Unknown index type`, idx);\r\n            return null;\r\n          }\r\n        }\r\n        if (i < 0 || i >= self.data.length) {\r\n          console.error(`GetSubData: Index out of range`, i);\r\n          return null;\r\n        }\r\n\r\n        if (self.data instanceof Float32Array) {\r\n          const d = new Float32Array(self.data.buffer, self.data.byteOffset + i * 4, 1);\r\n          return new ScalarData(d, format!);\r\n        } else if (self.data instanceof Int32Array) {\r\n          const d = new Int32Array(self.data.buffer, self.data.byteOffset + i * 4, 1);\r\n          return new ScalarData(d, format!);\r\n        } else if (self.data instanceof Uint32Array) {\r\n          const d = new Uint32Array(self.data.buffer, self.data.byteOffset + i * 4, 1);\r\n          return new ScalarData(d, format!);\r\n        }\r\n\r\n        throw `GetSubData: Invalid data type`;\r\n      } else if (postfix instanceof StringExpr) {\r\n        const member = postfix.value.toLowerCase();\r\n        if (member.length === 1) {\r\n          let i = 0;\r\n          if (member === \"x\" || member === \"r\") {\r\n            i = 0;\r\n          } else if (member === \"y\" || member === \"g\") {\r\n            i = 1;\r\n          } else if (member === \"z\" || member === \"b\") {\r\n            i = 2;\r\n          } else if (member === \"w\" || member === \"a\") {\r\n            i = 3;\r\n          } else {\r\n            console.error(`GetSubData: Unknown member ${member}`);\r\n            return null;\r\n          }\r\n\r\n          if (this.data instanceof Float32Array) {\r\n            let d = new Float32Array(this.data.buffer, this.data.byteOffset + i * 4, 1);\r\n            return new ScalarData(d, format!, this);\r\n          } else if (this.data instanceof Int32Array) {\r\n            let d = new Int32Array(this.data.buffer, this.data.byteOffset + i * 4, 1);\r\n            return new ScalarData(d, format!, this);\r\n          } else if (this.data instanceof Uint32Array) {\r\n            let d = new Uint32Array(this.data.buffer, this.data.byteOffset + i * 4, 1);\r\n            return new ScalarData(d, format!, this);\r\n          }\r\n        }\r\n\r\n        const values: number[] = [];\r\n        for (const m of member) {\r\n          if (m === \"x\" || m === \"r\") {\r\n            values.push(this.data[0]);\r\n          } else if (m === \"y\" || m === \"g\") {\r\n            values.push(this.data[1]);\r\n          } else if (m === \"z\" || m === \"b\") {\r\n            values.push(this.data[2]);\r\n          } else if (m === \"w\" || m === \"a\") {\r\n            values.push(this.data[3]);\r\n          } else {\r\n            console.error(`GetDataValue: Unknown member ${m}`);\r\n          }\r\n        }\r\n\r\n        self = _getVectorData(exec, values, format.name);\r\n      } else {\r\n        console.error(`GetSubData: Unknown postfix`, postfix);\r\n        return null;\r\n      }\r\n\r\n      postfix = postfix.postfix;\r\n    }\r\n\r\n    return self;\r\n  }\r\n\r\n  toString(): string {\r\n    let s = `${this.data[0]}`;\r\n    for (let i = 1; i < this.data.length; ++i) {\r\n      s += `, ${this.data[i]}`;\r\n    }\r\n    return s;\r\n  }\r\n}\r\n\r\nexport class MatrixData extends Data {\r\n  data: Float32Array;\r\n\r\n  constructor(value: number[] | Float32Array, typeInfo: TypeInfo, parent: Data | null = null) {\r\n    super(typeInfo, parent);\r\n    if (value instanceof Float32Array) {\r\n      this.data = value;\r\n    } else {\r\n      this.data = new Float32Array(value);\r\n    }\r\n  }\r\n\r\n  clone(): Data {\r\n    return new MatrixData(new Float32Array(this.data), this.typeInfo, null);\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    if (postfix instanceof StringExpr) {\r\n      console.error(\"TODO: Set matrix postfix\");\r\n      return;\r\n    }\r\n\r\n    if (!(value instanceof MatrixData)) {\r\n      console.error(`SetDataValue: Invalid value`, value);\r\n      return\r\n    }\r\n\r\n    this.data = value.data;\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix === null) {\r\n      return this;\r\n    }\r\n\r\n    const typeName = this.typeInfo.name;\r\n    let format = exec.getTypeInfo(\"f32\");\r\n    if (this.typeInfo instanceof TemplateInfo) {\r\n      format = this.typeInfo.format;\r\n    } else {\r\n      if (typeName.endsWith(\"f\")) {\r\n        format = exec.getTypeInfo(\"f32\");\r\n      } else if (typeName.endsWith(\"i\")) {\r\n        format = exec.getTypeInfo(\"i32\");\r\n      } else if (typeName.endsWith(\"u\")) {\r\n        format = exec.getTypeInfo(\"u32\");\r\n      } else if ( typeName.endsWith(\"h\")) {\r\n        format = exec.getTypeInfo(\"f16\");\r\n      } else {\r\n        console.error(`GetDataValue: Unknown type ${typeName}`);\r\n        return null;\r\n      }\r\n    }\r\n\r\n    if (postfix instanceof ArrayIndex) {\r\n      const idx = postfix.index;\r\n      let i = -1;\r\n      if (idx instanceof LiteralExpr) {\r\n        if (idx.value instanceof ScalarData) {\r\n          i = idx.value.value;\r\n        } else {\r\n          console.error(`GetDataValue: Invalid array index ${idx.value}`);\r\n          return null;\r\n        }\r\n      } else {\r\n        const d = exec.evalExpression(idx, context);\r\n        if (d instanceof ScalarData) {\r\n          i = d.value;\r\n        } else {\r\n          console.error(`GetDataValue: Unknown index type`, idx);\r\n          return null;\r\n        }\r\n      }\r\n      if (i < 0 || i >= this.data.length) {\r\n        console.error(`GetDataValue: Index out of range`, i);\r\n        return null;\r\n      }\r\n\r\n      const formatSuffix = typeName.endsWith(\"h\") ? \"h\" : \"f\";\r\n\r\n      let vectorData: VectorData;\r\n      if (typeName === \"mat2x2\" || typeName === \"mat2x2f\" || typeName === \"mat2x2h\" ||\r\n          typeName === \"mat3x2\" || typeName === \"mat3x2f\" || typeName === \"mat3x2h\" ||\r\n          typeName === \"mat4x2\" || typeName === \"mat4x2f\" || typeName === \"mat4x2h\") {\r\n        vectorData = new VectorData(new Float32Array(this.data.buffer, this.data.byteOffset + i * 2 * 4, 2), exec.getTypeInfo(`vec2${formatSuffix}`)!);\r\n      } else if (typeName === \"mat2x3\" || typeName === \"mat2x3f\" || typeName === \"mat2x3h\" ||\r\n                typeName === \"mat3x3\" || typeName === \"mat3x3f\" || typeName === \"mat3x3h\" ||\r\n                typeName === \"mat4x3\" || typeName === \"mat4x3f\" || typeName === \"mat4x3h\") {\r\n        vectorData = new VectorData(new Float32Array(this.data.buffer, this.data.byteOffset + i * 3 * 4, 3), exec.getTypeInfo(`vec3${formatSuffix}`)!);\r\n      } else if (typeName === \"mat2x4\" || typeName === \"mat2x4f\" || typeName === \"mat2x4h\" ||\r\n                typeName === \"mat3x4\" || typeName === \"mat3x4f\" || typeName === \"mat3x4h\" ||\r\n                typeName === \"mat4x4\" || typeName === \"mat4x4f\" || typeName === \"mat4x4h\") {\r\n        vectorData = new VectorData(new Float32Array(this.data.buffer, this.data.byteOffset + i * 4 * 4, 4), exec.getTypeInfo(`vec4${formatSuffix}`)!);\r\n      } else {\r\n        console.error(`GetDataValue: Unknown type ${typeName}`);\r\n        return null;\r\n      }\r\n\r\n      if (postfix.postfix) {\r\n        return vectorData.getSubData(exec, postfix.postfix, context);\r\n      }\r\n\r\n      return vectorData;\r\n    } else {\r\n      console.error(`GetDataValue: Invalid postfix`, postfix);\r\n      return null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  toString(): string {\r\n    let s = `${this.data[0]}`;\r\n    for (let i = 1; i < this.data.length; ++i) {\r\n      s += `, ${this.data[i]}`;\r\n    }\r\n    return s;\r\n  }\r\n}\r\n\r\n// Used to store array and struct data\r\nexport class TypedData extends Data {\r\n  buffer: ArrayBuffer;\r\n  offset: number;\r\n\r\n  constructor(data: ArrayBuffer | Float32Array | Uint32Array | Int32Array | Uint8Array | Int8Array,\r\n      typeInfo: TypeInfo, offset: number = 0, parent: Data | null = null) {\r\n    super(typeInfo, parent);\r\n    this.buffer = data instanceof ArrayBuffer ? data : data.buffer;\r\n    this.offset = offset;\r\n  }\r\n\r\n  clone(): Data {\r\n    const cloned = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));\r\n    return new TypedData(cloned.buffer, this.typeInfo, 0, null);\r\n  }\r\n\r\n  setDataValue(exec: ExecInterface, value: Data, postfix: Expression | null, context: ExecContext): void {\r\n    if (value === null) {\r\n      console.log(`setDataValue: NULL data.`);\r\n      return;\r\n    }\r\n\r\n    let offset = this.offset;\r\n    let typeInfo = this.typeInfo;\r\n    while (postfix) {\r\n      if (postfix instanceof ArrayIndex) {\r\n        if (typeInfo instanceof ArrayInfo) {\r\n          const idx = postfix.index;\r\n          if (idx instanceof LiteralExpr) {\r\n            if (idx.value instanceof ScalarData) {\r\n              offset += idx.value.value * typeInfo.stride;\r\n            } else {\r\n              console.error(`SetDataValue: Invalid index type ${idx.value}`);\r\n              return;\r\n            }\r\n          } else {\r\n            const i = exec.evalExpression(idx, context);\r\n            if (i instanceof ScalarData) {\r\n              offset += i.value * typeInfo.stride;\r\n            } else {\r\n              console.error(`SetDataValue: Unknown index type`, idx);\r\n              return;\r\n            }\r\n          }\r\n          typeInfo = typeInfo.format;\r\n        } else {\r\n          console.error(`SetDataValue: Type ${typeInfo.getTypeName()} is not an array`);\r\n        }\r\n      } else if (postfix instanceof StringExpr) {\r\n        const member = postfix.value;\r\n        if (typeInfo instanceof StructInfo) {\r\n          let found = false;\r\n          for (const m of typeInfo.members) {\r\n            if (m.name === member) {\r\n              offset += m.offset;\r\n              typeInfo = m.type;\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!found) {\r\n            console.error(`SetDataValue: Member ${member} not found`);\r\n            return;\r\n          }\r\n        } else if (typeInfo instanceof TypeInfo) {\r\n          const typeName = typeInfo.getTypeName();\r\n          let element = 0;\r\n          if (member === \"x\" || member === \"r\") {\r\n            element = 0;\r\n          } else if (member === \"y\" || member === \"g\") {\r\n            element = 1;\r\n          } else if (member === \"z\" || member === \"b\") {\r\n            element = 2;\r\n          } else if (member === \"w\" || member === \"a\") {\r\n            element = 3;\r\n          } else {\r\n            console.error(`SetDataValue: Unknown member ${member}`);\r\n            return;\r\n          }\r\n          if (!(value instanceof ScalarData)) {\r\n            console.error(`SetDataValue: Invalid value`, value);\r\n            return;\r\n          }\r\n          const v = value.value;\r\n          if (typeName === \"vec2f\") {\r\n            new Float32Array(this.buffer, offset, 2)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec3f\") {\r\n            new Float32Array(this.buffer, offset, 3)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec4f\") {\r\n            new Float32Array(this.buffer, offset, 4)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec2i\") {\r\n            new Int32Array(this.buffer, offset, 2)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec3i\") {\r\n            new Int32Array(this.buffer, offset, 3)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec4i\") {\r\n            new Int32Array(this.buffer, offset, 4)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec2u\") {\r\n            new Uint32Array(this.buffer, offset, 2)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec3u\") {\r\n            new Uint32Array(this.buffer, offset, 3)[element] = v;\r\n            return;\r\n          } else if (typeName === \"vec4u\") {\r\n            new Uint32Array(this.buffer, offset, 4)[element] = v;\r\n            return;\r\n          }\r\n          console.error(`SetDataValue: Type ${typeName} is not a struct`);\r\n          return;\r\n        }\r\n      } else {\r\n        console.error(`SetDataValue: Unknown postfix type`, postfix);\r\n        return;\r\n      }\r\n      postfix = postfix.postfix;\r\n    }\r\n\r\n    this.setData(exec, value, typeInfo, offset, context);\r\n  }\r\n\r\n  setData(exec: ExecInterface, value: Data, typeInfo: TypeInfo, offset: number, context: ExecContext): void {\r\n    const typeName = typeInfo.getTypeName();\r\n\r\n    if (typeName === \"f32\" || typeName === \"f16\") {\r\n      if (value instanceof ScalarData) {\r\n        new Float32Array(this.buffer, offset, 1)[0] = value.value;\r\n      }\r\n      return;\r\n    } else if (typeName === \"i32\" || typeName === \"atomic<i32>\" || typeName === \"x32\") {\r\n      if (value instanceof ScalarData) {\r\n        new Int32Array(this.buffer, offset, 1)[0] = value.value;\r\n      }\r\n      return;\r\n    } else if (typeName === \"u32\" || typeName === \"atomic<u32>\") {\r\n      if (value instanceof ScalarData) {\r\n        new Uint32Array(this.buffer, offset, 1)[0] = value.value;\r\n      }\r\n      return;\r\n    } else if (typeName === \"bool\") {\r\n      if (value instanceof ScalarData) {\r\n        new Int32Array(this.buffer, offset, 1)[0] = value.value;\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec2f\" || typeName === \"vec2h\") {\r\n      const x = new Float32Array(this.buffer, offset, 2);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec3f\" || typeName === \"vec3h\") {\r\n      const x = new Float32Array(this.buffer, offset, 3);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec4f\" || typeName === \"vec4h\") {\r\n      const x = new Float32Array(this.buffer, offset, 4);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec2i\") {\r\n      const x = new Int32Array(this.buffer, offset, 2);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec3i\") {\r\n      const x = new Int32Array(this.buffer, offset, 3);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec4i\") {\r\n      const x = new Int32Array(this.buffer, offset, 4);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec2u\") {\r\n      const x = new Uint32Array(this.buffer, offset, 2);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec3u\") {\r\n      const x = new Uint32Array(this.buffer, offset, 3);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec4u\") {\r\n      const x = new Uint32Array(this.buffer, offset, 4);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec2b\") {\r\n      const x = new Uint32Array(this.buffer, offset, 2);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec3b\") {\r\n      const x = new Uint32Array(this.buffer, offset, 3);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n      }\r\n      return;\r\n    } else if (typeName === \"vec4b\") {\r\n      const x = new Uint32Array(this.buffer, offset, 4);\r\n      if (value instanceof VectorData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat2x2f\" || typeName === \"mat2x2h\") {\r\n      const x = new Float32Array(this.buffer, offset, 4);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat2x3f\" || typeName === \"mat2x3h\") {\r\n      const x = new Float32Array(this.buffer, offset, 6);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat2x4f\" || typeName === \"mat2x4h\") {\r\n      const x = new Float32Array(this.buffer, offset, 8);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat3x2f\" || typeName === \"mat3x2h\") {\r\n      const x = new Float32Array(this.buffer, offset, 6);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat3x3f\" || typeName === \"mat3x3h\") {\r\n      const x = new Float32Array(this.buffer, offset, 9);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n        x[8] = value.data[8];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n        x[8] = value[8];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat3x4f\" || typeName === \"mat3x4h\") {\r\n      const x = new Float32Array(this.buffer, offset, 12);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n        x[8] = value.data[8];\r\n        x[9] = value.data[9];\r\n        x[10] = value.data[10];\r\n        x[11] = value.data[11];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n        x[8] = value[8];\r\n        x[9] = value[9];\r\n        x[10] = value[10];\r\n        x[11] = value[11];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat4x2f\" || typeName === \"mat4x2h\") {\r\n      const x = new Float32Array(this.buffer, offset, 8);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat4x3f\" || typeName === \"mat4x3h\") {\r\n      const x = new Float32Array(this.buffer, offset, 12);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n        x[8] = value.data[8];\r\n        x[9] = value.data[9];\r\n        x[10] = value.data[10];\r\n        x[11] = value.data[11];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n        x[8] = value[8];\r\n        x[9] = value[9];\r\n        x[10] = value[10];\r\n        x[11] = value[11];\r\n      }\r\n      return;\r\n    } else if (typeName === \"mat4x4f\" || typeName === \"mat4x4h\") {\r\n      const x = new Float32Array(this.buffer, offset, 16);\r\n      if (value instanceof MatrixData) {\r\n        x[0] = value.data[0];\r\n        x[1] = value.data[1];\r\n        x[2] = value.data[2];\r\n        x[3] = value.data[3];\r\n        x[4] = value.data[4];\r\n        x[5] = value.data[5];\r\n        x[6] = value.data[6];\r\n        x[7] = value.data[7];\r\n        x[8] = value.data[8];\r\n        x[9] = value.data[9];\r\n        x[10] = value.data[10];\r\n        x[11] = value.data[11];\r\n        x[12] = value.data[12];\r\n        x[13] = value.data[13];\r\n        x[14] = value.data[14];\r\n        x[15] = value.data[15];\r\n      } else {\r\n        x[0] = value[0];\r\n        x[1] = value[1];\r\n        x[2] = value[2];\r\n        x[3] = value[3];\r\n        x[4] = value[4];\r\n        x[5] = value[5];\r\n        x[6] = value[6];\r\n        x[7] = value[7];\r\n        x[8] = value[8];\r\n        x[9] = value[9];\r\n        x[10] = value[10];\r\n        x[11] = value[11];\r\n        x[12] = value[12];\r\n        x[13] = value[13];\r\n        x[14] = value[14];\r\n        x[15] = value[15];\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (value instanceof TypedData) {\r\n      if (typeInfo === value.typeInfo) {\r\n        const x = new Uint8Array(this.buffer, offset, value.buffer.byteLength);\r\n        x.set(new Uint8Array(value.buffer));\r\n        return;\r\n      } else {\r\n        console.error(`SetDataValue: Type mismatch`, typeName, value.typeInfo.getTypeName());\r\n        return;\r\n      }\r\n    }\r\n\r\n    console.error(`SetData: Unknown type ${typeName}`);\r\n  }\r\n\r\n  getSubData(exec: ExecInterface, postfix: Expression | null, context: ExecContext): Data | null {\r\n    if (postfix === null) {\r\n      return this;\r\n    }\r\n\r\n    let offset = this.offset;\r\n    let typeInfo = this.typeInfo;\r\n    while (postfix) {\r\n      if (postfix instanceof ArrayIndex) {\r\n        const idx = postfix.index;\r\n        const _i = idx instanceof Expression ? exec.evalExpression(idx, context) : idx;\r\n        let i = 0;\r\n        if (_i instanceof ScalarData) {\r\n          i = _i.value;\r\n        } else if (typeof _i === \"number\") {\r\n          i = _i;\r\n        } else {\r\n          console.error(`GetDataValue: Invalid index type`, idx);\r\n        }\r\n        if (typeInfo instanceof ArrayInfo) {\r\n          offset += i * typeInfo.stride;\r\n          typeInfo = typeInfo.format;\r\n        } else {\r\n          const typeName = typeInfo.getTypeName();\r\n          if (typeName === \"mat4x4\" || typeName === \"mat4x4f\" || typeName === \"mat4x4h\") {\r\n            offset += i * 16;\r\n            typeInfo = exec.getTypeInfo(\"vec4f\")!;\r\n          } else if (typeName === \"mat4x3\" || typeName === \"mat4x3f\" || typeName === \"mat4x3h\") {\r\n            offset += i * 12;\r\n            typeInfo = exec.getTypeInfo(\"vec3f\")!;\r\n          } else if (typeName === \"mat4x2\" || typeName === \"mat4x2f\" || typeName === \"mat4x2h\") {\r\n            offset += i * 8;\r\n            typeInfo = exec.getTypeInfo(\"vec2f\")!;\r\n          } else if (typeName === \"mat3x4\" || typeName === \"mat3x4f\" || typeName === \"mat3x4h\") {\r\n            offset += i * 12;\r\n            typeInfo = exec.getTypeInfo(\"vec4f\")!;\r\n          } else if (typeName === \"mat3x3\" || typeName === \"mat3x3f\" || typeName === \"mat3x3h\") {\r\n            offset += i * 9;\r\n            typeInfo = exec.getTypeInfo(\"vec3f\")!;\r\n          } else if (typeName === \"mat3x2\" || typeName === \"mat3x2f\" || typeName === \"mat3x2h\") {\r\n            offset += i * 6;\r\n            typeInfo = exec.getTypeInfo(\"vec2f\")!;\r\n          } else if (typeName === \"mat2x4\" || typeName === \"mat2x4f\" || typeName === \"mat2x4h\") {\r\n            offset += i * 8;\r\n            typeInfo = exec.getTypeInfo(\"vec4f\")!;\r\n          } else if (typeName === \"mat2x3\" || typeName === \"mat2x3f\" || typeName === \"mat2x3h\") {\r\n            offset += i * 6;\r\n            typeInfo = exec.getTypeInfo(\"vec3f\")!;\r\n          } else if (typeName === \"mat2x2\" || typeName === \"mat2x2f\" || typeName === \"mat2x2h\") {\r\n            offset += i * 4;\r\n            typeInfo = exec.getTypeInfo(\"vec2f\")!;\r\n          } else if (typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\") {\r\n            offset += i * 4;\r\n            typeInfo = exec.getTypeInfo(\"f32\")!;\r\n          } else if (typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\") {\r\n            offset += i * 2;\r\n            typeInfo = exec.getTypeInfo(\"f16\")!;\r\n          } else if (typeName === \"vec2b\" || typeName === \"vec3b\" || typeName === \"vec4b\") {\r\n            offset += i * 1;\r\n            typeInfo = exec.getTypeInfo(\"bool\")!;\r\n          } else if (typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\") {\r\n            offset += i * 4;\r\n            typeInfo = exec.getTypeInfo(\"i32\")!;\r\n          } else if (typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\") {\r\n            offset += i * 4;\r\n            typeInfo = exec.getTypeInfo(\"u32\")!;\r\n          } else {\r\n            console.error(`getDataValue: Type ${typeInfo.getTypeName()} is not an array`);\r\n          }\r\n        }\r\n      } else if (postfix instanceof StringExpr) {\r\n        const member = postfix.value;\r\n        if (typeInfo instanceof StructInfo) {\r\n          let found = false;\r\n          for (const m of typeInfo.members) {\r\n            if (m.name === member) {\r\n              offset += m.offset;\r\n              typeInfo = m.type;\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!found) {\r\n            console.error(`GetDataValue: Member ${member} not found`);\r\n            return null;\r\n          }\r\n        } else if (typeInfo instanceof TypeInfo) {\r\n          const typeName = typeInfo.getTypeName();\r\n          if (typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\" ||\r\n              typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\" ||\r\n              typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\" ||\r\n              typeName === \"vec2b\" || typeName === \"vec3b\" || typeName === \"vec4b\" ||\r\n              typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\" ||\r\n              typeName === \"vec2\" || typeName === \"vec3\" || typeName === \"vec4\") {\r\n\r\n            if (member.length > 0 && member.length < 5) {\r\n              let formatName = \"f32\";\r\n              let formatSuffix = \"f\";\r\n              const value: number[] = [];\r\n              for (let i = 0; i < member.length; ++i) {\r\n                const m = member[i].toLowerCase();\r\n                let element = 0;\r\n                if (m === \"x\" || m === \"r\") {\r\n                  element = 0;\r\n                } else if (m === \"y\" || m === \"g\") {\r\n                  element = 1;\r\n                } else if (m === \"z\" || m === \"b\") {\r\n                  element = 2;\r\n                } else if (m === \"w\" || m === \"a\") {\r\n                  element = 3;\r\n                } else {\r\n                  console.error(`Unknown member ${member}`);\r\n                  return null;\r\n                }\r\n\r\n                if (member.length === 1) {\r\n                  if (typeName.endsWith(\"f\")) {\r\n                    if (this.buffer.byteLength < (offset + element * 4 + 4)) {\r\n                      console.log(\"Insufficient buffer data\");\r\n                      return null;\r\n                    }\r\n                    return new ScalarData(new Float32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"f32\")!, this);\r\n                  } else if (typeName.endsWith(\"h\")) {\r\n                    return new ScalarData(new Float32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"f16\")!, this);\r\n                  } else if (typeName.endsWith(\"i\")) {\r\n                    return new ScalarData(new Int32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"i32\")!, this);\r\n                  } else if (typeName.endsWith(\"b\")) {\r\n                    return new ScalarData(new Int32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"bool\")!, this);\r\n                  } else if (typeName.endsWith(\"u\")) {\r\n                    return new ScalarData(new Uint32Array(this.buffer, offset + element * 4, 1), exec.getTypeInfo(\"i32\")!, this);\r\n                  }\r\n                }\r\n\r\n                if (typeName === \"vec2f\") {\r\n                  value.push(new Float32Array(this.buffer, offset, 2)[element]);\r\n                } else if (typeName === \"vec3f\") {\r\n                  if ((offset + 12) >= this.buffer.byteLength) {\r\n                    console.log(\"Insufficient buffer data\");\r\n                    return null;\r\n                  }\r\n                  const fa = new Float32Array(this.buffer, offset, 3);\r\n                  value.push(fa[element]);\r\n                } else if (typeName === \"vec4f\") {\r\n                  value.push(new Float32Array(this.buffer, offset, 4)[element]);\r\n                } else if (typeName === \"vec2i\") {\r\n                  formatName = \"i32\";\r\n                  formatSuffix = \"i\";\r\n                  value.push(new Int32Array(this.buffer, offset, 2)[element]);\r\n                } else if (typeName === \"vec3i\") {\r\n                  formatName = \"i32\";\r\n                  formatSuffix = \"i\";\r\n                  value.push(new Int32Array(this.buffer, offset, 3)[element]);\r\n                } else if (typeName === \"vec4i\") {\r\n                  formatName = \"i32\";\r\n                  formatSuffix = \"i\";\r\n                  value.push(new Int32Array(this.buffer, offset, 4)[element]);\r\n                } else if (typeName === \"vec2u\") {\r\n                  formatName = \"u32\";\r\n                  formatSuffix = \"u\";\r\n                  const ua = new Uint32Array(this.buffer, offset, 2);\r\n                  value.push(ua[element]);\r\n                } else if (typeName === \"vec3u\") {\r\n                  formatName = \"u32\";\r\n                  formatSuffix = \"u\";\r\n                  value.push(new Uint32Array(this.buffer, offset, 3)[element]);\r\n                } else if (typeName === \"vec4u\") {\r\n                  formatName = \"u32\";\r\n                  formatSuffix = \"u\";\r\n                  value.push(new Uint32Array(this.buffer, offset, 4)[element]);\r\n                }\r\n              }\r\n\r\n              if (value.length === 2) {\r\n                typeInfo = exec.getTypeInfo(`vec2${formatSuffix}`)!;\r\n              } else if (value.length === 3) {\r\n                typeInfo = exec.getTypeInfo(`vec3${formatSuffix}`)!;\r\n              } else if (value.length === 4) {\r\n                typeInfo = exec.getTypeInfo(`vec4${formatSuffix}`)!;\r\n              } else {\r\n                console.error(`GetDataValue: Invalid vector length ${value.length}`);\r\n              }\r\n\r\n              return new VectorData(value, typeInfo, null);\r\n            } else {\r\n              console.error(`GetDataValue: Unknown member ${member}`);\r\n              return null;\r\n            }\r\n          }\r\n\r\n          console.error(`GetDataValue: Type ${typeName} is not a struct`);\r\n          return null;\r\n        }\r\n      } else {\r\n        console.error(`GetDataValue: Unknown postfix type`, postfix);\r\n        return null;\r\n      }\r\n\r\n      postfix = postfix.postfix;\r\n    }\r\n\r\n    const typeName = typeInfo.getTypeName();\r\n\r\n    if (typeName === \"f32\") {\r\n      return new ScalarData(new Float32Array(this.buffer, offset, 1), typeInfo, this);\r\n    } else if (typeName === \"i32\") {\r\n      return new ScalarData(new Int32Array(this.buffer, offset, 1), typeInfo, this);\r\n    } else if (typeName === \"u32\") {\r\n      return new ScalarData(new Uint32Array(this.buffer, offset, 1), typeInfo, this);\r\n    } else if (typeName === \"vec2f\") {\r\n      return new VectorData(new Float32Array(this.buffer, offset, 2), typeInfo, this);\r\n    } else if (typeName === \"vec3f\") {\r\n      return new VectorData(new Float32Array(this.buffer, offset, 3), typeInfo, this);\r\n    } else if (typeName === \"vec4f\") {\r\n      return new VectorData(new Float32Array(this.buffer, offset, 4), typeInfo, this);\r\n    } else if (typeName === \"vec2i\") {\r\n      return new VectorData(new Int32Array(this.buffer, offset, 2), typeInfo, this);\r\n    } else if (typeName === \"vec3i\") {\r\n      return new VectorData(new Int32Array(this.buffer, offset, 3), typeInfo, this);\r\n    } else if (typeName === \"vec4i\") {\r\n      return new VectorData(new Int32Array(this.buffer, offset, 4), typeInfo, this);\r\n    } else if (typeName === \"vec2u\") {\r\n      return new VectorData(new Uint32Array(this.buffer, offset, 2), typeInfo, this);\r\n    } else if (typeName === \"vec3u\") {\r\n      return new VectorData(new Uint32Array(this.buffer, offset, 3), typeInfo, this);\r\n    } else if (typeName === \"vec4u\") {\r\n      return new VectorData(new Uint32Array(this.buffer, offset, 4), typeInfo, this);\r\n    }\r\n\r\n    if (typeInfo instanceof TemplateInfo && typeInfo.name === \"atomic\") {\r\n      if (typeInfo.format?.name === \"u32\") {\r\n        return new ScalarData(new Uint32Array(this.buffer, offset, 1)[0], typeInfo.format, this);\r\n      } else if (typeInfo.format?.name === \"i32\") {\r\n        return new ScalarData(new Int32Array(this.buffer, offset, 1)[0], typeInfo.format, this);\r\n      } else {\r\n        console.error(`GetDataValue: Invalid atomic format ${typeInfo.format?.name}`);\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return new TypedData(this.buffer, typeInfo, offset, this);\r\n  }\r\n\r\n  toArray(): number[] | Float32Array | Int32Array | Uint32Array | null {\r\n    const typeName = this.typeInfo.getTypeName();\r\n\r\n    if (typeName === \"f32\" || typeName === \"f16\") {\r\n      return new Float32Array(this.buffer, this.offset, 1);\r\n    } else if (typeName === \"i32\" || typeName === \"atomic<i32>\" || typeName === \"x32\") {\r\n      return new Int32Array(this.buffer, this.offset, 1);\r\n    } else if (typeName === \"u32\" || typeName === \"atomic<u32>\") {\r\n      return new Uint32Array(this.buffer, this.offset, 1);\r\n    } else if (typeName === \"bool\") {\r\n      return new Int32Array(this.buffer, this.offset, 1);\r\n    } else if (typeName === \"vec2f\" || typeName === \"vec2h\") {\r\n      return new Float32Array(this.buffer, this.offset, 2);\r\n    } else if (typeName === \"vec3f\" || typeName === \"vec3h\") {\r\n      return new Float32Array(this.buffer, this.offset, 3);\r\n    } else if (typeName === \"vec4f\" || typeName === \"vec4h\") {\r\n      return new Float32Array(this.buffer, this.offset, 4);\r\n    } else if (typeName === \"vec2i\") {\r\n      return new Int32Array(this.buffer, this.offset, 2);\r\n    } else if (typeName === \"vec3i\") {\r\n      return new Int32Array(this.buffer, this.offset, 3);\r\n    } else if (typeName === \"vec4i\") {\r\n      return new Int32Array(this.buffer, this.offset, 4);\r\n    } else if (typeName === \"vec2u\") {\r\n      return new Uint32Array(this.buffer, this.offset, 2);\r\n    } else if (typeName === \"vec3u\") {\r\n      return new Uint32Array(this.buffer, this.offset, 3);\r\n    } else if (typeName === \"vec4u\") {\r\n      return new Uint32Array(this.buffer, this.offset, 4);\r\n    } else if (typeName === \"vec2b\") {\r\n      return new Uint32Array(this.buffer, this.offset, 2);\r\n    } else if (typeName === \"vec3b\") {\r\n      return new Uint32Array(this.buffer, this.offset, 3);\r\n    } else if (typeName === \"vec4b\") {\r\n      return new Uint32Array(this.buffer, this.offset, 4);\r\n    } else if (typeName === \"mat2x2f\" || typeName === \"mat2x2h\") {\r\n      return new Float32Array(this.buffer, this.offset, 4);\r\n    } else if (typeName === \"mat2x3f\" || typeName === \"mat2x3h\") {\r\n      return new Float32Array(this.buffer, this.offset, 6);\r\n    } else if (typeName === \"mat2x4f\" || typeName === \"mat2x4h\") {\r\n      return new Float32Array(this.buffer, this.offset, 8);\r\n    } else if (typeName === \"mat3x2f\" || typeName === \"mat3x2h\") {\r\n      return new Float32Array(this.buffer, this.offset, 6);\r\n    } else if (typeName === \"mat3x3f\" || typeName === \"mat3x3h\") {\r\n      return new Float32Array(this.buffer, this.offset, 9);\r\n    } else if (typeName === \"mat3x4f\" || typeName === \"mat3x4h\") {\r\n      return new Float32Array(this.buffer, this.offset, 12);\r\n    } else if (typeName === \"mat4x2f\" || typeName === \"mat4x2h\") {\r\n      return new Float32Array(this.buffer, this.offset, 8);\r\n    } else if (typeName === \"mat4x3f\" || typeName === \"mat4x3h\") {\r\n      return new Float32Array(this.buffer, this.offset, 12);\r\n    } else if (typeName === \"mat4x4f\" || typeName === \"mat4x4h\") {\r\n      return new Float32Array(this.buffer, this.offset, 16);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  toString(): string {\r\n    let s = \"\";\r\n    if (this.typeInfo instanceof ArrayInfo) {\r\n      if (this.typeInfo.format.name === \"f32\") {\r\n        const fa = new Float32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}`;\r\n        for (let i = 1; i < fa.length; ++i) {\r\n          s += `, ${fa[i]}`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"i32\") {\r\n        const fa = new Int32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}`;\r\n        for (let i = 1; i < fa.length; ++i) {\r\n          s += `, ${fa[i]}`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"u32\") {\r\n        const fa = new Uint32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}`;\r\n        for (let i = 1; i < fa.length; ++i) {\r\n          s += `, ${fa[i]}`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"vec2f\") {\r\n        const fa = new Float32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}, ${fa[1]}]`;\r\n        for (let i = 1; i < fa.length / 2; ++i) {\r\n          s += `, [${fa[i * 2]}, ${fa[i * 2 + 1]}]`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"vec3f\") {\r\n        const fa = new Float32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}, ${fa[1]}, ${fa[2]}]`;\r\n        for (let i = 4; i < fa.length; i += 4) {\r\n          s += `, [${fa[i]}, ${fa[i + 1]}, ${fa[i + 2]}]`;\r\n        }\r\n      } else if (this.typeInfo.format.name === \"vec4f\") {\r\n        const fa = new Float32Array(this.buffer, this.offset);\r\n        s = `[${fa[0]}, ${fa[1]}, ${fa[2]}, ${fa[3]}]`;\r\n        for (let i = 4; i < fa.length; i += 4) {\r\n          s += `, [${fa[i]}, ${fa[i + 1]}, ${fa[i + 2]}, ${fa[i + 3]}]`;\r\n        }\r\n      } else {\r\n        s = `[...]`;\r\n      }\r\n    } else if (this.typeInfo instanceof StructInfo) {\r\n      s += `{...}`;\r\n    } else {\r\n      s = `[...]`;\r\n    }\r\n    return s;\r\n  }\r\n}\r\n\r\nexport class TextureData extends Data {\r\n  data: Array<ArrayBuffer | Float32Array | Uint32Array | Int32Array | Uint8Array | Int8Array>;\r\n  descriptor: Object;\r\n  view: Object | null;\r\n\r\n  constructor(data: Array<ArrayBuffer | Float32Array | Uint32Array | Int32Array | Uint8Array | Int8Array>,\r\n      typeInfo: TypeInfo, descriptor: Object, view: Object | null) {\r\n      super(typeInfo, null);\r\n      this.data = data;\r\n      this.descriptor = descriptor;\r\n      this.view = view;\r\n  }\r\n\r\n  clone(): Data {\r\n    return new TextureData(this.data, this.typeInfo, this.descriptor, this.view);\r\n  }\r\n\r\n  get width(): number {\r\n    const size = this.descriptor[\"size\"];\r\n    if (size instanceof Array && size.length > 0) {\r\n      return size[0] ?? 0;\r\n    } else if (size instanceof Object) {\r\n      return size[\"width\"] ?? 0;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  get height(): number {\r\n    const size = this.descriptor[\"size\"];\r\n    if (size instanceof Array && size.length > 1) {\r\n      return size[1] ?? 0;\r\n    } else if (size instanceof Object) {\r\n      return size[\"height\"] ?? 0;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  get depthOrArrayLayers(): number {\r\n    const size = this.descriptor[\"size\"];\r\n    if (size instanceof Array && size.length > 2) {\r\n      return size[2] ?? 0;\r\n    } else if (size instanceof Object) {\r\n      return size[\"depthOrArrayLayers\"] ?? 0;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  get format(): string {\r\n    if (this.descriptor) {\r\n      return this.descriptor[\"format\"] ?? \"rgba8unorm\";\r\n    }\r\n    return \"rgba8unorm\";\r\n  }\r\n\r\n  get sampleCount(): number {\r\n    if (this.descriptor) {\r\n      return this.descriptor[\"sampleCount\"] ?? 1;\r\n    }\r\n    return 1;\r\n  }\r\n\r\n  get mipLevelCount(): number {\r\n    if (this.descriptor) {\r\n      return this.descriptor[\"mipLevelCount\"] ?? 1;\r\n    }\r\n    return 1;\r\n  }\r\n\r\n  get dimension(): string {\r\n    if (this.descriptor) {\r\n      return this.descriptor[\"dimension\"] ?? \"2d\";\r\n    }\r\n    return \"2d\";\r\n  }\r\n\r\n  getMipLevelSize(level: number): number[] {\r\n    if (level >= this.mipLevelCount) {\r\n      return [0, 0, 0];\r\n    }\r\n\r\n    const size = [this.width, this.height, this.depthOrArrayLayers];\r\n    for (let i = 0; i < size.length; ++i) {\r\n      size[i] = Math.max(1, size[i] >> level);\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  get texelByteSize(): number {\r\n    const format = this.format;\r\n    const formatInfo = TextureFormatInfo[format];\r\n    if (!formatInfo) {\r\n      return 0;\r\n    }\r\n    if (formatInfo.isDepthStencil) {\r\n      return 4; // depth textures have r32float imageData\r\n    }\r\n    return formatInfo.bytesPerBlock;\r\n  }\r\n\r\n  get bytesPerRow(): number {\r\n    const width = this.width;\r\n    const texelByteSize = this.texelByteSize;\r\n    //return (width * texelByteSize + 255) & ~0xff; // bytesPerRow is aligned to a multiple of 256 bytes\r\n    return width * texelByteSize;\r\n  }\r\n\r\n  get isDepthStencil(): boolean {\r\n    const format = this.format;\r\n    const formatInfo = TextureFormatInfo[format];\r\n    if (!formatInfo) {\r\n      return false;\r\n    }\r\n    return formatInfo.isDepthStencil;\r\n  }\r\n\r\n  getGpuSize(): number {\r\n    const format = this.format;\r\n    const formatInfo = TextureFormatInfo[format];\r\n    const width = this.width;\r\n    if (!format || width <= 0 || !formatInfo) {\r\n      return -1;\r\n    }\r\n\r\n    const height = this.height;\r\n    const depthOrArrayLayers = this.depthOrArrayLayers;\r\n    const dimension = this.dimension;\r\n    const blockWidth = width / formatInfo.blockWidth;\r\n    const blockHeight = dimension === \"1d\" ? 1 : height / formatInfo.blockHeight;\r\n    const bytesPerBlock = formatInfo.bytesPerBlock;\r\n\r\n    return blockWidth * blockHeight * bytesPerBlock * depthOrArrayLayers;\r\n  }\r\n\r\n  getPixel(x: number, y: number, z: number = 0, mipLevel: number = 0): number[] | null {\r\n    const texelByteSize = this.texelByteSize;\r\n    const bytesPerRow = this.bytesPerRow;\r\n    const height = this.height;\r\n    const buffer = this.data[mipLevel];\r\n    const imageData = new Uint8Array(buffer);\r\n    return getTexturePixel(imageData, x, y, z, mipLevel, height, bytesPerRow, texelByteSize, this.format);\r\n  }\r\n\r\n  setPixel(x: number, y: number, z: number, mipLevel: number, value: number[]): void {\r\n    const texelByteSize = this.texelByteSize;\r\n    const bytesPerRow = this.bytesPerRow;\r\n    const height = this.height;\r\n    const buffer = this.data[mipLevel];\r\n    const imageData = new Uint8Array(buffer);\r\n    setTexturePixel(imageData, x, y, z, mipLevel, height, bytesPerRow, texelByteSize, this.format, value);\r\n  }\r\n}\r\n","export enum TokenClass {\r\n  token,\r\n  keyword,\r\n  reserved,\r\n}\r\n\r\nexport class TokenType {\r\n  name: string;\r\n  type: TokenClass;\r\n  rule: RegExp | string;\r\n\r\n  constructor(name: string, type: TokenClass, rule: RegExp | string) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.rule = rule;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.name;\r\n  }\r\n}\r\n\r\n/// Catalog of defined token types, keywords, and reserved words.\r\nexport class TokenTypes {\r\n  static readonly none = new TokenType(\"\", TokenClass.reserved, \"\");\r\n  static readonly eof = new TokenType(\"EOF\", TokenClass.token, \"\");\r\n\r\n  static readonly reserved = {\r\n    asm: new TokenType(\"asm\", TokenClass.reserved, \"asm\"),\r\n    bf16: new TokenType(\"bf16\", TokenClass.reserved, \"bf16\"),\r\n    do: new TokenType(\"do\", TokenClass.reserved, \"do\"),\r\n    enum: new TokenType(\"enum\", TokenClass.reserved, \"enum\"),\r\n    f16: new TokenType(\"f16\", TokenClass.reserved, \"f16\"),\r\n    f64: new TokenType(\"f64\", TokenClass.reserved, \"f64\"),\r\n    handle: new TokenType(\"handle\", TokenClass.reserved, \"handle\"),\r\n    i8: new TokenType(\"i8\", TokenClass.reserved, \"i8\"),\r\n    i16: new TokenType(\"i16\", TokenClass.reserved, \"i16\"),\r\n    i64: new TokenType(\"i64\", TokenClass.reserved, \"i64\"),\r\n    mat: new TokenType(\"mat\", TokenClass.reserved, \"mat\"),\r\n    premerge: new TokenType(\"premerge\", TokenClass.reserved, \"premerge\"),\r\n    regardless: new TokenType(\"regardless\", TokenClass.reserved, \"regardless\"),\r\n    typedef: new TokenType(\"typedef\", TokenClass.reserved, \"typedef\"),\r\n    u8: new TokenType(\"u8\", TokenClass.reserved, \"u8\"),\r\n    u16: new TokenType(\"u16\", TokenClass.reserved, \"u16\"),\r\n    u64: new TokenType(\"u64\", TokenClass.reserved, \"u64\"),\r\n    unless: new TokenType(\"unless\", TokenClass.reserved, \"unless\"),\r\n    using: new TokenType(\"using\", TokenClass.reserved, \"using\"),\r\n    vec: new TokenType(\"vec\", TokenClass.reserved, \"vec\"),\r\n    void: new TokenType(\"void\", TokenClass.reserved, \"void\"),\r\n  };\r\n\r\n  static readonly keywords = {\r\n    array: new TokenType(\"array\", TokenClass.keyword, \"array\"),\r\n    atomic: new TokenType(\"atomic\", TokenClass.keyword, \"atomic\"),\r\n    bool: new TokenType(\"bool\", TokenClass.keyword, \"bool\"),\r\n    f32: new TokenType(\"f32\", TokenClass.keyword, \"f32\"),\r\n    i32: new TokenType(\"i32\", TokenClass.keyword, \"i32\"),\r\n    mat2x2: new TokenType(\"mat2x2\", TokenClass.keyword, \"mat2x2\"),\r\n    mat2x3: new TokenType(\"mat2x3\", TokenClass.keyword, \"mat2x3\"),\r\n    mat2x4: new TokenType(\"mat2x4\", TokenClass.keyword, \"mat2x4\"),\r\n    mat3x2: new TokenType(\"mat3x2\", TokenClass.keyword, \"mat3x2\"),\r\n    mat3x3: new TokenType(\"mat3x3\", TokenClass.keyword, \"mat3x3\"),\r\n    mat3x4: new TokenType(\"mat3x4\", TokenClass.keyword, \"mat3x4\"),\r\n    mat4x2: new TokenType(\"mat4x2\", TokenClass.keyword, \"mat4x2\"),\r\n    mat4x3: new TokenType(\"mat4x3\", TokenClass.keyword, \"mat4x3\"),\r\n    mat4x4: new TokenType(\"mat4x4\", TokenClass.keyword, \"mat4x4\"),\r\n    ptr: new TokenType(\"ptr\", TokenClass.keyword, \"ptr\"),\r\n    sampler: new TokenType(\"sampler\", TokenClass.keyword, \"sampler\"),\r\n    sampler_comparison: new TokenType(\r\n      \"sampler_comparison\",\r\n      TokenClass.keyword,\r\n      \"sampler_comparison\"\r\n    ),\r\n    struct: new TokenType(\"struct\", TokenClass.keyword, \"struct\"),\r\n    texture_1d: new TokenType(\"texture_1d\", TokenClass.keyword, \"texture_1d\"),\r\n    texture_2d: new TokenType(\"texture_2d\", TokenClass.keyword, \"texture_2d\"),\r\n    texture_2d_array: new TokenType(\r\n      \"texture_2d_array\",\r\n      TokenClass.keyword,\r\n      \"texture_2d_array\"\r\n    ),\r\n    texture_3d: new TokenType(\"texture_3d\", TokenClass.keyword, \"texture_3d\"),\r\n    texture_cube: new TokenType(\r\n      \"texture_cube\",\r\n      TokenClass.keyword,\r\n      \"texture_cube\"\r\n    ),\r\n    texture_cube_array: new TokenType(\r\n      \"texture_cube_array\",\r\n      TokenClass.keyword,\r\n      \"texture_cube_array\"\r\n    ),\r\n    texture_multisampled_2d: new TokenType(\r\n      \"texture_multisampled_2d\",\r\n      TokenClass.keyword,\r\n      \"texture_multisampled_2d\"\r\n    ),\r\n    texture_storage_1d: new TokenType(\r\n      \"texture_storage_1d\",\r\n      TokenClass.keyword,\r\n      \"texture_storage_1d\"\r\n    ),\r\n    texture_storage_2d: new TokenType(\r\n      \"texture_storage_2d\",\r\n      TokenClass.keyword,\r\n      \"texture_storage_2d\"\r\n    ),\r\n    texture_storage_2d_array: new TokenType(\r\n      \"texture_storage_2d_array\",\r\n      TokenClass.keyword,\r\n      \"texture_storage_2d_array\"\r\n    ),\r\n    texture_storage_3d: new TokenType(\r\n      \"texture_storage_3d\",\r\n      TokenClass.keyword,\r\n      \"texture_storage_3d\"\r\n    ),\r\n    texture_depth_2d: new TokenType(\r\n      \"texture_depth_2d\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_2d\"\r\n    ),\r\n    texture_depth_2d_array: new TokenType(\r\n      \"texture_depth_2d_array\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_2d_array\"\r\n    ),\r\n    texture_depth_cube: new TokenType(\r\n      \"texture_depth_cube\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_cube\"\r\n    ),\r\n    texture_depth_cube_array: new TokenType(\r\n      \"texture_depth_cube_array\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_cube_array\"\r\n    ),\r\n    texture_depth_multisampled_2d: new TokenType(\r\n      \"texture_depth_multisampled_2d\",\r\n      TokenClass.keyword,\r\n      \"texture_depth_multisampled_2d\"\r\n    ),\r\n    texture_external: new TokenType(\r\n      \"texture_external\",\r\n      TokenClass.keyword,\r\n      \"texture_external\"\r\n    ),\r\n    u32: new TokenType(\"u32\", TokenClass.keyword, \"u32\"),\r\n    vec2: new TokenType(\"vec2\", TokenClass.keyword, \"vec2\"),\r\n    vec3: new TokenType(\"vec3\", TokenClass.keyword, \"vec3\"),\r\n    vec4: new TokenType(\"vec4\", TokenClass.keyword, \"vec4\"),\r\n    bitcast: new TokenType(\"bitcast\", TokenClass.keyword, \"bitcast\"),\r\n    block: new TokenType(\"block\", TokenClass.keyword, \"block\"),\r\n    break: new TokenType(\"break\", TokenClass.keyword, \"break\"),\r\n    case: new TokenType(\"case\", TokenClass.keyword, \"case\"),\r\n    continue: new TokenType(\"continue\", TokenClass.keyword, \"continue\"),\r\n    continuing: new TokenType(\"continuing\", TokenClass.keyword, \"continuing\"),\r\n    default: new TokenType(\"default\", TokenClass.keyword, \"default\"),\r\n    diagnostic: new TokenType(\"diagnostic\", TokenClass.keyword, \"diagnostic\"),\r\n    discard: new TokenType(\"discard\", TokenClass.keyword, \"discard\"),\r\n    else: new TokenType(\"else\", TokenClass.keyword, \"else\"),\r\n    enable: new TokenType(\"enable\", TokenClass.keyword, \"enable\"),\r\n    fallthrough: new TokenType(\r\n      \"fallthrough\",\r\n      TokenClass.keyword,\r\n      \"fallthrough\"\r\n    ),\r\n    false: new TokenType(\"false\", TokenClass.keyword, \"false\"),\r\n    fn: new TokenType(\"fn\", TokenClass.keyword, \"fn\"),\r\n    for: new TokenType(\"for\", TokenClass.keyword, \"for\"),\r\n    function: new TokenType(\"function\", TokenClass.keyword, \"function\"),\r\n    if: new TokenType(\"if\", TokenClass.keyword, \"if\"),\r\n    let: new TokenType(\"let\", TokenClass.keyword, \"let\"),\r\n    const: new TokenType(\"const\", TokenClass.keyword, \"const\"),\r\n    loop: new TokenType(\"loop\", TokenClass.keyword, \"loop\"),\r\n    while: new TokenType(\"while\", TokenClass.keyword, \"while\"),\r\n    private: new TokenType(\"private\", TokenClass.keyword, \"private\"),\r\n    read: new TokenType(\"read\", TokenClass.keyword, \"read\"),\r\n    read_write: new TokenType(\"read_write\", TokenClass.keyword, \"read_write\"),\r\n    return: new TokenType(\"return\", TokenClass.keyword, \"return\"),\r\n    requires: new TokenType(\"requires\", TokenClass.keyword, \"requires\"),\r\n    storage: new TokenType(\"storage\", TokenClass.keyword, \"storage\"),\r\n    switch: new TokenType(\"switch\", TokenClass.keyword, \"switch\"),\r\n    true: new TokenType(\"true\", TokenClass.keyword, \"true\"),\r\n    alias: new TokenType(\"alias\", TokenClass.keyword, \"alias\"),\r\n    type: new TokenType(\"type\", TokenClass.keyword, \"type\"),\r\n    uniform: new TokenType(\"uniform\", TokenClass.keyword, \"uniform\"),\r\n    var: new TokenType(\"var\", TokenClass.keyword, \"var\"),\r\n    override: new TokenType(\"override\", TokenClass.keyword, \"override\"),\r\n    workgroup: new TokenType(\"workgroup\", TokenClass.keyword, \"workgroup\"),\r\n    write: new TokenType(\"write\", TokenClass.keyword, \"write\"),\r\n    r8unorm: new TokenType(\"r8unorm\", TokenClass.keyword, \"r8unorm\"),\r\n    r8snorm: new TokenType(\"r8snorm\", TokenClass.keyword, \"r8snorm\"),\r\n    r8uint: new TokenType(\"r8uint\", TokenClass.keyword, \"r8uint\"),\r\n    r8sint: new TokenType(\"r8sint\", TokenClass.keyword, \"r8sint\"),\r\n    r16uint: new TokenType(\"r16uint\", TokenClass.keyword, \"r16uint\"),\r\n    r16sint: new TokenType(\"r16sint\", TokenClass.keyword, \"r16sint\"),\r\n    r16float: new TokenType(\"r16float\", TokenClass.keyword, \"r16float\"),\r\n    rg8unorm: new TokenType(\"rg8unorm\", TokenClass.keyword, \"rg8unorm\"),\r\n    rg8snorm: new TokenType(\"rg8snorm\", TokenClass.keyword, \"rg8snorm\"),\r\n    rg8uint: new TokenType(\"rg8uint\", TokenClass.keyword, \"rg8uint\"),\r\n    rg8sint: new TokenType(\"rg8sint\", TokenClass.keyword, \"rg8sint\"),\r\n    r32uint: new TokenType(\"r32uint\", TokenClass.keyword, \"r32uint\"),\r\n    r32sint: new TokenType(\"r32sint\", TokenClass.keyword, \"r32sint\"),\r\n    r32float: new TokenType(\"r32float\", TokenClass.keyword, \"r32float\"),\r\n    rg16uint: new TokenType(\"rg16uint\", TokenClass.keyword, \"rg16uint\"),\r\n    rg16sint: new TokenType(\"rg16sint\", TokenClass.keyword, \"rg16sint\"),\r\n    rg16float: new TokenType(\"rg16float\", TokenClass.keyword, \"rg16float\"),\r\n    rgba8unorm: new TokenType(\"rgba8unorm\", TokenClass.keyword, \"rgba8unorm\"),\r\n    rgba8unorm_srgb: new TokenType(\r\n      \"rgba8unorm_srgb\",\r\n      TokenClass.keyword,\r\n      \"rgba8unorm_srgb\"\r\n    ),\r\n    rgba8snorm: new TokenType(\"rgba8snorm\", TokenClass.keyword, \"rgba8snorm\"),\r\n    rgba8uint: new TokenType(\"rgba8uint\", TokenClass.keyword, \"rgba8uint\"),\r\n    rgba8sint: new TokenType(\"rgba8sint\", TokenClass.keyword, \"rgba8sint\"),\r\n    bgra8unorm: new TokenType(\"bgra8unorm\", TokenClass.keyword, \"bgra8unorm\"),\r\n    bgra8unorm_srgb: new TokenType(\r\n      \"bgra8unorm_srgb\",\r\n      TokenClass.keyword,\r\n      \"bgra8unorm_srgb\"\r\n    ),\r\n    rgb10a2unorm: new TokenType(\r\n      \"rgb10a2unorm\",\r\n      TokenClass.keyword,\r\n      \"rgb10a2unorm\"\r\n    ),\r\n    rg11b10float: new TokenType(\r\n      \"rg11b10float\",\r\n      TokenClass.keyword,\r\n      \"rg11b10float\"\r\n    ),\r\n    rg32uint: new TokenType(\"rg32uint\", TokenClass.keyword, \"rg32uint\"),\r\n    rg32sint: new TokenType(\"rg32sint\", TokenClass.keyword, \"rg32sint\"),\r\n    rg32float: new TokenType(\"rg32float\", TokenClass.keyword, \"rg32float\"),\r\n    rgba16uint: new TokenType(\"rgba16uint\", TokenClass.keyword, \"rgba16uint\"),\r\n    rgba16sint: new TokenType(\"rgba16sint\", TokenClass.keyword, \"rgba16sint\"),\r\n    rgba16float: new TokenType(\r\n      \"rgba16float\",\r\n      TokenClass.keyword,\r\n      \"rgba16float\"\r\n    ),\r\n    rgba32uint: new TokenType(\"rgba32uint\", TokenClass.keyword, \"rgba32uint\"),\r\n    rgba32sint: new TokenType(\"rgba32sint\", TokenClass.keyword, \"rgba32sint\"),\r\n    rgba32float: new TokenType(\r\n      \"rgba32float\",\r\n      TokenClass.keyword,\r\n      \"rgba32float\"\r\n    ),\r\n    static_assert: new TokenType(\r\n      \"static_assert\",\r\n      TokenClass.keyword,\r\n      \"static_assert\"\r\n    ),\r\n\r\n    // WGSL grammar has a few keywords that have different token names than the strings they\r\n    // represent. Aliasing them here.\r\n    /*int32: new TokenType(\"i32\", TokenClass.keyword, \"i32\"),\r\n        uint32: new TokenType(\"u32\", TokenClass.keyword, \"u32\"),\r\n        float32: new TokenType(\"f32\", TokenClass.keyword, \"f32\"),\r\n        pointer: new TokenType(\"ptr\", TokenClass.keyword, \"ptr\"),*/\r\n  };\r\n\r\n  static readonly tokens = {\r\n    decimal_float_literal: new TokenType(\r\n      \"decimal_float_literal\",\r\n      TokenClass.token,\r\n      /((-?[0-9]*\\.[0-9]+|-?[0-9]+\\.[0-9]*)((e|E)(\\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/\r\n    ),\r\n    hex_float_literal: new TokenType(\r\n      \"hex_float_literal\",\r\n      TokenClass.token,\r\n      /-?0x((([0-9a-fA-F]*\\.[0-9a-fA-F]+|[0-9a-fA-F]+\\.[0-9a-fA-F]*)((p|P)(\\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\\+|-)?[0-9]+[fh]?))/\r\n    ),\r\n    int_literal: new TokenType(\r\n      \"int_literal\",\r\n      TokenClass.token,\r\n      /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/\r\n    ),\r\n    uint_literal: new TokenType(\r\n      \"uint_literal\",\r\n      TokenClass.token,\r\n      /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/\r\n    ),\r\n    name: new TokenType(\"name\", TokenClass.token,  /([_\\p{XID_Start}][\\p{XID_Continue}]+)|([\\p{XID_Start}])/u),\r\n    //name: new TokenType(\"name\", TokenClass.token, /[_a-zA-Z][0-9a-zA-Z_]*/),\r\n    ident: new TokenType(\"ident\", TokenClass.token, /[_a-zA-Z][0-9a-zA-Z_]*/),\r\n    and: new TokenType(\"and\", TokenClass.token, \"&\"),\r\n    and_and: new TokenType(\"and_and\", TokenClass.token, \"&&\"),\r\n    arrow: new TokenType(\"arrow \", TokenClass.token, \"->\"),\r\n    attr: new TokenType(\"attr\", TokenClass.token, \"@\"),\r\n    forward_slash: new TokenType(\"forward_slash\", TokenClass.token, \"/\"),\r\n    bang: new TokenType(\"bang\", TokenClass.token, \"!\"),\r\n    bracket_left: new TokenType(\"bracket_left\", TokenClass.token, \"[\"),\r\n    bracket_right: new TokenType(\"bracket_right\", TokenClass.token, \"]\"),\r\n    brace_left: new TokenType(\"brace_left\", TokenClass.token, \"{\"),\r\n    brace_right: new TokenType(\"brace_right\", TokenClass.token, \"}\"),\r\n    colon: new TokenType(\"colon\", TokenClass.token, \":\"),\r\n    comma: new TokenType(\"comma\", TokenClass.token, \",\"),\r\n    equal: new TokenType(\"equal\", TokenClass.token, \"=\"),\r\n    equal_equal: new TokenType(\"equal_equal\", TokenClass.token, \"==\"),\r\n    not_equal: new TokenType(\"not_equal\", TokenClass.token, \"!=\"),\r\n    greater_than: new TokenType(\"greater_than\", TokenClass.token, \">\"),\r\n    greater_than_equal: new TokenType(\r\n      \"greater_than_equal\",\r\n      TokenClass.token,\r\n      \">=\"\r\n    ),\r\n    shift_right: new TokenType(\"shift_right\", TokenClass.token, \">>\"),\r\n    less_than: new TokenType(\"less_than\", TokenClass.token, \"<\"),\r\n    less_than_equal: new TokenType(\"less_than_equal\", TokenClass.token, \"<=\"),\r\n    shift_left: new TokenType(\"shift_left\", TokenClass.token, \"<<\"),\r\n    modulo: new TokenType(\"modulo\", TokenClass.token, \"%\"),\r\n    minus: new TokenType(\"minus\", TokenClass.token, \"-\"),\r\n    minus_minus: new TokenType(\"minus_minus\", TokenClass.token, \"--\"),\r\n    period: new TokenType(\"period\", TokenClass.token, \".\"),\r\n    plus: new TokenType(\"plus\", TokenClass.token, \"+\"),\r\n    plus_plus: new TokenType(\"plus_plus\", TokenClass.token, \"++\"),\r\n    or: new TokenType(\"or\", TokenClass.token, \"|\"),\r\n    or_or: new TokenType(\"or_or\", TokenClass.token, \"||\"),\r\n    paren_left: new TokenType(\"paren_left\", TokenClass.token, \"(\"),\r\n    paren_right: new TokenType(\"paren_right\", TokenClass.token, \")\"),\r\n    semicolon: new TokenType(\"semicolon\", TokenClass.token, \";\"),\r\n    star: new TokenType(\"star\", TokenClass.token, \"*\"),\r\n    tilde: new TokenType(\"tilde\", TokenClass.token, \"~\"),\r\n    underscore: new TokenType(\"underscore\", TokenClass.token, \"_\"),\r\n    xor: new TokenType(\"xor\", TokenClass.token, \"^\"),\r\n    plus_equal: new TokenType(\"plus_equal\", TokenClass.token, \"+=\"),\r\n    minus_equal: new TokenType(\"minus_equal\", TokenClass.token, \"-=\"),\r\n    times_equal: new TokenType(\"times_equal\", TokenClass.token, \"*=\"),\r\n    division_equal: new TokenType(\"division_equal\", TokenClass.token, \"/=\"),\r\n    modulo_equal: new TokenType(\"modulo_equal\", TokenClass.token, \"%=\"),\r\n    and_equal: new TokenType(\"and_equal\", TokenClass.token, \"&=\"),\r\n    or_equal: new TokenType(\"or_equal\", TokenClass.token, \"|=\"),\r\n    xor_equal: new TokenType(\"xor_equal\", TokenClass.token, \"^=\"),\r\n    shift_right_equal: new TokenType(\r\n      \"shift_right_equal\",\r\n      TokenClass.token,\r\n      \">>=\"\r\n    ),\r\n    shift_left_equal: new TokenType(\r\n      \"shift_left_equal\",\r\n      TokenClass.token,\r\n      \"<<=\"\r\n    ),\r\n  };\r\n\r\n  static readonly simpleTokens = {\r\n    \"@\": this.tokens.attr,\r\n    \"{\": this.tokens.brace_left,\r\n    \"}\": this.tokens.brace_right,\r\n    \":\": this.tokens.colon,\r\n    \",\": this.tokens.comma,\r\n    \"(\": this.tokens.paren_left,\r\n    \")\": this.tokens.paren_right,\r\n    \";\": this.tokens.semicolon,\r\n  };\r\n\r\n  static readonly literalTokens = {\r\n    \"&\": this.tokens.and,\r\n    \"&&\": this.tokens.and_and,\r\n    \"->\": this.tokens.arrow ,\r\n    \"/\": this.tokens.forward_slash,\r\n    \"!\": this.tokens.bang,\r\n    \"[\": this.tokens.bracket_left,\r\n    \"]\": this.tokens.bracket_right,\r\n    \"=\": this.tokens.equal,\r\n    \"==\": this.tokens.equal_equal,\r\n    \"!=\": this.tokens.not_equal,\r\n    \">\": this.tokens.greater_than,\r\n    \">=\": this.tokens.greater_than_equal,\r\n    \">>\": this.tokens.shift_right,\r\n    \"<\": this.tokens.less_than,\r\n    \"<=\": this.tokens.less_than_equal,\r\n    \"<<\": this.tokens.shift_left,\r\n    \"%\": this.tokens.modulo,\r\n    \"-\": this.tokens.minus,\r\n    \"--\": this.tokens.minus_minus,\r\n    \".\": this.tokens.period,\r\n    \"+\": this.tokens.plus,\r\n    \"++\": this.tokens.plus_plus,\r\n    \"|\": this.tokens.or,\r\n    \"||\": this.tokens.or_or,\r\n    \"*\": this.tokens.star,\r\n    \"~\": this.tokens.tilde,\r\n    \"_\": this.tokens.underscore,\r\n    \"^\": this.tokens.xor,\r\n    \"+=\": this.tokens.plus_equal,\r\n    \"-=\": this.tokens.minus_equal,\r\n    \"*=\": this.tokens.times_equal,\r\n    \"/=\": this.tokens.division_equal,\r\n    \"%=\": this.tokens.modulo_equal,\r\n    \"&=\": this.tokens.and_equal,\r\n    \"|=\": this.tokens.or_equal,\r\n    \"^=\": this.tokens.xor_equal,\r\n    \">>=\": this.tokens.shift_right_equal,\r\n    \"<<=\": this.tokens.shift_left_equal,\r\n  };\r\n\r\n  static readonly regexTokens = {\r\n    decimal_float_literal: this.tokens.decimal_float_literal,\r\n    hex_float_literal: this.tokens.hex_float_literal,\r\n    int_literal: this.tokens.int_literal,\r\n    uint_literal: this.tokens.uint_literal,\r\n    ident: this.tokens.ident,\r\n  };\r\n\r\n  static readonly storage_class = [\r\n    this.keywords.function,\r\n    this.keywords.private,\r\n    this.keywords.workgroup,\r\n    this.keywords.uniform,\r\n    this.keywords.storage,\r\n  ];\r\n\r\n  static readonly access_mode = [\r\n    this.keywords.read,\r\n    this.keywords.write,\r\n    this.keywords.read_write,\r\n  ];\r\n\r\n  static readonly sampler_type = [\r\n    this.keywords.sampler,\r\n    this.keywords.sampler_comparison,\r\n  ];\r\n\r\n  static readonly sampled_texture_type = [\r\n    this.keywords.texture_1d,\r\n    this.keywords.texture_2d,\r\n    this.keywords.texture_2d_array,\r\n    this.keywords.texture_3d,\r\n    this.keywords.texture_cube,\r\n    this.keywords.texture_cube_array,\r\n  ];\r\n\r\n  static readonly multisampled_texture_type = [\r\n    this.keywords.texture_multisampled_2d,\r\n  ];\r\n\r\n  static readonly storage_texture_type = [\r\n    this.keywords.texture_storage_1d,\r\n    this.keywords.texture_storage_2d,\r\n    this.keywords.texture_storage_2d_array,\r\n    this.keywords.texture_storage_3d,\r\n  ];\r\n\r\n  static readonly depth_texture_type = [\r\n    this.keywords.texture_depth_2d,\r\n    this.keywords.texture_depth_2d_array,\r\n    this.keywords.texture_depth_cube,\r\n    this.keywords.texture_depth_cube_array,\r\n    this.keywords.texture_depth_multisampled_2d,\r\n  ];\r\n\r\n  static readonly texture_external_type = [this.keywords.texture_external];\r\n\r\n  static readonly any_texture_type = [\r\n    ...this.sampled_texture_type,\r\n    ...this.multisampled_texture_type,\r\n    ...this.storage_texture_type,\r\n    ...this.depth_texture_type,\r\n    ...this.texture_external_type,\r\n  ];\r\n\r\n  static readonly texel_format = [\r\n    this.keywords.r8unorm,\r\n    this.keywords.r8snorm,\r\n    this.keywords.r8uint,\r\n    this.keywords.r8sint,\r\n    this.keywords.r16uint,\r\n    this.keywords.r16sint,\r\n    this.keywords.r16float,\r\n    this.keywords.rg8unorm,\r\n    this.keywords.rg8snorm,\r\n    this.keywords.rg8uint,\r\n    this.keywords.rg8sint,\r\n    this.keywords.r32uint,\r\n    this.keywords.r32sint,\r\n    this.keywords.r32float,\r\n    this.keywords.rg16uint,\r\n    this.keywords.rg16sint,\r\n    this.keywords.rg16float,\r\n    this.keywords.rgba8unorm,\r\n    this.keywords.rgba8unorm_srgb,\r\n    this.keywords.rgba8snorm,\r\n    this.keywords.rgba8uint,\r\n    this.keywords.rgba8sint,\r\n    this.keywords.bgra8unorm,\r\n    this.keywords.bgra8unorm_srgb,\r\n    this.keywords.rgb10a2unorm,\r\n    this.keywords.rg11b10float,\r\n    this.keywords.rg32uint,\r\n    this.keywords.rg32sint,\r\n    this.keywords.rg32float,\r\n    this.keywords.rgba16uint,\r\n    this.keywords.rgba16sint,\r\n    this.keywords.rgba16float,\r\n    this.keywords.rgba32uint,\r\n    this.keywords.rgba32sint,\r\n    this.keywords.rgba32float,\r\n  ];\r\n\r\n  static readonly const_literal = [\r\n    this.tokens.int_literal,\r\n    this.tokens.uint_literal,\r\n    this.tokens.decimal_float_literal,\r\n    this.tokens.hex_float_literal,\r\n    this.keywords.true,\r\n    this.keywords.false,\r\n  ];\r\n\r\n  static readonly literal_or_ident = [\r\n    this.tokens.ident,\r\n    this.tokens.int_literal,\r\n    this.tokens.uint_literal,\r\n    this.tokens.decimal_float_literal,\r\n    this.tokens.hex_float_literal,\r\n    this.tokens.name\r\n  ];\r\n\r\n  static readonly element_count_expression = [\r\n    this.tokens.int_literal,\r\n    this.tokens.uint_literal,\r\n    this.tokens.ident,\r\n  ];\r\n\r\n  static readonly template_types = [\r\n    this.keywords.vec2,\r\n    this.keywords.vec3,\r\n    this.keywords.vec4,\r\n    this.keywords.mat2x2,\r\n    this.keywords.mat2x3,\r\n    this.keywords.mat2x4,\r\n    this.keywords.mat3x2,\r\n    this.keywords.mat3x3,\r\n    this.keywords.mat3x4,\r\n    this.keywords.mat4x2,\r\n    this.keywords.mat4x3,\r\n    this.keywords.mat4x4,\r\n    this.keywords.atomic,\r\n    this.keywords.bitcast,\r\n    ...this.any_texture_type,\r\n  ];\r\n\r\n  // The grammar calls out 'block', but attribute grammar is defined to use a 'ident'.\r\n  // The attribute grammar should be ident | block.\r\n  static readonly attribute_name = [this.tokens.ident, this.keywords.block, this.keywords.diagnostic];\r\n\r\n  static readonly assignment_operators = [\r\n    this.tokens.equal,\r\n    this.tokens.plus_equal,\r\n    this.tokens.minus_equal,\r\n    this.tokens.times_equal,\r\n    this.tokens.division_equal,\r\n    this.tokens.modulo_equal,\r\n    this.tokens.and_equal,\r\n    this.tokens.or_equal,\r\n    this.tokens.xor_equal,\r\n    this.tokens.shift_right_equal,\r\n    this.tokens.shift_left_equal,\r\n  ];\r\n\r\n  static readonly increment_operators = [\r\n    this.tokens.plus_plus,\r\n    this.tokens.minus_minus,\r\n  ];\r\n}\r\n\r\n/// A token parsed by the WgslScanner.\r\nexport class Token {\r\n  readonly type: TokenType; // The type of the token.\r\n  readonly lexeme: string; // The string of the token, as parsed from the source text.\r\n  readonly line: number; // The line number of the token in the source text.\r\n  readonly start: number; // The start position of the token in the source text.\r\n  readonly end: number; // The end position of the token in the source text.\r\n\r\n  constructor(type: TokenType, lexeme: string, line: number, start: number, end: number) {\r\n    this.type = type;\r\n    this.lexeme = lexeme;\r\n    this.line = line;\r\n    this.start = start;\r\n    this.end = end;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.lexeme;\r\n  }\r\n\r\n  isTemplateType(): boolean {\r\n    return TokenTypes.template_types.indexOf(this.type) != -1;\r\n  }\r\n\r\n  isArrayType(): boolean {\r\n    return this.type == TokenTypes.keywords.array;\r\n  }\r\n\r\n  isArrayOrTemplateType(): boolean {\r\n    return this.isArrayType() || this.isTemplateType();\r\n  }\r\n}\r\n\r\n/// Lexical scanner for the WGSL language. This takes an input source text and generates a list\r\n/// of Token objects, which can then be fed into the WgslParser to generate an AST.\r\nexport class WgslScanner {\r\n  private _source: string;\r\n  private _tokens: Token[] = [];\r\n  private _start = 0;\r\n  private _current = 0;\r\n  private _line = 1;\r\n\r\n  constructor(source?: string) {\r\n    this._source = source ?? \"\";\r\n  }\r\n\r\n  /// Scan all tokens from the source.\r\n  scanTokens(): Token[] {\r\n    while (!this._isAtEnd()) {\r\n      this._start = this._current;\r\n      if (!this.scanToken()) {\r\n        throw `Invalid syntax at line ${this._line}`;\r\n      }\r\n    }\r\n\r\n    this._tokens.push(new Token(TokenTypes.eof, \"\", this._line, this._current, this._current));\r\n\r\n    return this._tokens;\r\n  }\r\n\r\n  /// Scan a single token from the source.\r\n  scanToken(): boolean {\r\n    // Find the longest consecutive set of characters that match a rule.\r\n    let lexeme = this._advance();\r\n\r\n    // Skip line-feed, adding to the line counter.\r\n    if (lexeme == \"\\n\") {\r\n      this._line++;\r\n      return true;\r\n    }\r\n\r\n    // Skip whitespace\r\n    if (this._isWhitespace(lexeme)) {\r\n      return true;\r\n    }\r\n\r\n    if (lexeme == \"/\") {\r\n      // If it's a // comment, skip everything until the next line-feed.\r\n      if (this._peekAhead() == \"/\") {\r\n        while (lexeme != \"\\n\") {\r\n          if (this._isAtEnd()) {\r\n            return true;\r\n          }\r\n          lexeme = this._advance();\r\n        }\r\n        // skip the linefeed\r\n        this._line++;\r\n        return true;\r\n      } else if (this._peekAhead() == \"*\") {\r\n        // If it's a / * block comment, skip everything until the matching * /,\r\n        // allowing for nested block comments.\r\n        this._advance();\r\n        let commentLevel = 1;\r\n        while (commentLevel > 0) {\r\n          if (this._isAtEnd()) {\r\n            return true;\r\n          }\r\n          lexeme = this._advance();\r\n          if (lexeme == \"\\n\") {\r\n            this._line++;\r\n          } else if (lexeme == \"*\") {\r\n            if (this._peekAhead() == \"/\") {\r\n              this._advance();\r\n              commentLevel--;\r\n              if (commentLevel == 0) {\r\n                return true;\r\n              }\r\n            }\r\n          } else if (lexeme == \"/\") {\r\n            if (this._peekAhead() == \"*\") {\r\n              this._advance();\r\n              commentLevel++;\r\n            }\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Shortcut single character tokens\r\n    const simpleToken = TokenTypes.simpleTokens[lexeme];\r\n    if (simpleToken) {\r\n      this._addToken(simpleToken);\r\n      return true;\r\n    }\r\n\r\n    // Shortcut keywords and identifiers\r\n    let matchType = TokenTypes.none;\r\n    const isAlpha = this._isAlpha(lexeme);\r\n    const isUnderscore = lexeme === \"_\";\r\n\r\n    if (this._isAlphaNumeric(lexeme)) {\r\n      let nextChar = this._peekAhead();\r\n      while (this._isAlphaNumeric(nextChar)) {\r\n        lexeme += this._advance();\r\n        nextChar = this._peekAhead();\r\n      }\r\n    }\r\n\r\n    if (isAlpha) {\r\n      const matchedType = TokenTypes.keywords[lexeme];\r\n      if (matchedType) {\r\n        this._addToken(matchedType);\r\n        return true;\r\n      }\r\n    }\r\n\r\n    if (isAlpha || isUnderscore) {\r\n      this._addToken(TokenTypes.tokens.ident);\r\n      return true;\r\n    }\r\n\r\n    // Scan for the next valid token type\r\n    for (;;) {\r\n      let matchedType = this._findType(lexeme);\r\n\r\n      // An exception to \"longest lexeme\" rule is '>>'. In the case of 1>>2, it's a\r\n      // shift_right.\r\n      // In the case of array<vec4<f32>>, it's two greater_than's (one to close the vec4,\r\n      // and one to close the array).\r\n      // Another ambiguity is '>='. In the case of vec2<i32>=vec2(1,2),\r\n      // it's a greather_than and an equal, not a greater_than_equal.\r\n      // Another ambiguity is '-'. In the case of a-2, it's a minus; in the case of a*-2, it's a -2;\r\n      // in the case of foo()->int, it's a ->; in the case of foo-- or --foo, it's a -- decrement.\r\n\r\n      // WGSL requires context sensitive parsing to resolve these ambiguities. Both of these cases\r\n      // are predicated on it the > either closing a template, or being part of an operator.\r\n      // The solution here is to check if there was a less_than up to some number of tokens\r\n      // previously, and the token prior to that is a keyword that requires a '<', then it will be\r\n      // split into two operators; otherwise it's a single operator.\r\n      const nextLexeme = this._peekAhead();\r\n      if (lexeme == \"-\" && this._tokens.length > 0) {\r\n        if (nextLexeme == \"=\") {\r\n          this._current++;\r\n          lexeme += nextLexeme;\r\n          this._addToken(TokenTypes.tokens.minus_equal);\r\n          return true;\r\n        }\r\n        if (nextLexeme == \"-\") {\r\n          this._current++;\r\n          lexeme += nextLexeme;\r\n          this._addToken(TokenTypes.tokens.minus_minus);\r\n          return true;\r\n        }\r\n        const ti = this._tokens.length - 1;\r\n        const isIdentOrLiteral = TokenTypes.literal_or_ident.indexOf(this._tokens[ti].type) != -1;\r\n        if ((isIdentOrLiteral || this._tokens[ti].type == TokenTypes.tokens.paren_right) && nextLexeme != \">\") {\r\n          this._addToken(matchedType);\r\n          return true;\r\n        }\r\n      }\r\n      if (lexeme == \">\" && (nextLexeme == \">\" || nextLexeme == \"=\")) {\r\n        let foundLessThan = false;\r\n        let ti = this._tokens.length - 1;\r\n        for (let count = 0; count < 5 && ti >= 0; ++count, --ti) {\r\n          if (TokenTypes.assignment_operators.indexOf(this._tokens[ti].type) !== -1) {\r\n            break;\r\n          }\r\n          if (this._tokens[ti].type === TokenTypes.tokens.less_than) {\r\n            if (ti > 0 && this._tokens[ti - 1].isArrayOrTemplateType()) {\r\n              foundLessThan = true;\r\n            }\r\n            break;\r\n          }\r\n        }\r\n        // If there was a less_than in the recent token history, then this is probably a\r\n        // greater_than.\r\n        if (foundLessThan) {\r\n          this._addToken(matchedType);\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // The current lexeme may not match any rule, but some token types may be invalid for\r\n      // part of the string but valid after a few more characters.\r\n      // For example, 0x.5 is a hex_float_literal. But as it's being scanned,\r\n      // \"0\" is a int_literal, then \"0x\" is invalid. If we stopped there, it would return\r\n      // the int_literal \"0\", but that's incorrect. So if we look forward a few characters,\r\n      // we'd get \"0x.\", which is still invalid, followed by \"0x.5\" which is the correct\r\n      // hex_float_literal. So that means if we hit an non-matching string, we should look\r\n      // ahead up to two characters to see if the string starts matching a valid rule again.\r\n      if (matchedType === TokenTypes.none) {\r\n        let lookAheadLexeme = lexeme;\r\n        let lookAhead = 0;\r\n        const maxLookAhead = 2;\r\n        for (let li = 0; li < maxLookAhead; ++li) {\r\n          lookAheadLexeme += this._peekAhead(li);\r\n          matchedType = this._findType(lookAheadLexeme);\r\n          if (matchedType !== TokenTypes.none) {\r\n            lookAhead = li;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (matchedType === TokenTypes.none) {\r\n          if (matchType === TokenTypes.none) {\r\n            return false;\r\n          }\r\n          this._current--;\r\n          this._addToken(matchType);\r\n          return true;\r\n        }\r\n\r\n        lexeme = lookAheadLexeme;\r\n        this._current += lookAhead + 1;\r\n      }\r\n\r\n      matchType = matchedType;\r\n\r\n      if (this._isAtEnd()) {\r\n        break;\r\n      }\r\n\r\n      lexeme += this._advance();\r\n    }\r\n\r\n    // We got to the end of the input stream. Then the token we've ready so far is it.\r\n    if (matchType === TokenTypes.none) {\r\n      return false;\r\n    }\r\n\r\n    this._addToken(matchType);\r\n    return true;\r\n  }\r\n\r\n  _findType(lexeme: string): TokenType {\r\n    for (const name in TokenTypes.regexTokens) {\r\n      const type = TokenTypes.regexTokens[name];\r\n      if (this._match(lexeme, type.rule)) {\r\n        return type;\r\n      }\r\n    }\r\n\r\n    const type = TokenTypes.literalTokens[lexeme];\r\n    if (type) {\r\n      return type;\r\n    }\r\n\r\n    return TokenTypes.none;\r\n  }\r\n\r\n  _match(lexeme: string, rule: RegExp): boolean {\r\n    const match = rule.exec(lexeme);\r\n    return match && match.index == 0 && match[0] == lexeme;\r\n  }\r\n\r\n  _isAtEnd(): boolean {\r\n    return this._current >= this._source.length;\r\n  }\r\n\r\n  _isAlpha(c: string): boolean {\r\n    // To support UTF-8 characters, allow anything other than whitespace, numbers, or operators\r\n    return !this._isNumeric(c) && !this._isWhitespace(c) && c !== \"_\" && c !== \".\" && c !== \"(\" && c !== \")\" &&\r\n      c !== \"[\" && c !== \"]\" && c !== \"{\" && c !== \"}\" && c !== \",\" && c !== \";\" && c !== \":\" && c !== \"=\" &&\r\n      c !== \"!\" && c !== \"<\" && c !== \">\" && c !== \"+\" && c !== \"-\" && c !== \"*\" && c !== \"/\" && c !== \"%\" &&\r\n      c !== \"&\" && c !== \"|\" && c !== \"^\" && c !== \"~\" && c !== \"@\" && c !== \"#\" && c !== \"?\" && c !== \"'\" &&\r\n      c !== \"`\" && c !== \"\\\"\" && c !== \"\\\\\" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\0\";\r\n  }\r\n\r\n  _isNumeric(c: string): boolean {\r\n    return c >= \"0\" && c <= \"9\";\r\n  }\r\n\r\n  _isAlphaNumeric(c: string): boolean {\r\n    return this._isAlpha(c) || this._isNumeric(c) || c === \"_\";\r\n  }\r\n\r\n  _isWhitespace(c: string): boolean {\r\n    return c == \" \" || c == \"\\t\" || c == \"\\r\";\r\n  }\r\n\r\n  _advance(amount: number = 0): string {\r\n    let c = this._source[this._current];\r\n    amount = amount || 0;\r\n    amount++;\r\n    this._current += amount;\r\n    return c;\r\n  }\r\n\r\n  _peekAhead(offset: number = 0): string {\r\n    offset = offset || 0;\r\n    if (this._current + offset >= this._source.length) {\r\n      return \"\\0\";\r\n    }\r\n    return this._source[this._current + offset];\r\n  }\r\n\r\n  _addToken(type: TokenType) {\r\n    const text = this._source.substring(this._start, this._current);\r\n    this._tokens.push(new Token(type, text, this._line, this._start, this._current));\r\n  }\r\n}\r\n","export function isArray(value: any): boolean {\r\n    return Array.isArray(value) || value?.buffer instanceof ArrayBuffer;\r\n}\r\n\r\nexport function isNumber(value: any): boolean {\r\n    return typeof value === \"number\";\r\n}\r\n\r\nconst _f32 = new Float32Array(1);\r\nconst _f32_i32 = new Uint32Array(_f32.buffer);\r\nconst _f32_u32 = new Uint32Array(_f32.buffer);\r\nconst _i32 = new Int32Array(1);\r\nconst _i32_f32 = new Float32Array(_i32.buffer);\r\nconst _i32_u32 = new Uint32Array(_i32.buffer);\r\nconst _u32 = new Uint32Array(1);\r\nconst _u32_f32 = new Float32Array(_u32.buffer);\r\nconst _u32_i32 = new Int32Array(_u32.buffer);\r\n\r\nexport function castScalar(v: number, from: string, to: string): number {\r\n    if (from === to) {\r\n        return v;\r\n    }\r\n\r\n    if (from === \"f32\") {\r\n        if (to === \"i32\" || to === \"x32\") {\r\n            _f32[0] = v;\r\n            return _f32_i32[0];\r\n        } else if (to === \"u32\") {\r\n            _f32[0] = v;\r\n            return _f32_u32[0];\r\n        }\r\n    } else if (from === \"i32\" || from === \"x32\") {\r\n        if (to === \"f32\") {\r\n            _i32[0] = v;\r\n            return _i32_f32[0];\r\n        } else if (to === \"u32\") {\r\n            _i32[0] = v;\r\n            return _i32_u32[0];\r\n        }\r\n    } else if (from === \"u32\") {\r\n        if (to === \"f32\") {\r\n            _u32[0] = v;\r\n            return _u32_f32[0];\r\n        } else if (to === \"i32\" || to === \"x32\") {\r\n            _u32[0] = v;\r\n            return _u32_i32[0];\r\n        }\r\n    }\r\n\r\n    console.error(`Unsupported cast from ${from} to ${to}`);\r\n    return v;\r\n}\r\n\r\nexport function castVector(v: number[], from: string, to: string): number[] {\r\n    if (from === to) {\r\n        return v;\r\n    }\r\n\r\n    const cast = new Array<number>(v.length);\r\n    for (let i = 0; i < v.length; i++) {\r\n        cast[i] = castScalar(v[i], from, to);\r\n    }\r\n\r\n    return cast;\r\n}\r\n","/**\r\n * @author Brendan Duncan / https://github.com/brendan-duncan\r\n */\r\nimport { TokenTypes } from \"../wgsl_scanner.js\";\r\nimport { Type, Struct, Alias, Override, Var, Node, Function, VariableExpr, CreateExpr,\r\n    Let, CallExpr, Call, Argument, Member, Attribute, ArrayType, SamplerType, TemplateType, \r\n    PointerType } from \"../wgsl_ast.js\";\r\nimport { _BlockStart, _BlockEnd } from \"../wgsl_ast.js\";\r\nimport { FunctionInfo, VariableInfo, AliasInfo, OverrideInfo, PointerInfo,\r\n  StructInfo, TypeInfo, MemberInfo, ArrayInfo, TemplateInfo, OutputInfo,\r\n  InputInfo, ArgumentInfo, ResourceType, EntryFunctions } from \"./info.js\";\r\nimport { isArray } from \"../utils/cast.js\";\r\n \r\nclass _FunctionResources {\r\n  node: Function;\r\n  resources: VariableInfo[] | null = null;\r\n  inUse: boolean = false;\r\n  info: FunctionInfo | null = null;\r\n  constructor(node: Function) {\r\n    this.node = node;\r\n  }\r\n}\r\n\r\nclass _TypeSize {\r\n  align: number;\r\n  size: number;\r\n\r\n  constructor(align: number, size: number) {\r\n    this.align = align;\r\n    this.size = size;\r\n  }\r\n}\r\n\r\nexport class Reflect {\r\n  /// All top-level uniform vars in the shader.\r\n  uniforms: VariableInfo[] = [];\r\n  /// All top-level storage vars in the shader.\r\n  storage: VariableInfo[] = [];\r\n  /// All top-level texture vars in the shader;\r\n  textures: VariableInfo[] = [];\r\n  // All top-level sampler vars in the shader.\r\n  samplers: VariableInfo[] = [];\r\n  /// All top-level type aliases in the shader.\r\n  aliases: AliasInfo[] = [];\r\n  /// All top-level overrides in the shader.\r\n  overrides: OverrideInfo[] = [];\r\n  /// All top-level structs in the shader.\r\n  structs: StructInfo[] = [];\r\n  /// All entry functions in the shader: vertex, fragment, and/or compute.\r\n  entry: EntryFunctions = new EntryFunctions();\r\n  /// All functions in the shader, including entry functions.\r\n  functions: FunctionInfo[] = [];\r\n\r\n  _types: Map<Type, TypeInfo> = new Map();\r\n  _functions: Map<string, _FunctionResources> = new Map();\r\n\r\n  _isStorageTexture(type: TypeInfo): boolean {\r\n    return (\r\n      type.name == \"texture_storage_1d\" ||\r\n      type.name == \"texture_storage_2d\" ||\r\n      type.name == \"texture_storage_2d_array\" ||\r\n      type.name == \"texture_storage_3d\"\r\n    );\r\n  }\r\n\r\n  updateAST(ast: Node[]): void {\r\n    for (const node of ast) {\r\n      if (node instanceof Function) {\r\n        this._functions.set(node.name, new _FunctionResources(node as Function));\r\n      }\r\n    }\r\n\r\n    for (const node of ast) {\r\n      if (node instanceof Struct) {\r\n        const info = this.getTypeInfo(node as Struct, null);\r\n        if (info instanceof StructInfo) {\r\n          this.structs.push(info as StructInfo);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const node of ast) {\r\n      if (node instanceof Alias) {\r\n        this.aliases.push(this._getAliasInfo(node as Alias));\r\n        continue;\r\n      }\r\n\r\n      if (node instanceof Override) {\r\n        const v = node as Override;\r\n        const id = this._getAttributeNum(v.attributes, \"id\", 0);\r\n        const type = v.type != null ? this.getTypeInfo(v.type, v.attributes) : null;\r\n        this.overrides.push(new OverrideInfo(v.name, type, v.attributes, id));\r\n        continue;\r\n      }\r\n\r\n      if (this._isUniformVar(node)) {\r\n        const v = node as Var;\r\n        const g = this._getAttributeNum(v.attributes, \"group\", 0);\r\n        const b = this._getAttributeNum(v.attributes, \"binding\", 0);\r\n        const type = this.getTypeInfo(v.type!, v.attributes);\r\n        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Uniform, v.access);\r\n        if (!varInfo.access) {\r\n          varInfo.access = \"read\";\r\n        }\r\n        this.uniforms.push(varInfo);\r\n        continue;\r\n      }\r\n\r\n      if (this._isStorageVar(node)) {\r\n        const v = node as Var;\r\n        const g = this._getAttributeNum(v.attributes, \"group\", 0);\r\n        const b = this._getAttributeNum(v.attributes, \"binding\", 0);\r\n        const type = this.getTypeInfo(v.type!, v.attributes);\r\n        const isStorageTexture = this._isStorageTexture(type);\r\n        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Storage, v.access);\r\n        if (!varInfo.access) {\r\n          varInfo.access = \"read\";\r\n        }\r\n        this.storage.push(varInfo);\r\n        continue;\r\n      }\r\n\r\n      if (this._isTextureVar(node)) {\r\n        const v = node as Var;\r\n        const g = this._getAttributeNum(v.attributes, \"group\", 0);\r\n        const b = this._getAttributeNum(v.attributes, \"binding\", 0);\r\n        const type = this.getTypeInfo(v.type!, v.attributes);\r\n        const isStorageTexture = this._isStorageTexture(type);\r\n        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, \r\n            isStorageTexture ? ResourceType.StorageTexture : ResourceType.Texture, v.access);\r\n        if (!varInfo.access) {\r\n          varInfo.access = \"read\";\r\n        }\r\n        if (isStorageTexture) {\r\n          this.storage.push(varInfo);\r\n        } else {\r\n          this.textures.push(varInfo);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (this._isSamplerVar(node)) {\r\n        const v = node as Var;\r\n        const g = this._getAttributeNum(v.attributes, \"group\", 0);\r\n        const b = this._getAttributeNum(v.attributes, \"binding\", 0);\r\n        const type = this.getTypeInfo(v.type!, v.attributes);\r\n        const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Sampler, v.access);\r\n        this.samplers.push(varInfo);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    for (const node of ast) {\r\n      if (node instanceof Function) {\r\n        const vertexStage = this._getAttribute(node, \"vertex\");\r\n        const fragmentStage = this._getAttribute(node, \"fragment\");\r\n        const computeStage = this._getAttribute(node, \"compute\");\r\n        const stage = vertexStage || fragmentStage || computeStage;\r\n\r\n        const fn = new FunctionInfo(node.name, stage?.name, node.attributes);\r\n        fn.attributes = node.attributes;\r\n        fn.startLine = node.startLine;\r\n        fn.endLine = node.endLine;\r\n        this.functions.push(fn);\r\n        this._functions.get(node.name)!.info = fn;\r\n\r\n        if (stage) {\r\n          this._functions.get(node.name)!.inUse = true;\r\n          fn.inUse = true;\r\n          fn.inputs = this._getInputs(node.args);\r\n          fn.outputs = this._getOutputs(node.returnType);\r\n          this.entry[stage.name].push(fn);\r\n        }\r\n        fn.resources = this._findResources(node, !!stage);\r\n\r\n        fn.arguments = node.args.map(\r\n          (arg) => new ArgumentInfo(arg.name, this.getTypeInfo(arg.type, arg.attributes), arg.attributes)\r\n        );\r\n\r\n        fn.returnType = node.returnType ? this.getTypeInfo(node.returnType, node.attributes) : null;\r\n\r\n        continue;\r\n      }\r\n    }\r\n\r\n    for (const fn of this._functions.values()) {\r\n      if (fn.info) {\r\n        fn.info.inUse = fn.inUse;\r\n        this._addCalls(fn.node, fn.info.calls);\r\n      }\r\n    }\r\n\r\n    for (const fn of this._functions.values()) {\r\n      fn.node.search((node) => {\r\n        if (node instanceof Attribute) {\r\n          if (node.value) {\r\n            if (isArray(node.value)) {\r\n              for (const value of node.value) {\r\n                for (const override of this.overrides) {\r\n                  if (value === override.name) {\r\n                    fn.info?.overrides.push(override);\r\n                  }\r\n                }\r\n              }\r\n            } else {\r\n              for (const override of this.overrides) {\r\n                if (node.value === override.name) {\r\n                  fn.info?.overrides.push(override);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else if (node instanceof VariableExpr) {\r\n          for (const override of this.overrides) {\r\n            if (node.name === override.name) {\r\n              fn.info?.overrides.push(override);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    for (const u of this.uniforms) {\r\n      this._markStructsInUse(u.type);\r\n    }\r\n    for (const s of this.storage) {\r\n      this._markStructsInUse(s.type);\r\n    }\r\n  }\r\n\r\n  getFunctionInfo(name: string): FunctionInfo | null {\r\n    for (const fn of this.functions) {\r\n      if (fn.name == name) {\r\n        return fn;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  getStructInfo(name: string): StructInfo | null {\r\n    for (const s of this.structs) {\r\n      if (s.name == name) {\r\n        return s;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  getOverrideInfo(name: string): OverrideInfo | null {\r\n    for (const o of this.overrides) {\r\n      if (o.name == name) {\r\n        return o;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _markStructsInUse(type: TypeInfo) {\r\n    if (!type) {\r\n      return;\r\n    }\r\n    if (type.isStruct) {\r\n      (type as StructInfo).inUse = true;\r\n      if ((type as StructInfo).members) {\r\n        for (const m of (type as StructInfo).members) {\r\n          this._markStructsInUse(m.type);\r\n        }\r\n      }\r\n    } else if (type.isArray) {\r\n      this._markStructsInUse((type as ArrayInfo).format);\r\n    } else if (type.isTemplate) {\r\n      if ((type as TemplateInfo).format) {\r\n        this._markStructsInUse((type as TemplateInfo).format!);\r\n      }\r\n    } else {\r\n      const alias = this._getAlias(type.name);\r\n      if (alias) {\r\n        this._markStructsInUse(alias);\r\n      }\r\n    }\r\n  }\r\n\r\n  _addCalls(fn: Function, calls: Set<FunctionInfo>, ) {\r\n    for (const call of fn.calls) {\r\n      const info = this._functions.get(call.name)?.info;\r\n      if (info) {\r\n        calls.add(info);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// Find a resource by its group and binding.\r\n  findResource(group: number, binding: number, entry?: string) {\r\n    if (entry) {\r\n      for (const fn of this.entry.compute) {\r\n        if (fn.name === entry) {\r\n          for (const r of fn.resources) {\r\n            if (r.group == group && r.binding == binding) {\r\n              return r;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      for (const fn of this.entry.vertex) {\r\n        if (fn.name === entry) {\r\n          for (const r of fn.resources) {\r\n            if (r.group == group && r.binding == binding) {\r\n              return r;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      for (const fn of this.entry.fragment) {\r\n        if (fn.name === entry) {\r\n          for (const r of fn.resources) {\r\n            if (r.group == group && r.binding == binding) {\r\n              return r;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const u of this.uniforms) {\r\n      if (u.group == group && u.binding == binding) {\r\n        return u;\r\n      }\r\n    }\r\n    for (const s of this.storage) {\r\n      if (s.group == group && s.binding == binding) {\r\n        return s;\r\n      }\r\n    }\r\n    for (const t of this.textures) {\r\n      if (t.group == group && t.binding == binding) {\r\n        return t;\r\n      }\r\n    }\r\n    for (const s of this.samplers) {\r\n      if (s.group == group && s.binding == binding) {\r\n        return s;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _findResource(name: string): VariableInfo | null {\r\n    for (const u of this.uniforms) {\r\n      if (u.name == name) {\r\n        return u;\r\n      }\r\n    }\r\n    for (const s of this.storage) {\r\n      if (s.name == name) {\r\n        return s;\r\n      }\r\n    }\r\n    for (const t of this.textures) {\r\n      if (t.name == name) {\r\n        return t;\r\n      }\r\n    }\r\n    for (const s of this.samplers) {\r\n      if (s.name == name) {\r\n        return s;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  _markStructsFromAST(type: Type) {\r\n    const info = this.getTypeInfo(type, null);\r\n    this._markStructsInUse(info);\r\n  }\r\n\r\n  _findResources(fn: Node, isEntry: boolean): VariableInfo[] {\r\n    const resources: any[] = [];\r\n    const self = this;\r\n    const varStack: any[] = [];\r\n    fn.search((node) => {\r\n      if (node instanceof _BlockStart) {\r\n        varStack.push({});\r\n      } else if (node instanceof _BlockEnd) {\r\n        varStack.pop();\r\n      } else if (node instanceof Var) {\r\n        const v = node as Var;\r\n        if (isEntry && v.type !== null) {\r\n          this._markStructsFromAST(v.type);\r\n        }\r\n        if (varStack.length > 0) {\r\n          varStack[varStack.length - 1][v.name] = v;\r\n        }\r\n      } else if (node instanceof CreateExpr) {\r\n        const c = node as CreateExpr;\r\n        if (isEntry && c.type !== null) {\r\n          this._markStructsFromAST(c.type);\r\n        }\r\n      } else if (node instanceof Let) {\r\n        const v = node as Let;\r\n        if (isEntry && v.type !== null) {\r\n          this._markStructsFromAST(v.type);\r\n        }\r\n        if (varStack.length > 0) {\r\n          varStack[varStack.length - 1][v.name] = v;\r\n        }\r\n      } else if (node instanceof VariableExpr) {\r\n        const v = node as VariableExpr;\r\n        // Check to see if the variable is a local variable before checking to see if it's\r\n        // a resource.\r\n        if (varStack.length > 0) {\r\n          const varInfo = varStack[varStack.length - 1][v.name];\r\n          if (varInfo) {\r\n            return;\r\n          }\r\n        }\r\n        const varInfo = self._findResource(v.name);\r\n        if (varInfo) {\r\n          resources.push(varInfo);\r\n        }\r\n      } else if (node instanceof CallExpr) {\r\n        const c = node as CallExpr;\r\n        const callFn = self._functions.get(c.name);\r\n        if (callFn) {\r\n          if (isEntry) {\r\n            callFn.inUse = true;\r\n          }\r\n          (fn as Function).calls.add(callFn.node);\r\n          // force the recursion to mark the structures\r\n          callFn.resources = self._findResources(callFn.node, isEntry);\r\n          resources.push(...callFn.resources);\r\n        }\r\n        if (c.name === \"textureSample\") {\r\n          if (c.args.length >= 2) {\r\n            const textureArg = c.args[0];\r\n            let texture = null;\r\n            if (textureArg instanceof VariableExpr) {\r\n              const varInfo = self._findResource(textureArg.name);\r\n              if (varInfo && varInfo.resourceType === ResourceType.Texture) {\r\n                texture = varInfo;\r\n              }\r\n            }\r\n            const samplerArg = c.args[1];\r\n            let sampler = null;\r\n            if (samplerArg instanceof VariableExpr) {\r\n              const varInfo = self._findResource(samplerArg.name);\r\n              if (varInfo && varInfo.resourceType === ResourceType.Sampler) {\r\n                sampler = varInfo;\r\n              }\r\n            }\r\n\r\n            if (texture && sampler) {\r\n              if (texture.relations === null) {\r\n                texture.relations = [];\r\n              }\r\n              texture.relations.push(sampler);\r\n\r\n              if (sampler.relations === null) {\r\n                sampler.relations = [];\r\n              }\r\n              sampler.relations.push(texture);\r\n            }\r\n          }\r\n        }\r\n      } else if (node instanceof Call) {\r\n        const c = node as Call;\r\n        const callFn = self._functions.get(c.name);\r\n        if (callFn) {\r\n          if (isEntry) {\r\n            callFn.inUse = true;\r\n          }\r\n          (fn as Function).calls.add(callFn.node);\r\n          // force the recursion to mark the structures\r\n          callFn.resources = self._findResources(callFn.node, isEntry);\r\n          resources.push(...callFn.resources);\r\n        }\r\n      }\r\n    });\r\n    return [...new Map(resources.map(r => [r.name, r])).values()];\r\n  }\r\n\r\n  getBindGroups(): Array<VariableInfo[]> {\r\n    const groups: Array<VariableInfo[]> = [];\r\n\r\n    function _makeRoom(group: number, binding: number) {\r\n      if (group >= groups.length) {\r\n        groups.length = group + 1;\r\n      }\r\n\r\n      if (groups[group] === undefined) {\r\n        groups[group] = [];\r\n      }\r\n\r\n      if (binding >= groups[group].length) {\r\n        groups[group].length = binding + 1;\r\n      }\r\n    }\r\n\r\n    for (const u of this.uniforms) {\r\n      _makeRoom(u.group, u.binding);\r\n      const group = groups[u.group];\r\n      group[u.binding] = u;\r\n    }\r\n\r\n    for (const u of this.storage) {\r\n      _makeRoom(u.group, u.binding);\r\n      const group = groups[u.group];\r\n      group[u.binding] = u;\r\n    }\r\n\r\n    for (const t of this.textures) {\r\n      _makeRoom(t.group, t.binding);\r\n      const group = groups[t.group];\r\n      group[t.binding] = t;\r\n    }\r\n\r\n    for (const t of this.samplers) {\r\n      _makeRoom(t.group, t.binding);\r\n      const group = groups[t.group];\r\n      group[t.binding] = t;\r\n    }\r\n\r\n    return groups;\r\n  }\r\n\r\n  _getOutputs(\r\n    type: Type,\r\n    outputs: OutputInfo[] | undefined = undefined\r\n  ): OutputInfo[] {\r\n    if (outputs === undefined) {\r\n      outputs = [];\r\n    }\r\n\r\n    if (type instanceof Struct) {\r\n      this._getStructOutputs(type, outputs);\r\n    } else {\r\n      const output = this._getOutputInfo(type);\r\n      if (output !== null) {\r\n        outputs.push(output);\r\n      }\r\n    }\r\n\r\n    return outputs;\r\n  }\r\n\r\n  _getStructOutputs(struct: Struct, outputs: OutputInfo[]) {\r\n    for (const m of struct.members) {\r\n      if (m.type instanceof Struct) {\r\n        this._getStructOutputs(m.type, outputs);\r\n      } else {\r\n        const location =\r\n          this._getAttribute(m, \"location\") || this._getAttribute(m, \"builtin\");\r\n        if (location !== null) {\r\n          const typeInfo = this.getTypeInfo(m.type, m.type.attributes);\r\n          const locationValue = this._parseInt(location.value);\r\n          const info = new OutputInfo(\r\n            m.name,\r\n            typeInfo,\r\n            location.name,\r\n            locationValue\r\n          );\r\n          outputs.push(info);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _getOutputInfo(type: Type): OutputInfo | null {\r\n    const location =\r\n      this._getAttribute(type, \"location\") ||\r\n      this._getAttribute(type, \"builtin\");\r\n    if (location !== null) {\r\n      const typeInfo = this.getTypeInfo(type, type.attributes);\r\n      const locationValue = this._parseInt(location.value);\r\n      const info = new OutputInfo(\"\", typeInfo, location.name, locationValue);\r\n      return info;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _getInputs(\r\n    args: Argument[],\r\n    inputs: InputInfo[] | undefined = undefined\r\n  ): InputInfo[] {\r\n    if (inputs === undefined) {\r\n      inputs = [];\r\n    }\r\n\r\n    for (const arg of args) {\r\n      if (arg.type instanceof Struct) {\r\n        this._getStructInputs(arg.type, inputs);\r\n      } else {\r\n        const input = this._getInputInfo(arg);\r\n        if (input !== null) {\r\n          inputs.push(input);\r\n        }\r\n      }\r\n    }\r\n\r\n    return inputs;\r\n  }\r\n\r\n  _getStructInputs(struct: Struct, inputs: InputInfo[]) {\r\n    for (const m of struct.members) {\r\n      if (m.type instanceof Struct) {\r\n        this._getStructInputs(m.type, inputs);\r\n      } else {\r\n        const input = this._getInputInfo(m);\r\n        if (input !== null) {\r\n          inputs.push(input);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _getInputInfo(node: Member | Argument): InputInfo | null {\r\n    const location =\r\n      this._getAttribute(node, \"location\") ||\r\n      this._getAttribute(node, \"builtin\");\r\n    if (location !== null) {\r\n      const interpolation = this._getAttribute(node, \"interpolation\");\r\n      const type = this.getTypeInfo(node.type, node.attributes);\r\n      const locationValue = this._parseInt(location.value);\r\n      const info = new InputInfo(node.name, type, location.name, locationValue);\r\n      if (interpolation !== null) {\r\n        info.interpolation = this._parseString(interpolation.value);\r\n      }\r\n      return info;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _parseString(s: string | string[]): string {\r\n    if (s instanceof Array) {\r\n      s = s[0];\r\n    }\r\n    return s;\r\n  }\r\n\r\n  _parseInt(s: string | string[]): number | string {\r\n    if (s instanceof Array) {\r\n      s = s[0];\r\n    }\r\n    const n = parseInt(s);\r\n    return isNaN(n) ? s : n;\r\n  }\r\n\r\n  _getAlias(name: string): TypeInfo | null {\r\n    for (const a of this.aliases) {\r\n      if (a.name == name) {\r\n        return a.type;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _getAliasInfo(node: Alias): AliasInfo {\r\n    return new AliasInfo(node.name, this.getTypeInfo(node.type!, null));\r\n  }\r\n\r\n  getTypeInfoByName(name: string): TypeInfo | null {\r\n    for (const s of this.structs) {\r\n      if (s.name == name) {\r\n        return s;\r\n      }\r\n    }\r\n    for (const a of this.aliases) {\r\n      if (a.name == name) {\r\n        return a.type;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  getTypeInfo(type: Type, attributes: Attribute[] | null = null): TypeInfo {\r\n    if (this._types.has(type)) {\r\n      return this._types.get(type)!;\r\n    }\r\n\r\n    if (type instanceof PointerType) {\r\n      const t = type.type ? this.getTypeInfo(type.type!, type.attributes) : null;\r\n      const info = new PointerInfo(type.name, t, attributes);\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    if (type instanceof ArrayType) {\r\n      const a = type as ArrayType;\r\n      const t = a.format ? this.getTypeInfo(a.format!, a.attributes) : null;\r\n      const info = new ArrayInfo(a.name, attributes);\r\n      info.format = t;\r\n      info.count = a.count;\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    if (type instanceof Struct) {\r\n      const s = type as Struct;\r\n      const info = new StructInfo(s.name, attributes);\r\n      info.startLine = s.startLine;\r\n      info.endLine = s.endLine;\r\n      for (const m of s.members) {\r\n        const t = this.getTypeInfo(m.type!, m.attributes);\r\n        info.members.push(new MemberInfo(m.name, t, m.attributes));\r\n      }\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    if (type instanceof SamplerType) {\r\n      const s = type as SamplerType;\r\n      const formatIsType = s.format instanceof Type;\r\n      const format = s.format\r\n        ? formatIsType\r\n          ? this.getTypeInfo(s.format! as Type, null)\r\n          : new TypeInfo(s.format! as string, null)\r\n        : null;\r\n      const info = new TemplateInfo(s.name, format, attributes, s.access);\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    if (type instanceof TemplateType) {\r\n      const t = type as TemplateType;\r\n      const format = t.format ? this.getTypeInfo(t.format!, null) : null;\r\n      const info = new TemplateInfo(t.name, format, attributes, t.access);\r\n      this._types.set(type, info);\r\n      this._updateTypeInfo(info);\r\n      return info;\r\n    }\r\n\r\n    const info = new TypeInfo(type.name, attributes);\r\n    this._types.set(type, info);\r\n    this._updateTypeInfo(info);\r\n    return info;\r\n  }\r\n\r\n  _updateTypeInfo(type: TypeInfo) {\r\n    const typeSize = this._getTypeSize(type);\r\n    type.size = typeSize?.size ?? 0;\r\n\r\n    if (type instanceof ArrayInfo) {\r\n      if (type[\"format\"]) {\r\n        const formatInfo = this._getTypeSize(type[\"format\"]);\r\n        // Array stride is the maximum of the format size and alignment.\r\n        // In the case of a vec3f, the size is 12 bytes, but the alignment is 16 bytes.\r\n        // Buffer alignment is therefore 16 bytes.\r\n        type.stride = Math.max(formatInfo?.size ?? 0, formatInfo?.align ?? 0);\r\n        this._updateTypeInfo(type[\"format\"]);\r\n      }\r\n    }\r\n\r\n    if (type instanceof PointerInfo) {\r\n      this._updateTypeInfo(type[\"format\"]);\r\n    }\r\n\r\n    if (type instanceof StructInfo) {\r\n      this._updateStructInfo(type);\r\n    }\r\n  }\r\n\r\n  _updateStructInfo(struct: StructInfo) {\r\n    let offset = 0;\r\n    let lastSize = 0;\r\n    let lastOffset = 0;\r\n    let structAlign = 0;\r\n\r\n    for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {\r\n      const member = struct.members[mi];\r\n\r\n      const sizeInfo = this._getTypeSize(member);\r\n      if (!sizeInfo) {\r\n        continue;\r\n      }\r\n\r\n      const type = this._getAlias(member.type.name) ?? member.type;\r\n      const align = sizeInfo.align;\r\n      const size = sizeInfo.size;\r\n      offset = this._roundUp(align, offset + lastSize);\r\n      lastSize = size;\r\n      lastOffset = offset;\r\n      structAlign = Math.max(structAlign, align);\r\n\r\n      member.offset = offset;\r\n      member.size = size;\r\n\r\n      this._updateTypeInfo(member.type);\r\n    }\r\n\r\n    struct.size = this._roundUp(structAlign, lastOffset + lastSize);\r\n    struct.align = structAlign;\r\n  }\r\n\r\n  _getTypeSize(\r\n    type: TypeInfo | MemberInfo | null | undefined\r\n  ): _TypeSize | null {\r\n    if (type === null || type === undefined) {\r\n      return null;\r\n    }\r\n\r\n    const explicitSize = this._getAttributeNum(type.attributes, \"size\", 0);\r\n    const explicitAlign = this._getAttributeNum(type.attributes, \"align\", 0);\r\n\r\n    if (type instanceof MemberInfo) {\r\n      type = type.type;\r\n    }\r\n\r\n    if (type instanceof TypeInfo) {\r\n      const alias = this._getAlias(type.name);\r\n      if (alias !== null) {\r\n        type = alias;\r\n      }\r\n    }\r\n\r\n    {\r\n      const info = Reflect._typeInfo[type.name];\r\n      if (info !== undefined) {\r\n        const divisor = type[\"format\"]?.name === \"f16\" ? 2 : 1;\r\n        return new _TypeSize(\r\n          Math.max(explicitAlign, info.align / divisor),\r\n          Math.max(explicitSize, info.size / divisor)\r\n        );\r\n      }\r\n    }\r\n\r\n    {\r\n      const info =\r\n        Reflect._typeInfo[type.name.substring(0, type.name.length - 1)];\r\n      if (info) {\r\n        const divisor = type.name[type.name.length - 1] === \"h\" ? 2 : 1;\r\n        return new _TypeSize(\r\n          Math.max(explicitAlign, info.align / divisor),\r\n          Math.max(explicitSize, info.size / divisor)\r\n        );\r\n      }\r\n    }\r\n\r\n    if (type instanceof ArrayInfo) {\r\n      let arrayType = type as ArrayInfo;\r\n      let align = 8;\r\n      let size = 8;\r\n      // Type                 AlignOf(T)          Sizeof(T)\r\n      // array<E, N>          AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))\r\n      // array<E>             AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))  (N determined at runtime)\r\n      //\r\n      // @stride(Q)\r\n      // array<E, N>          AlignOf(E)          N * Q\r\n      //\r\n      // @stride(Q)\r\n      // array<E>             AlignOf(E)          Nruntime * Q\r\n      //const E = type.format.name;\r\n      const E = this._getTypeSize(arrayType.format);\r\n      if (E !== null) {\r\n        size = E.size;\r\n        align = E.align;\r\n      }\r\n\r\n      const N = arrayType.count;\r\n\r\n      const stride = this._getAttributeNum(\r\n        type?.attributes ?? null,\r\n        \"stride\",\r\n        this._roundUp(align, size)\r\n      );\r\n      size = N * stride;\r\n\r\n      if (explicitSize) {\r\n        size = explicitSize;\r\n      }\r\n\r\n      return new _TypeSize(\r\n        Math.max(explicitAlign, align),\r\n        Math.max(explicitSize, size)\r\n      );\r\n    }\r\n\r\n    if (type instanceof StructInfo) {\r\n      let align = 0;\r\n      let size = 0;\r\n      // struct S     AlignOf:    max(AlignOfMember(S, M1), ... , AlignOfMember(S, MN))\r\n      //              SizeOf:     roundUp(AlignOf(S), OffsetOfMember(S, L) + SizeOfMember(S, L))\r\n      //                          Where L is the last member of the structure\r\n      let offset = 0;\r\n      let lastSize = 0;\r\n      let lastOffset = 0;\r\n      for (const m of type.members) {\r\n        const mi = this._getTypeSize(m.type);\r\n        if (mi !== null) {\r\n          align = Math.max(mi.align, align);\r\n          offset = this._roundUp(mi.align, offset + lastSize);\r\n          lastSize = mi.size;\r\n          lastOffset = offset;\r\n        }\r\n      }\r\n      size = this._roundUp(align, lastOffset + lastSize);\r\n\r\n      return new _TypeSize(\r\n        Math.max(explicitAlign, align),\r\n        Math.max(explicitSize, size)\r\n      );\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _isUniformVar(node: Node): boolean {\r\n    return node instanceof Var && node.storage == \"uniform\";\r\n  }\r\n\r\n  _isStorageVar(node: Node): boolean {\r\n    return node instanceof Var && node.storage == \"storage\";\r\n  }\r\n\r\n  _isTextureVar(node: Node): boolean {\r\n    return (\r\n      node instanceof Var &&\r\n      node.type !== null &&\r\n      Reflect._textureTypes.indexOf(node.type.name) != -1\r\n    );\r\n  }\r\n\r\n  _isSamplerVar(node: Node): boolean {\r\n    return (\r\n      node instanceof Var &&\r\n      node.type !== null &&\r\n      Reflect._samplerTypes.indexOf(node.type.name) != -1\r\n    );\r\n  }\r\n\r\n  _getAttribute(node: Node, name: string): Attribute | null {\r\n    const obj = node as Object;\r\n    if (!obj || !obj[\"attributes\"]) {\r\n      return null;\r\n    }\r\n    const attrs = obj[\"attributes\"];\r\n    for (let a of attrs) {\r\n      if (a.name == name) {\r\n        return a;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _getAttributeNum(\r\n    attributes: Attribute[] | null,\r\n    name: string,\r\n    defaultValue: number\r\n  ): number {\r\n    if (attributes === null) {\r\n      return defaultValue;\r\n    }\r\n    for (let a of attributes) {\r\n      if (a.name == name) {\r\n        let v = a !== null && a.value !== null ? a.value : defaultValue;\r\n        if (v instanceof Array) {\r\n          v = v[0];\r\n        }\r\n        if (typeof v === \"number\") {\r\n          return v;\r\n        }\r\n        if (typeof v === \"string\") {\r\n          return parseInt(v);\r\n        }\r\n        return defaultValue;\r\n      }\r\n    }\r\n    return defaultValue;\r\n  }\r\n\r\n  _roundUp(k: number, n: number): number {\r\n    return Math.ceil(n / k) * k;\r\n  }\r\n\r\n  // Type                 AlignOf(T)          Sizeof(T)\r\n  // i32, u32, or f32     4                   4\r\n  // atomic<T>            4                   4\r\n  // vec2<T>              8                   8\r\n  // vec3<T>              16                  12\r\n  // vec4<T>              16                  16\r\n  // mat2x2<f32>          8                   16\r\n  // mat3x2<f32>          8                   24\r\n  // mat4x2<f32>          8                   32\r\n  // mat2x3<f32>          16                  32\r\n  // mat3x3<f32>          16                  48\r\n  // mat4x3<f32>          16                  64\r\n  // mat2x4<f32>          16                  32\r\n  // mat3x4<f32>          16                  48\r\n  // mat4x4<f32>          16                  64\r\n  static readonly _typeInfo = {\r\n    f16: { align: 2, size: 2 },\r\n    i32: { align: 4, size: 4 },\r\n    u32: { align: 4, size: 4 },\r\n    f32: { align: 4, size: 4 },\r\n    atomic: { align: 4, size: 4 },\r\n    vec2: { align: 8, size: 8 },\r\n    vec3: { align: 16, size: 12 },\r\n    vec4: { align: 16, size: 16 },\r\n    mat2x2: { align: 8, size: 16 },\r\n    mat3x2: { align: 8, size: 24 },\r\n    mat4x2: { align: 8, size: 32 },\r\n    mat2x3: { align: 16, size: 32 },\r\n    mat3x3: { align: 16, size: 48 },\r\n    mat4x3: { align: 16, size: 64 },\r\n    mat2x4: { align: 16, size: 32 },\r\n    mat3x4: { align: 16, size: 48 },\r\n    mat4x4: { align: 16, size: 64 },\r\n  };\r\n\r\n  static readonly _textureTypes = TokenTypes.any_texture_type.map((t) => {\r\n    return t.name;\r\n  });\r\n\r\n  static readonly _samplerTypes = TokenTypes.sampler_type.map((t) => {\r\n    return t.name;\r\n  });\r\n}\r\n\r\n\r\n","import { Let, Var, Argument, Function } from \"../wgsl_ast.js\";\r\nimport { Data } from \"../wgsl_ast.js\";\r\n\r\ntype ASTVarNode = Let | Var | Argument;\r\n\r\nlet _id = 0;\r\n\r\nexport class VarRef {\r\n    name: string;\r\n    value: Data;\r\n    node: ASTVarNode | null;\r\n    readonly id: number = _id++;\r\n\r\n    constructor(n: string, v: Data, node: ASTVarNode | null) {\r\n        this.name = n;\r\n        this.value = v;\r\n        this.node = node;\r\n    }\r\n\r\n    clone(): VarRef {\r\n        return new VarRef(this.name, this.value, this.node);\r\n    }\r\n};\r\n\r\nexport class FunctionRef {\r\n    name: string;\r\n    node: Function;\r\n    readonly id: number = _id++;\r\n\r\n    constructor(node: Function) {\r\n        this.name = node.name;\r\n        this.node = node;\r\n    }\r\n\r\n    clone(): FunctionRef {\r\n        return new FunctionRef(this.node);\r\n    }\r\n};\r\n\r\nexport class ExecContext {\r\n    parent: ExecContext | null = null;\r\n    variables = new Map<string, VarRef>();\r\n    functions = new Map<string, FunctionRef>();\r\n    currentFunctionName = \"\";\r\n    readonly id: number = _id++;\r\n\r\n    constructor(parent?: ExecContext) {\r\n        if (parent) {\r\n            this.parent = parent;\r\n            this.currentFunctionName = parent.currentFunctionName;\r\n        }\r\n    }\r\n\r\n    getVariable(name: string): VarRef | null {\r\n        if (this.variables.has(name)) {\r\n            return this.variables.get(name) ?? null;\r\n        }\r\n        if (this.parent) {\r\n            return this.parent.getVariable(name);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getFunction(name: string): FunctionRef | null {\r\n        if (this.functions.has(name)) {\r\n            return this.functions.get(name) ?? null;\r\n        }\r\n        if (this.parent) {\r\n            return this.parent.getFunction(name);\r\n        }\r\n        return null\r\n    }\r\n\r\n    createVariable(name: string, value: Data, node?: ASTVarNode) {\r\n        this.variables.set(name, new VarRef(name, value, node ?? null));\r\n    }\r\n\r\n    setVariable(name: string, value: Data, node?: ASTVarNode) {\r\n        const v = this.getVariable(name);\r\n        if (v !== null) {\r\n            v.value = value;\r\n        } else {\r\n            this.createVariable(name, value, node);\r\n        }\r\n    }\r\n\r\n    getVariableValue(name: string): Data | null {\r\n        const v = this.getVariable(name);\r\n        return v?.value ?? null;\r\n    }\r\n\r\n    clone(): ExecContext {\r\n        return new ExecContext(this);\r\n    }\r\n};\r\n","import { Node, Type } from \"../wgsl_ast.js\";\r\nimport { ExecContext } from \"./exec_context.js\";\r\nimport { TypeInfo } from \"../wgsl_reflect.js\";\r\nimport { Data } from \"../wgsl_ast.js\";\r\n\r\nexport class ExecInterface {\r\n    evalExpression(node: Node, context: ExecContext): Data | null {\r\n        return null;\r\n    }\r\n\r\n    getTypeInfo(type: Type | string): TypeInfo | null {\r\n        return null; \r\n    }\r\n\r\n    getVariableName(node: Node, context: ExecContext): string | null {\r\n        return \"\";\r\n    }\r\n}\r\n","import { CallExpr, Call, UnaryOperator, VariableExpr } from \"../wgsl_ast.js\";\r\nimport { Data, TypedData, TextureData, ScalarData, VectorData, MatrixData } from \"../wgsl_ast.js\";\r\nimport { ExecContext } from \"./exec_context.js\";\r\nimport { ExecInterface } from \"./exec_interface.js\";\r\nimport { ArrayInfo, TypeInfo } from \"../reflect/info.js\";\r\n\r\nexport class BuiltinFunctions {\r\n    exec: ExecInterface;\r\n\r\n    constructor(exec: ExecInterface) {\r\n        this.exec = exec;\r\n    }\r\n\r\n    getTypeInfo(type: string): TypeInfo | null {\r\n        return this.exec.getTypeInfo(type);\r\n    }\r\n\r\n    // Logical Built-in Functions\r\n    All(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        let isTrue = true;\r\n        if (value instanceof VectorData) {\r\n            value.data.forEach((x: any) => { if (!x) isTrue = false; });\r\n            return new ScalarData(isTrue ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n        }\r\n        throw new Error(`All() expects a vector argument. Line ${node.line}`);\r\n    }\r\n\r\n    Any(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            const res = value.data.some((v: any) => v);\r\n            return new ScalarData(res ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n        }\r\n        throw new Error(`Any() expects a vector argument. Line ${node.line}`);\r\n    }\r\n\r\n    Select(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // select(false, true, condition)\r\n        const condition = this.exec.evalExpression(node.args[2], context);\r\n        if (!(condition instanceof ScalarData)) {\r\n            throw new Error(`Select() expects a bool condition. Line ${node.line}`);\r\n        }\r\n        if (!condition.value) {\r\n            return this.exec.evalExpression(node.args[0], context);\r\n        } else {\r\n            return this.exec.evalExpression(node.args[1], context);\r\n        }\r\n    }\r\n\r\n    // Array Built-in Functions\r\n    ArrayLength(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let arrayArg = node.args[0];\r\n        // TODO: handle \"&\" operator\r\n        if (arrayArg instanceof UnaryOperator) {\r\n            arrayArg = (arrayArg as UnaryOperator).right;\r\n        }\r\n        const arrayData = this.exec.evalExpression(arrayArg, context);\r\n        if (arrayData instanceof TypedData && arrayData.typeInfo.size === 0) {\r\n            const ta = arrayData.typeInfo as ArrayInfo;\r\n            const count = arrayData.buffer.byteLength / ta.stride;\r\n            return new ScalarData(count, this.getTypeInfo(\"u32\"));\r\n        }\r\n        return new ScalarData(arrayData.typeInfo.size, this.getTypeInfo(\"u32\"));\r\n    }\r\n\r\n    // Numeric Built-in Functions\r\n    Abs(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.abs(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.abs(s.value), s.typeInfo);\r\n    }\r\n\r\n    Acos(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.acos(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.acos(s.value), value.typeInfo);\r\n    }\r\n\r\n    Acosh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.acosh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.acosh(s.value), value.typeInfo);\r\n    }\r\n\r\n    Asin(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.asin(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.asin(s.value), value.typeInfo);\r\n    }\r\n\r\n    Asinh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.asinh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.asinh(s.value), value.typeInfo);\r\n    }\r\n\r\n    Atan(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.atan(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.atan(s.value), value.typeInfo);\r\n    }\r\n\r\n    Atanh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.atanh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.atanh(s.value), value.typeInfo);\r\n    }\r\n\r\n    Atan2(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const y = this.exec.evalExpression(node.args[0], context);\r\n        const x = this.exec.evalExpression(node.args[1], context);\r\n        if (y instanceof VectorData && x instanceof VectorData) {\r\n            return new VectorData(y.data.map((v: number, i: number) => Math.atan2(v, x.data[i])), y.typeInfo);\r\n        }\r\n        const ys = y as ScalarData;\r\n        const xs = x as ScalarData;\r\n        return new ScalarData(Math.atan2(ys.value, xs.value), y.typeInfo);\r\n    }\r\n\r\n    Ceil(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.ceil(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.ceil(s.value), value.typeInfo);\r\n    }\r\n\r\n    _clamp(value: number, min: number, max: number): number {\r\n        return Math.min(Math.max(value, min), max);\r\n    }\r\n\r\n    Clamp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        const min = this.exec.evalExpression(node.args[1], context);\r\n        const max = this.exec.evalExpression(node.args[2], context);\r\n        if (value instanceof VectorData && min instanceof VectorData && max instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number, i: number) => this._clamp(v, min.data[i], max.data[i])), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        const minS = min as ScalarData;\r\n        const maxS = max as ScalarData\r\n        return new ScalarData(this._clamp(s.value, minS.value, maxS.value), value.typeInfo);\r\n    }\r\n\r\n    Cos(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.cos(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.cos(s.value), value.typeInfo);\r\n    }\r\n\r\n    Cosh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.cosh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.cos(s.value), value.typeInfo);\r\n    }\r\n\r\n    CountLeadingZeros(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.clz32(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.clz32(s.value), value.typeInfo);\r\n    }\r\n\r\n    _countOneBits(value: number): number {\r\n        let count = 0;\r\n        while (value !== 0) {\r\n            if (value & 1) {\r\n                count++;\r\n            }\r\n            value >>= 1;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    CountOneBits(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => this._countOneBits(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(this._countOneBits(s.value), value.typeInfo);\r\n    }\r\n\r\n    _countTrailingZeros(value: number): number {\r\n        if (value === 0) {\r\n            return 32; // Special case for 0\r\n        }\r\n        let count = 0;\r\n        while ((value & 1) === 0) {\r\n            value >>= 1;\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    CountTrailingZeros(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => this._countTrailingZeros(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(this._countTrailingZeros(s.value), value.typeInfo);\r\n    }\r\n\r\n    Cross(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            if (l.data.length !== 3 || r.data.length !== 3) {\r\n                console.error(`Cross() expects 3D vectors. Line ${node.line}`);\r\n                return null;\r\n            }\r\n            const lv = l.data;\r\n            const rv = r.data;\r\n            return new VectorData([\r\n                lv[1] * rv[2] - rv[1] * lv[2],\r\n                lv[2] * rv[0] - rv[2] * lv[0],\r\n                lv[0] * rv[1] - rv[0] * lv[1],\r\n            ], l.typeInfo);\r\n        }\r\n        console.error(`Cross() expects vector arguments. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Degrees(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        const radToDeg = 180.0 / Math.PI;\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => v * radToDeg), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(s.value * radToDeg, this.getTypeInfo(\"f32\"));\r\n    }\r\n\r\n    Determinant(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const m = this.exec.evalExpression(node.args[0], context);\r\n        if (m instanceof MatrixData) {\r\n            const mv = m.data;\r\n            const mt = m.typeInfo.getTypeName();\r\n            const isHalf = mt.endsWith(\"h\");\r\n            const formatType = isHalf ? this.getTypeInfo(\"f16\") : this.getTypeInfo(\"f32\");\r\n            if (mt === \"mat2x2\" || mt === \"mat2x2f\" || mt === \"mat2x2h\") {\r\n                return new ScalarData(mv[0] * mv[3] - mv[1] * mv[2], formatType);\r\n            } else if (mt === \"mat2x3\" || mt === \"mat2x3f\" || mt === \"mat2x3h\") {\r\n                return new ScalarData(mv[0] * (mv[4] * mv[8] - mv[5] * mv[7]) -\r\n                        mv[1] * (mv[3] * mv[8] - mv[5] * mv[6]) + mv[2] * (mv[3] * mv[7] - mv[4] * mv[6]), formatType);\r\n            } else if (mt === \"mat2x4\" || mt === \"mat2x4f\" || mt === \"mat2x4h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat3x2\" || mt === \"mat3x2f\" || mt === \"mat3x2h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat3x3\" || mt === \"mat3x3f\" || mt === \"mat3x3h\") {\r\n                return new ScalarData(mv[0] * (mv[4] * mv[8] - mv[5] * mv[7]) -\r\n                        mv[1] * (mv[3] * mv[8] - mv[5] * mv[6]) + mv[2] * (mv[3] * mv[7] - mv[4] * mv[6]), formatType);\r\n            } else if (mt === \"mat3x4\" || mt === \"mat3x4f\" || mt === \"mat3x4h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat4x2\" || mt === \"mat4x2f\" || mt === \"mat4x2h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat4x3\" || mt === \"mat4x3f\" || mt === \"mat4x3h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            } else if (mt === \"mat4x4\" || mt === \"mat4x4f\" || mt === \"mat4x4h\") {\r\n                console.error(`TODO: Determinant for ${mt}`);\r\n            }\r\n        }\r\n        console.error(`Determinant expects a matrix argument. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Distance(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            let sum = 0;\r\n            for (let i = 0; i < l.data.length; ++i) {\r\n                sum += (l.data[i] - r.data[i]) * (l.data[i] - r.data[i]);\r\n            }\r\n            return new ScalarData(Math.sqrt(sum), this.getTypeInfo(\"f32\"));\r\n        }\r\n        const ls = l as ScalarData;\r\n        const rs = r as ScalarData;\r\n        return new ScalarData(Math.abs(ls.value - rs.value), l.typeInfo);\r\n    }\r\n\r\n    _dot(e1: Int32Array | Uint32Array | Float32Array, e2: Int32Array | Uint32Array | Float32Array) {\r\n        let dot = 0;\r\n        for (let i = 0; i < e1.length; ++i) {\r\n            dot += e2[i] * e1[i];\r\n        }\r\n        return dot;\r\n    }\r\n\r\n    Dot(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            return new ScalarData(this._dot(l.data, r.data), this.getTypeInfo(\"f32\"));\r\n        }\r\n        console.error(`Dot() expects vector arguments. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Dot4U8Packed(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: dot4U8Packed. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Dot4I8Packed(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: dot4I8Packed. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Exp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.exp(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.exp(s.value), value.typeInfo);\r\n    }\r\n\r\n    Exp2(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.pow(2, v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.pow(2, s.value), value.typeInfo);\r\n    }\r\n\r\n    ExtractBits(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        const offset = this.exec.evalExpression(node.args[1], context);\r\n        const count = this.exec.evalExpression(node.args[2], context);\r\n        if (offset.typeInfo.name !== \"u32\" && offset.typeInfo.name !== \"x32\") {\r\n            console.error(`ExtractBits() expects an i32 offset argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n        if (count.typeInfo.name !== \"u32\" && count.typeInfo.name !== \"x32\") {\r\n            console.error(`ExtractBits() expects an i32 count argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const o = (offset as ScalarData).value;\r\n        const c = (count as ScalarData).value;\r\n\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => (v >> o) & ((1 << c) - 1)), value.typeInfo);\r\n        }\r\n\r\n        if (value.typeInfo.name !== \"i32\" && value.typeInfo.name !== \"x32\") {\r\n            console.error(`ExtractBits() expects an i32 argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n        const v = (value as ScalarData).value;\r\n        return new ScalarData((v >> o) & ((1 << c) - 1), this.getTypeInfo(\"i32\"));\r\n    }\r\n\r\n    FaceForward(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const e1 = this.exec.evalExpression(node.args[0], context);\r\n        const e2 = this.exec.evalExpression(node.args[1], context);\r\n        const n = this.exec.evalExpression(node.args[2], context);\r\n        if (e1 instanceof VectorData && e2 instanceof VectorData && n instanceof VectorData) {\r\n            const dot = this._dot(e2.data, n.data);\r\n            if (dot < 0) {\r\n                return new VectorData(Array.from(e1.data), e1.typeInfo);\r\n            }\r\n            return new VectorData(e1.data.map((v: number) => -v), e1.typeInfo);\r\n        }\r\n        console.error(`FaceForward() expects vector arguments. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _firstLeadingBit(s: number): number {\r\n        if (s === 0) {\r\n            return -1;\r\n        }\r\n        return 31 - Math.clz32(s);  // clz32: count leading zeros\r\n    }\r\n\r\n    FirstLeadingBit(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => this._firstLeadingBit(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(this._firstLeadingBit(s.value), value.typeInfo);\r\n    }\r\n\r\n    _firstTrailingBit(s: number): number {\r\n        if (s === 0) {\r\n            return -1;\r\n        }\r\n        return Math.log2(s & -s); // n & -n isolates the lowest set bit.  Math.log2 gives its position.\r\n    }\r\n\r\n    FirstTrailingBit(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => this._firstTrailingBit(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(this._firstTrailingBit(s.value), value.typeInfo);\r\n    }\r\n\r\n    Floor(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.floor(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.floor(s.value), value.typeInfo);\r\n    }\r\n\r\n    Fma(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const a = this.exec.evalExpression(node.args[0], context);\r\n        const b = this.exec.evalExpression(node.args[1], context);\r\n        const c = this.exec.evalExpression(node.args[2], context);\r\n        if (a instanceof VectorData && b instanceof VectorData && c instanceof VectorData) {\r\n            if (a.data.length !== b.data.length || a.data.length !== c.data.length) {\r\n                console.error(`Fma() expects vectors of the same length. Line ${node.line}`);\r\n                return null;\r\n            }\r\n            return new VectorData(a.data.map((v: number, i: number) => v * b.data[i] + c.data[i]), a.typeInfo);\r\n        }\r\n        const av = a as ScalarData;\r\n        const bv = b as ScalarData;\r\n        const cv = c as ScalarData;\r\n        return new ScalarData(av.value * bv.value + cv.value, av.typeInfo);\r\n    }\r\n\r\n    Fract(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => v - Math.floor(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(s.value - Math.floor(s.value), value.typeInfo);\r\n    }\r\n\r\n    Frexp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: frexp. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    InsertBits(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        const insert = this.exec.evalExpression(node.args[1], context);\r\n        const offset = this.exec.evalExpression(node.args[2], context);\r\n        const count = this.exec.evalExpression(node.args[3], context);\r\n\r\n        if (offset.typeInfo.name !== \"u32\" && offset.typeInfo.name !== \"x32\") {\r\n            console.error(`InsertBits() expects an i32 offset argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const o = (offset as ScalarData).value;\r\n        const c = (count as ScalarData).value;\r\n        const mask = ((1 << c) - 1) << o;\r\n        const invMask = ~mask;\r\n\r\n        if (value instanceof VectorData && insert instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number, i: number) => {\r\n                return (v & invMask) | ((insert.data[i] << o) & mask);\r\n            }), value.typeInfo);\r\n        }\r\n        const v = (value as ScalarData).value;\r\n        const i = (insert as ScalarData).value;\r\n        return new ScalarData((v & invMask) | ((i << o) & mask), value.typeInfo);\r\n    }\r\n\r\n    InverseSqrt(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => 1 / Math.sqrt(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(1 / Math.sqrt(s.value), value.typeInfo);\r\n    }\r\n\r\n    Ldexp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: ldexp. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Length(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            let sum = 0;\r\n            value.data.forEach((v: number) => { sum += v * v; });\r\n            return new ScalarData(Math.sqrt(sum), this.getTypeInfo(\"f32\"));\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.abs(s.value), value.typeInfo);\r\n    }\r\n\r\n    Log(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.log(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.log(s.value), value.typeInfo);\r\n    }\r\n\r\n    Log2(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.log2(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData\r\n        return new ScalarData(Math.log2(s.value), value.typeInfo);\r\n    }\r\n\r\n    Max(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            return new VectorData(l.data.map((v: number, i: number) => Math.max(v, r.data[i])), l.typeInfo);\r\n        }\r\n        const ls = l as ScalarData;\r\n        const rs = r as ScalarData;\r\n        return new ScalarData(Math.max(ls.value, rs.value), l.typeInfo);\r\n    }\r\n\r\n    Min(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const l = this.exec.evalExpression(node.args[0], context);\r\n        const r = this.exec.evalExpression(node.args[1], context);\r\n        if (l instanceof VectorData && r instanceof VectorData) {\r\n            return new VectorData(l.data.map((v: number, i: number) => Math.min(v, r.data[i])), l.typeInfo);\r\n        }\r\n        const ls = l as ScalarData;\r\n        const rs = r as ScalarData;\r\n        return new ScalarData(Math.min(ls.value, rs.value), l.typeInfo);\r\n    }\r\n\r\n    Mix(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const x = this.exec.evalExpression(node.args[0], context);\r\n        const y = this.exec.evalExpression(node.args[1], context);\r\n        const a = this.exec.evalExpression(node.args[2], context);\r\n        if (x instanceof VectorData && y instanceof VectorData && a instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => x.data[i] * (1 - a.data[i]) + y.data[i] * a.data[i]), x.typeInfo);\r\n        }\r\n        const xs = x as ScalarData;\r\n        const ys = y as ScalarData;\r\n        const as = a as ScalarData;\r\n        return new ScalarData(xs.value * (1 - as.value) + ys.value * as.value, x.typeInfo);\r\n    }\r\n\r\n    Modf(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const x = this.exec.evalExpression(node.args[0], context);\r\n        const y = this.exec.evalExpression(node.args[1], context);\r\n        if (x instanceof VectorData && y instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => v % y.data[i]), x.typeInfo);\r\n        }\r\n        const xs = x as ScalarData;\r\n        const ys = y as ScalarData;\r\n        return new ScalarData(xs.value % ys.value, x.typeInfo);\r\n    }\r\n\r\n    Normalize(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            const length = (this.Length(node, context) as ScalarData).value;\r\n            return new VectorData(value.data.map((v: number) => v / length), value.typeInfo);\r\n        }\r\n        console.error(`Normalize() expects a vector argument. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Pow(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const x = this.exec.evalExpression(node.args[0], context);\r\n        const y = this.exec.evalExpression(node.args[1], context);\r\n        if (x instanceof VectorData && y instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => Math.pow(v, y.data[i])), x.typeInfo);\r\n        }\r\n        const xs = x as ScalarData;\r\n        const ys = y as ScalarData;\r\n        return new ScalarData(Math.pow(xs.value, ys.value), x.typeInfo);\r\n    }\r\n\r\n    QuantizeToF16(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // TODO: actually quantize the f32 to f16\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => v), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(s.value, value.typeInfo);\r\n    }\r\n\r\n    Radians(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => v * Math.PI / 180), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(s.value * Math.PI / 180, this.getTypeInfo(\"f32\"));\r\n    }\r\n\r\n    Reflect(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // e1 - 2 * dot(e2, e1) * e2\r\n        let e1 = this.exec.evalExpression(node.args[0], context);\r\n        let e2 = this.exec.evalExpression(node.args[1], context);\r\n        if (e1 instanceof VectorData && e2 instanceof VectorData) {\r\n            const dot = this._dot(e1.data, e2.data);\r\n            return new VectorData(e1.data.map((v: number, i: number) => v - 2 * dot * e2.data[i]), e1.typeInfo);\r\n        }\r\n        console.error(`Reflect() expects vector arguments. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Refract(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let e1 = this.exec.evalExpression(node.args[0], context);\r\n        let e2 = this.exec.evalExpression(node.args[1], context);\r\n        let e3 = this.exec.evalExpression(node.args[2], context);\r\n        if (e1 instanceof VectorData && e2 instanceof VectorData && e3 instanceof ScalarData) {\r\n            const dot = this._dot(e2.data, e1.data);\r\n            return new VectorData(e1.data.map((v: number, i: number) => {\r\n                const k = 1.0 - e3.value * e3.value * (1.0 - dot * dot);\r\n                if (k < 0) {\r\n                    return 0;\r\n                }\r\n                const sqrtK = Math.sqrt(k);\r\n                return e3.value * v - (e3.value * dot + sqrtK) * e2.data[i];\r\n            }), e1.typeInfo);\r\n        }\r\n\r\n        console.error(`Refract() expects vector arguments and a scalar argument. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    ReverseBits(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: reverseBits. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    Round(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.round(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.round(s.value), value.typeInfo);\r\n    }\r\n\r\n    Saturate(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.min(Math.max(v, 0), 1)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.min(Math.max(s.value, 0), 1), value.typeInfo);\r\n    }\r\n\r\n    Sign(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.sign(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.sign(s.value), value.typeInfo);\r\n    }\r\n\r\n    Sin(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.sin(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.sin(s.value), value.typeInfo);\r\n    }\r\n\r\n    Sinh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.sinh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.sinh(s.value), value.typeInfo);\r\n    }\r\n\r\n    _smoothstep(edge0: number, edge1: number, x: number): number {\r\n        const t = Math.min(Math.max((x - edge0) / (edge1 - edge0), 0), 1);\r\n        return t * t * (3 - 2 * t);\r\n    }\r\n\r\n    SmoothStep(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const edge0 = this.exec.evalExpression(node.args[0], context);\r\n        const edge1 = this.exec.evalExpression(node.args[1], context);\r\n        const x = this.exec.evalExpression(node.args[2], context);\r\n        if (x instanceof VectorData && edge0 instanceof VectorData && edge1 instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => this._smoothstep(edge0.data[i], edge1.data[i], v)), x.typeInfo);\r\n        }\r\n        const e0 = edge0 as ScalarData;\r\n        const e1 = edge1 as ScalarData;\r\n        const xS = x as ScalarData;\r\n        return new ScalarData(this._smoothstep(e0.value, e1.value, xS.value), x.typeInfo);\r\n    }\r\n\r\n    Sqrt(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.sqrt(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.sqrt(s.value), value.typeInfo);\r\n    }\r\n\r\n    Step(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const edge = this.exec.evalExpression(node.args[0], context);\r\n        const x = this.exec.evalExpression(node.args[1], context);\r\n        if (x instanceof VectorData && edge instanceof VectorData) {\r\n            return new VectorData(x.data.map((v: number, i: number) => v < edge.data[i] ? 0 : 1), x.typeInfo);\r\n        }\r\n        const e = edge as ScalarData;\r\n        const s = x as ScalarData;\r\n        return new ScalarData(s.value < e.value ? 0 : 1, e.typeInfo);\r\n    }\r\n\r\n    Tan(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.tan(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.tan(s.value), value.typeInfo);\r\n    }\r\n\r\n    Tanh(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.tanh(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData;\r\n        return new ScalarData(Math.tanh(s.value), value.typeInfo);\r\n    }\r\n\r\n    _getTransposeType(t: TypeInfo): TypeInfo {\r\n        const tname = t.getTypeName();\r\n        if (tname === \"mat2x2f\" || tname === \"mat2x2h\") {\r\n            return t;\r\n        } else if (tname === \"mat2x3f\") {\r\n            return this.getTypeInfo(\"mat3x2f\");\r\n        } else if (tname === \"mat2x3h\") {\r\n            return this.getTypeInfo(\"mat3x2h\");\r\n        } else if (tname === \"mat2x4f\") {\r\n            return this.getTypeInfo(\"mat4x2f\");\r\n        } else if (tname === \"mat2x4h\") {\r\n            return this.getTypeInfo(\"mat4x2h\");\r\n        } else if (tname === \"mat3x2f\") {\r\n            return this.getTypeInfo(\"mat2x3f\");\r\n        } else if (tname === \"mat3x2h\") {\r\n            return this.getTypeInfo(\"mat2x3h\");\r\n        } else if (tname === \"mat3x3f\" || tname === \"mat3x3h\") {\r\n            return t;\r\n        } else if (tname === \"mat3x4f\") {\r\n            return this.getTypeInfo(\"mat4x3f\");\r\n        } else if (tname === \"mat3x4h\") {\r\n            return this.getTypeInfo(\"mat4x3h\");\r\n        } else if (tname === \"mat4x2f\") {\r\n            return this.getTypeInfo(\"mat2x4f\");\r\n        } else if (tname === \"mat4x2h\") {\r\n            return this.getTypeInfo(\"mat2x4h\");\r\n        } else if (tname === \"mat4x3f\") {\r\n            return this.getTypeInfo(\"mat3x4f\");\r\n        } else if (tname === \"mat4x3h\") {\r\n            return this.getTypeInfo(\"mat3x4h\");\r\n        } else if (tname === \"mat4x4f\" || tname === \"mat4x4h\") {\r\n            return t;\r\n        }\r\n\r\n        console.error(`Invalid matrix type ${tname}`);\r\n        return t;\r\n    }\r\n\r\n    Transpose(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const m = this.exec.evalExpression(node.args[0], context);\r\n        if (!(m instanceof MatrixData)) {\r\n            console.error(`Transpose() expects a matrix argument. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const ttype = this._getTransposeType(m.typeInfo);\r\n\r\n        if (m.typeInfo.name === \"mat2x2\" || m.typeInfo.name === \"mat2x2f\" || m.typeInfo.name === \"mat2x2h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[2], mv[1], mv[3]], ttype);\r\n        } else if (m.typeInfo.name === \"mat2x3\" || m.typeInfo.name === \"mat2x3f\" || m.typeInfo.name === \"mat2x3h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[3], mv[6], mv[1], mv[4], mv[7]], ttype);\r\n        } else if (m.typeInfo.name === \"mat2x4\" || m.typeInfo.name === \"mat2x4f\" || m.typeInfo.name === \"mat2x4h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[8], mv[12], mv[1], mv[5], mv[9], mv[13]], ttype);\r\n        } else if (m.typeInfo.name === \"mat3x2\" || m.typeInfo.name === \"mat3x2f\" || m.typeInfo.name === \"mat3x2h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[3], mv[1], mv[4], mv[2], mv[5]], ttype);\r\n        } else if (m.typeInfo.name === \"mat3x3\" || m.typeInfo.name === \"mat3x3f\" || m.typeInfo.name === \"mat3x3h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[3], mv[6], mv[1], mv[4], mv[7], mv[2], mv[5], mv[8]], ttype);\r\n        } else if (m.typeInfo.name === \"mat3x4\" || m.typeInfo.name === \"mat3x4f\" || m.typeInfo.name === \"mat3x4h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[8], mv[12], mv[1], mv[5], mv[9], mv[13], mv[2], mv[6], mv[10], mv[14]], ttype);\r\n        } else if (m.typeInfo.name === \"mat4x2\" || m.typeInfo.name === \"mat4x2f\" || m.typeInfo.name === \"mat4x2h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[1], mv[5], mv[2], mv[6]], ttype);\r\n        } else if (m.typeInfo.name === \"mat4x3\" || m.typeInfo.name === \"mat4x3f\" || m.typeInfo.name === \"mat4x3h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[8], mv[1], mv[5], mv[9], mv[2], mv[6], mv[10]], ttype);\r\n        } else if (m.typeInfo.name === \"mat4x4\" || m.typeInfo.name === \"mat4x4f\" || m.typeInfo.name === \"mat4x4h\") {\r\n            const mv = m.data;\r\n            return new MatrixData([mv[0], mv[4], mv[8], mv[12],\r\n                                   mv[1], mv[5], mv[9], mv[13],\r\n                                   mv[2], mv[6], mv[10], mv[14],\r\n                                   mv[3], mv[7], mv[11], mv[15]], ttype);\r\n        }\r\n\r\n        console.error(`Invalid matrix type ${m.typeInfo.name}`);\r\n        return null;\r\n    }\r\n\r\n    Trunc(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const value = this.exec.evalExpression(node.args[0], context);\r\n        if (value instanceof VectorData) {\r\n            return new VectorData(value.data.map((v: number) => Math.trunc(v)), value.typeInfo);\r\n        }\r\n        const s = value as ScalarData\r\n        return new ScalarData(Math.trunc(s.value), value.typeInfo);\r\n    }\r\n\r\n    // Derivative Built-in Functions\r\n    Dpdx(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: dpdx. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    DpdxCoarse(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(`TODO: dpdxCoarse. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    DpdxFine(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: dpdxFine\");\r\n        return null;\r\n    }\r\n\r\n    Dpdy(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: dpdy\");\r\n        return null;\r\n    }\r\n\r\n    DpdyCoarse(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: dpdyCoarse\");\r\n        return null;\r\n    }\r\n\r\n    DpdyFine(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: dpdyFine\");\r\n        return null;\r\n    }\r\n\r\n    Fwidth(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: fwidth\");\r\n        return null;\r\n    }\r\n\r\n    FwidthCoarse(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: fwidthCoarse\");\r\n        return null;\r\n    }\r\n\r\n    FwidthFine(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: fwidthFine\");\r\n        return null;\r\n    }\r\n\r\n    // Texture Built-in Functions\r\n    TextureDimensions(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        const level = node.args.length > 1 ? (this.exec.evalExpression(node.args[1], context) as ScalarData).value : 0;\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                if (level < 0 || level >= texture.mipLevelCount) {\r\n                    console.error(`Invalid mip level for textureDimensions. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                const textureSize = texture.getMipLevelSize(level);\r\n\r\n                const dimension = texture.dimension;\r\n\r\n                if (dimension === \"1d\") {\r\n                    return new ScalarData(textureSize[0], this.getTypeInfo(\"u32\"));\r\n                } else if (dimension === \"3d\") {\r\n                    return new VectorData(textureSize, this.getTypeInfo(\"vec3u\"));\r\n                } else if (dimension === \"2d\") {\r\n                    return new VectorData(textureSize.slice(0, 2), this.getTypeInfo(\"vec2u\"));\r\n                } else {\r\n                    console.error(`Invalid texture dimension ${dimension} not found. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n        console.error(`Invalid texture argument for textureDimensions. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureGather(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureGather\");\r\n        return null;\r\n    }\r\n\r\n    TextureGatherCompare(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureGatherCompare\");\r\n        return null;\r\n    }\r\n\r\n    TextureLoad(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // https://www.w3.org/TR/WGSL/#textureload\r\n        const textureArg = node.args[0];\r\n        const uv = this.exec.evalExpression(node.args[1], context);\r\n\r\n        // TODO: non-vec2 UVs, for non-2D textures\r\n        if (!(uv instanceof VectorData) || uv.data.length !== 2) {\r\n            console.error(`Invalid UV argument for textureLoad. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                let zVal = 0;\r\n                let mipLevel = 0;\r\n                if ([\"texture_storage_2d_array\", \"texture_2d_array\", \"texture_depth_2d_array\"].indexOf(texture.typeInfo.name) > -1) {\r\n                    zVal = (this.exec.evalExpression(node.args[2], context)as ScalarData).value;\r\n                }\r\n                if ([\"texture_1d\", \"texture_2d\", \"texture_depth_2d\", \"texture_3d\"].indexOf(texture.typeInfo.name) > -1) {\r\n                    mipLevel = (this.exec.evalExpression(node.args[2], context)as ScalarData).value;\r\n                }\r\n                if ([\"texture_2d_array\", \"texture_depth_2d_array\"].indexOf(texture.typeInfo.name) > -1) {\r\n                    mipLevel = (this.exec.evalExpression(node.args[3], context)as ScalarData).value;\r\n                }\r\n                const x = Math.floor(uv.data[0]);\r\n                const y = Math.floor(uv.data[1]);\r\n                const z = Math.floor(zVal);\r\n                const level = Math.floor(mipLevel)\r\n                if (x < 0 || x >= texture.width || y < 0 || y >= texture.height) {\r\n                    console.error(`Texture ${textureName} out of bounds. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                const texel = texture.getPixel(x, y, z, level);\r\n                if (texel === null) {\r\n                    console.error(`Invalid texture format for textureLoad. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                return new VectorData(texel, this.getTypeInfo(\"vec4f\"));\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        console.error(`Invalid texture argument for textureLoad. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureNumLayers(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                return new ScalarData(texture.depthOrArrayLayers, this.getTypeInfo(\"u32\"));\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n        console.error(`Invalid texture argument for textureNumLayers. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureNumLevels(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                return new ScalarData(texture.mipLevelCount, this.getTypeInfo(\"u32\"));\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n        console.error(`Invalid texture argument for textureNumLevels. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureNumSamples(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                return new ScalarData(texture.sampleCount, this.getTypeInfo(\"u32\"));\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n        console.error(`Invalid texture argument for textureNumSamples. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    TextureSample(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSample\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleBias(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleBias\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleCompare(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleCompare\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleCompareLevel(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleCompareLevel\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleGrad(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleGrad\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleLevel(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleLevel\");\r\n        return null;\r\n    }\r\n\r\n    TextureSampleBaseClampToEdge(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: textureSampleBaseClampToEdge\");\r\n        return null;\r\n    }\r\n\r\n    TextureStore(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        const textureArg = node.args[0];\r\n        const uv = this.exec.evalExpression(node.args[1], context);\r\n        const index = (node.args.length === 4) ? (this.exec.evalExpression(node.args[2], context) as ScalarData).value : 0;\r\n        const value = (node.args.length === 4) ? (this.exec.evalExpression(node.args[3], context) as VectorData).data :\r\n            (this.exec.evalExpression(node.args[2], context) as VectorData).data;\r\n\r\n        if (value.length !== 4) {\r\n            console.error(`Invalid value argument for textureStore. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        // TODO: non-vec2 UVs, for non-2D textures\r\n        if (!(uv instanceof VectorData) || uv.data.length !== 2) {\r\n            console.error(`Invalid UV argument for textureStore. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        if (textureArg instanceof VariableExpr) {\r\n            const textureName = (textureArg as VariableExpr).name;\r\n            const texture = context.getVariableValue(textureName);\r\n            if (texture instanceof TextureData) {\r\n                const textureSize = texture.getMipLevelSize(0);\r\n                const x = Math.floor(uv.data[0]);\r\n                const y = Math.floor(uv.data[1]);\r\n                if (x < 0 || x >= textureSize[0] || y < 0 || y >= textureSize[1]) {\r\n                    console.error(`Texture ${textureName} out of bounds. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                texture.setPixel(x, y, 0, index, Array.from(value));\r\n\r\n                return null;\r\n            } else {\r\n                console.error(`Texture ${textureName} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        console.error(`Invalid texture argument for textureStore. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    // Atomic Built-in Functions\r\n    AtomicLoad(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n        return currentValue;\r\n    }\r\n\r\n    AtomicStore(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    AtomicAdd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value += value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicSub(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value -= value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicMax(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = Math.max(currentValue.value, value.value);\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicMin(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = Math.min(currentValue.value, value.value);\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicAnd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = currentValue.value & value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicOr(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = currentValue.value | value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicXor(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = currentValue.value ^ value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicExchange(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        let l = node.args[0];\r\n        if (l instanceof UnaryOperator) {\r\n            l = l.right;\r\n        }\r\n\r\n        const name = this.exec.getVariableName(l, context);\r\n        const v = context.getVariable(name);\r\n\r\n        let r = node.args[1];\r\n        const value = this.exec.evalExpression(r, context);\r\n\r\n        const currentValue = v.value.getSubData(this.exec, l.postfix, context);\r\n\r\n        const originalValue = new ScalarData((currentValue as ScalarData).value, currentValue.typeInfo);\r\n\r\n        if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n            currentValue.value = value.value;\r\n        }\r\n\r\n        if (v.value instanceof TypedData) {\r\n            v.value.setDataValue(this.exec, currentValue, l.postfix, context);\r\n        }\r\n\r\n        return originalValue;\r\n    }\r\n\r\n    AtomicCompareExchangeWeak(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: atomicCompareExchangeWeak\");\r\n        return null;\r\n    }\r\n\r\n    // Data Packing Built-in Functions\r\n    Pack4x8snorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4x8snorm\");\r\n        return null;\r\n    }\r\n\r\n    Pack4x8unorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4x8unorm\");\r\n        return null;\r\n    }\r\n\r\n    Pack4xI8(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4xI8\");\r\n        return null;\r\n    }\r\n\r\n    Pack4xU8(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4xU8\");\r\n        return null;\r\n    }\r\n\r\n    Pack4x8Clamp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4x8Clamp\");\r\n        return null;\r\n    }\r\n\r\n    Pack4xU8Clamp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack4xU8Clamp\");\r\n        return null;\r\n    }\r\n\r\n    Pack2x16snorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack2x16snorm\");\r\n        return null;\r\n    }\r\n\r\n    Pack2x16unorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack2x16unorm\");\r\n        return null;\r\n    }\r\n\r\n    Pack2x16float(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: pack2x16float\");\r\n        return null;\r\n    }\r\n\r\n    // Data Unpacking Built-in Functions\r\n    Unpack4x8snorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack4x8snorm\");\r\n        return null;\r\n    }\r\n\r\n    Unpack4x8unorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack4x8unorm\");\r\n        return null;\r\n    }\r\n\r\n    Unpack4xI8(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack4xI8\");\r\n        return null;\r\n    }\r\n\r\n    Unpack4xU8(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack4xU8\");\r\n        return null;\r\n    }\r\n\r\n    Unpack2x16snorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack2x16snorm\");\r\n        return null;\r\n    }\r\n\r\n    Unpack2x16unorm(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack2x16unorm\");\r\n        return null;\r\n    }\r\n\r\n    Unpack2x16float(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: unpack2x16float\");\r\n        return null;\r\n    }\r\n\r\n    // Synchronization Functions\r\n    StorageBarrier(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // Execution is single threaded, barriers not necessary.\r\n        return null;\r\n    }\r\n\r\n    TextureBarrier(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // Execution is single threaded, barriers not necessary.\r\n        return null;\r\n    }\r\n\r\n    WorkgroupBarrier(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // Execution is single threaded, barriers not necessary.\r\n        return null;\r\n    }\r\n\r\n    WorkgroupUniformLoad(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        // Execution is single threaded, barriers not necessary.\r\n        return null;\r\n    }\r\n\r\n    // Subgroup Functions\r\n    SubgroupAdd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupAdd\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupExclusiveAdd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupExclusiveAdd\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupInclusiveAdd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupInclusiveAdd\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupAll(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupAll\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupAnd(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupAnd\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupAny(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupAny\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupBallot(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupBallot\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupBroadcast(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupBroadcast\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupBroadcastFirst(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupBroadcastFirst\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupElect(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupElect\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupMax(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupMax\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupMin(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupMin\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupMul(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupMul\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupExclusiveMul(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupExclusiveMul\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupInclusiveMul(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupInclusiveMul\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupOr(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupOr\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupShuffle(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupShuffle\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupShuffleDown(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupShuffleDown\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupShuffleUp(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupShuffleUp\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupShuffleXor(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupShuffleXor\");\r\n        return null;\r\n    }\r\n\r\n    SubgroupXor(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: subgroupXor\");\r\n        return null;\r\n    }\r\n\r\n    // Quad Functions\r\n    QuadBroadcast(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: quadBroadcast\");\r\n        return null;\r\n    }\r\n\r\n    QuadSwapDiagonal(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: quadSwapDiagonal\");\r\n        return null;\r\n    }\r\n\r\n    QuadSwapX(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: quadSwapX\");\r\n        return null;\r\n    }\r\n\r\n    QuadSwapY(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        console.error(\"TODO: quadSwapY\");\r\n        return null;\r\n    }\r\n}\r\n","import { TypeInfo } from '../reflect/info';\r\n\r\nexport const VectorTypeSize = {\r\n    \"vec2\": 2, \"vec2f\": 2, \"vec2i\": 2, \"vec2u\": 2, \"vec2b\": 2, \"vec2h\": 2,\r\n    \"vec3\": 3, \"vec3f\": 3, \"vec3i\": 3, \"vec3u\": 3, \"vec3b\": 3, \"vec3h\": 3,\r\n    \"vec4\": 4, \"vec4f\": 4, \"vec4i\": 4, \"vec4u\": 4, \"vec4b\": 4, \"vec4h\": 4\r\n};\r\n\r\nexport const MatrixTypeSize = {\r\n    \"mat2x2\": [2, 2, 4], \"mat2x2f\": [2, 2, 4], \"mat2x2h\": [2, 2, 4],\r\n    \"mat2x3\": [2, 3, 6], \"mat2x3f\": [2, 3, 6], \"mat2x3h\": [2, 3, 6],\r\n    \"mat2x4\": [2, 4, 8], \"mat2x4f\": [2, 4, 8], \"mat2x4h\": [2, 4, 8],\r\n    \"mat3x2\": [3, 2, 6], \"mat3x2f\": [3, 2, 6], \"mat3x2h\": [3, 2, 6],\r\n    \"mat3x3\": [3, 3, 9], \"mat3x3f\": [3, 3, 9], \"mat3x3h\": [3, 3, 9],\r\n    \"mat3x4\": [3, 4, 12], \"mat3x4f\": [3, 4, 12], \"mat3x4h\": [3, 4, 12],\r\n    \"mat4x2\": [4, 2, 8], \"mat4x2f\": [4, 2, 8], \"mat4x2h\": [4, 2, 8],\r\n    \"mat4x3\": [4, 3, 12], \"mat4x3f\": [4, 3, 12], \"mat4x3h\": [4, 3, 12],\r\n    \"mat4x4\": [4, 4, 16], \"mat4x4f\": [4, 4, 16], \"mat4x4h\": [4, 4, 16]\r\n};\r\n\r\nexport const MatrixTransposeType = {\r\n    \"mat2x2\": \"mat2x2\", \"mat2x2f\": \"mat2x2f\", \"mat2x2h\": \"mat2x2h\",\r\n    \"mat2x3\": \"mat3x2\", \"mat2x3f\": \"mat3x2f\", \"mat2x3h\": \"mat3x2h\",\r\n    \"mat2x4\": \"mat4x2\", \"mat2x4f\": \"mat4x2f\", \"mat2x4h\": \"mat4x2h\",\r\n    \"mat3x2\": \"mat2x3\", \"mat3x2f\": \"mat2x3f\", \"mat3x2h\": \"mat2x3h\",\r\n    \"mat3x3\": \"mat3x3\", \"mat3x3f\": \"mat3x3f\", \"mat3x3h\": \"mat3x3h\",\r\n    \"mat3x4\": \"mat4x3\", \"mat3x4f\": \"mat4x3f\", \"mat3x4h\": \"mat4x3h\",\r\n    \"mat4x2\": \"mat2x4\", \"mat4x2f\": \"mat2x4f\", \"mat4x2h\": \"mat2x4h\",\r\n    \"mat4x3\": \"mat4x3\", \"mat4x3f\": \"mat4x3f\", \"mat4x3h\": \"mat4x3h\",\r\n    \"mat4x4\": \"mat4x4\", \"mat4x4f\": \"mat4x4f\", \"mat4x4h\": \"mat4x4h\"\r\n};\r\n\r\nexport function matrixTranspose(matrix: number[], t: TypeInfo) {\r\n    if (MatrixTypeSize[t.name] === undefined) {\r\n        return null;\r\n    }\r\n\r\n    const cols = MatrixTypeSize[t.name][0];\r\n    const rows = MatrixTypeSize[t.name][1];\r\n    const result: number[] = [];\r\n\r\n    for (let i = 0; i < cols; i++) {\r\n        for (let j = 0; j < rows; j++) {\r\n            result[i * rows + j] = matrix[j * cols + i];\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport function matrixMultiply(matrixA: number[], t1: TypeInfo, matrixB: number[], t2: TypeInfo): number[] | null {\r\n  if (MatrixTypeSize[t1.name] === undefined || MatrixTypeSize[t2.name] === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const k = MatrixTypeSize[t1.name][0];\r\n  const r = MatrixTypeSize[t1.name][1];\r\n  const c = MatrixTypeSize[t2.name][0];\r\n  const k2 = MatrixTypeSize[t2.name][1];\r\n\r\n  if (k !== k2) {\r\n    return null;\r\n  }\r\n\r\n  const result: number[] = new Array(c * r);\r\n\r\n  for (let j = 0; j < r; j++) { // Iterate through columns of result\r\n    for (let i = 0; i < c; i++) { // Iterate through rows of result\r\n      let sum = 0;\r\n      for (let l = 0; l < k; l++) {\r\n        sum += matrixA[l * r + j] * matrixB[i * k + l]; // Access column-major elements\r\n      }\r\n      result[j * c + i] = sum; // Store in column-major order\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function matrixVectorMultiply(matrix: number[], t1: TypeInfo, vector: number[], t2: TypeInfo): number[] | null {\r\n  if (MatrixTypeSize[t1.name] === undefined || VectorTypeSize[t2.name] === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const cols = MatrixTypeSize[t1.name][0];\r\n  const rows = MatrixTypeSize[t1.name][1];\r\n  \r\n  if (cols !== vector.length) {\r\n    return null;\r\n  }\r\n\r\n  const resultVec = new Array(rows);\r\n  // Perform matrix-vector multiplication (column-major)\r\n  for (let i = 0; i < rows; i++) {\r\n    let sum = 0;\r\n    for (let j = 0; j < cols; j++) {\r\n      sum += matrix[j * rows + i] * vector[j]; // Access column-major element\r\n    }\r\n    resultVec[i] = sum;\r\n  }\r\n\r\n  return resultVec;\r\n}\r\n\r\nexport function vectorMatrixMultiply(vector: number[], t1: TypeInfo, matrix: number[], t2: TypeInfo): number[] | null {\r\n  if (VectorTypeSize[t1.name] === undefined || MatrixTypeSize[t2.name] === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const cols = MatrixTypeSize[t2.name][0];\r\n  const rows = MatrixTypeSize[t2.name][1];\r\n\r\n  if (rows !== vector.length) {\r\n    return null;\r\n  }\r\n\r\n  const result: number[] = [];\r\n  for (let j = 0; j < cols; j++) {\r\n    let sum = 0;\r\n    for (let i = 0; i < rows; i++) {\r\n      sum += vector[i] * matrix[i * cols + j];\r\n    }\r\n    result[j] = sum;\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { Node, Type, TemplateType, Return, Break, Continue, Let, Var, Const,\r\n    If, For, While, Loop, Continuing, Assign, Increment, Struct, Override, ArrayType,\r\n    Call, Diagnostic, Alias, BinaryOperator, LiteralExpr, Expression,\r\n    VariableExpr, CallExpr, CreateExpr, ConstExpr, BitcastExpr, UnaryOperator,\r\n    ArrayIndex, StringExpr, Function, Switch, SwitchCase, Case, Default, DefaultSelector } from \"./wgsl_ast.js\";\r\nimport { Data, TypedData, TextureData, ScalarData, VectorData, MatrixData, PointerData, VoidData } from \"./wgsl_ast.js\";\r\nimport { Reflect } from \"./reflect/reflect.js\";\r\nimport { TypeInfo, StructInfo, ArrayInfo, TemplateInfo } from \"./reflect/info.js\";\r\nimport { ExecContext, FunctionRef } from \"./exec/exec_context.js\";\r\nimport { ExecInterface } from \"./exec/exec_interface.js\";\r\nimport { BuiltinFunctions } from \"./exec/builtin_functions.js\";\r\nimport { isArray, castScalar, castVector } from \"./utils/cast.js\";\r\nimport { matrixMultiply, matrixVectorMultiply, vectorMatrixMultiply, MatrixTypeSize, VectorTypeSize } from \"./utils/matrix.js\";\r\n\r\nexport class WgslExec extends ExecInterface {\r\n    ast: Node[];\r\n    context: ExecContext;\r\n    reflection: Reflect;\r\n    builtins: BuiltinFunctions;\r\n    typeInfo: Object;\r\n\r\n    constructor(ast?: Node[], context?: ExecContext) {\r\n        super();\r\n        this.ast = ast ?? [];\r\n        this.reflection = new Reflect();\r\n        this.reflection.updateAST(this.ast);\r\n\r\n        this.context = context?.clone() ?? new ExecContext();\r\n        this.builtins = new BuiltinFunctions(this);\r\n\r\n        this.typeInfo = {\r\n            \"bool\": this.getTypeInfo(Type.bool),\r\n            \"i32\": this.getTypeInfo(Type.i32),\r\n            \"u32\": this.getTypeInfo(Type.u32),\r\n            \"f32\": this.getTypeInfo(Type.f32),\r\n            \"f16\": this.getTypeInfo(Type.f16),\r\n            \"vec2f\": this.getTypeInfo(TemplateType.vec2f),\r\n            \"vec2u\": this.getTypeInfo(TemplateType.vec2u),\r\n            \"vec2i\": this.getTypeInfo(TemplateType.vec2i),\r\n            \"vec2h\": this.getTypeInfo(TemplateType.vec2h),\r\n            \"vec3f\": this.getTypeInfo(TemplateType.vec3f),\r\n            \"vec3u\": this.getTypeInfo(TemplateType.vec3u),\r\n            \"vec3i\": this.getTypeInfo(TemplateType.vec3i),\r\n            \"vec3h\": this.getTypeInfo(TemplateType.vec3h),\r\n            \"vec4f\": this.getTypeInfo(TemplateType.vec4f),\r\n            \"vec4u\": this.getTypeInfo(TemplateType.vec4u),\r\n            \"vec4i\": this.getTypeInfo(TemplateType.vec4i),\r\n            \"vec4h\": this.getTypeInfo(TemplateType.vec4h),\r\n            \"mat2x2f\": this.getTypeInfo(TemplateType.mat2x2f),\r\n            \"mat2x3f\": this.getTypeInfo(TemplateType.mat2x3f),\r\n            \"mat2x4f\": this.getTypeInfo(TemplateType.mat2x4f),\r\n            \"mat3x2f\": this.getTypeInfo(TemplateType.mat3x2f),\r\n            \"mat3x3f\": this.getTypeInfo(TemplateType.mat3x3f),\r\n            \"mat3x4f\": this.getTypeInfo(TemplateType.mat3x4f),\r\n            \"mat4x2f\": this.getTypeInfo(TemplateType.mat4x2f),\r\n            \"mat4x3f\": this.getTypeInfo(TemplateType.mat4x3f),\r\n            \"mat4x4f\": this.getTypeInfo(TemplateType.mat4x4f),\r\n        };\r\n    }\r\n\r\n    getVariableValue(name: string): number | number[] | null {\r\n        const v = this.context.getVariable(name)?.value ?? null;\r\n        if (v === null) {\r\n            return null;\r\n        }\r\n        if (v instanceof ScalarData) {\r\n            return v.value;\r\n        }\r\n        if (v instanceof VectorData) {\r\n            return Array.from(v.data);\r\n        }\r\n        if (v instanceof MatrixData) {\r\n            return Array.from(v.data);\r\n        }\r\n        if (v instanceof TypedData) {\r\n            if (v.typeInfo instanceof ArrayInfo) {\r\n                if (v.typeInfo.format.name === \"u32\") {\r\n                    return Array.from(new Uint32Array(v.buffer, v.offset, v.typeInfo.count));\r\n                } else if (v.typeInfo.format.name === \"i32\") {\r\n                    return Array.from(new Int32Array(v.buffer, v.offset, v.typeInfo.count));\r\n                } else if (v.typeInfo.format.name === \"f32\") {\r\n                    return Array.from(new Float32Array(v.buffer, v.offset, v.typeInfo.count));\r\n                }\r\n            }\r\n        }\r\n        console.error(`Unsupported return variable type ${v.typeInfo.name}`);\r\n        return null;\r\n    }\r\n\r\n    execute(config?: Object): void {\r\n        config = config ?? {};\r\n        if (config[\"constants\"]) {\r\n            this._setOverrides(config[\"constants\"], this.context);\r\n        }\r\n\r\n        this._execStatements(this.ast, this.context);\r\n    }\r\n\r\n    dispatchWorkgroups(kernel: string, dispatchCount: number | number[], bindGroups: Object, config?: Object): void {\r\n        const context = this.context.clone();\r\n\r\n        config = config ?? {};\r\n        if (config[\"constants\"]) {\r\n            this._setOverrides(config[\"constants\"], context);\r\n        }\r\n\r\n        this._execStatements(this.ast, context);\r\n\r\n        const f = context.getFunction(kernel);\r\n        if (!f) {\r\n            console.error(`Function ${kernel} not found`);\r\n            return;\r\n        }\r\n\r\n        if (typeof dispatchCount === \"number\") {\r\n            dispatchCount = [dispatchCount, 1, 1];\r\n        } else if (dispatchCount.length === 0) {\r\n            console.error(`Invalid dispatch count`);\r\n            return;\r\n        } else if (dispatchCount.length === 1) {\r\n            dispatchCount = [dispatchCount[0], 1, 1];\r\n        } else if (dispatchCount.length === 2) {\r\n            dispatchCount = [dispatchCount[0], dispatchCount[1], 1];\r\n        } else if (dispatchCount.length > 3) {\r\n            dispatchCount = [dispatchCount[0], dispatchCount[1], dispatchCount[2]];\r\n        }\r\n\r\n        const width = dispatchCount[0];\r\n        const height = dispatchCount[1];\r\n        const depth = dispatchCount[2];\r\n\r\n        const vec3u = this.getTypeInfo(\"vec3u\");\r\n        context.setVariable(\"@num_workgroups\", new VectorData(dispatchCount, vec3u));\r\n\r\n        const kernelRefl = this.reflection.getFunctionInfo(kernel);\r\n        if (kernelRefl === null) {\r\n            console.error(`Function ${kernel} not found in reflection data`);\r\n        }\r\n\r\n        for (const set in bindGroups) {\r\n            for (const binding in bindGroups[set]) {\r\n                const entry = bindGroups[set][binding];\r\n\r\n                context.variables.forEach((v) => {\r\n                    const node = v.node;\r\n                    if (node?.attributes) {\r\n                        let b = null;\r\n                        let s = null;\r\n                        for (const attr of node.attributes) {\r\n                            if (attr.name === \"binding\") {\r\n                                b = attr.value;\r\n                            } else if (attr.name === \"group\") {\r\n                                s = attr.value;\r\n                            }\r\n                        }\r\n                        if (binding == b && set == s) {\r\n                            let found = false;\r\n                            for (const resource of kernelRefl.resources) {\r\n                                if (resource.name === v.name && resource.group === parseInt(set) && resource.binding === parseInt(binding)) {\r\n                                    found = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            if (found) {\r\n                                if (entry.texture !== undefined && entry.descriptor !== undefined) {\r\n                                    // Texture\r\n                                    const textureData = new TextureData(entry.texture, this.getTypeInfo(node.type), entry.descriptor,\r\n                                            entry.texture.view ?? null);\r\n                                    v.value = textureData;\r\n                                } else if (entry.uniform !== undefined) {\r\n                                    // Uniform buffer\r\n                                    v.value = new TypedData(entry.uniform, this.getTypeInfo(node.type));\r\n                                } else {\r\n                                    // Storage buffer\r\n                                    v.value = new TypedData(entry, this.getTypeInfo(node.type));\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        for (let z = 0; z < depth; ++z) {\r\n            for (let y = 0; y < height; ++y) {\r\n                for (let x = 0; x < width; ++x) {\r\n                    context.setVariable(\"@workgroup_id\", new VectorData([x, y, z], this.getTypeInfo(\"vec3u\")));\r\n                    this._dispatchWorkgroup(f, [x, y, z], context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    static _breakObj = new Data(new TypeInfo(\"BREAK\", null), null);\r\n    static _continueObj = new Data(new TypeInfo(\"CONTINUE\", null), null);\r\n\r\n    execStatement(stmt: Node, context: ExecContext): Data | null {\r\n        if (stmt instanceof Return) {\r\n            return this.evalExpression(stmt.value, context);\r\n        } else if (stmt instanceof Break) {\r\n            if (stmt.condition) {\r\n                const c = this.evalExpression(stmt.condition, context);\r\n                if (!(c instanceof ScalarData)) {\r\n                    throw new Error(`Invalid break-if condition`);\r\n                }\r\n                if (!c.value) {\r\n                    return null;\r\n                }\r\n            }\r\n            return WgslExec._breakObj;\r\n        } else if (stmt instanceof Continue) {\r\n            return WgslExec._continueObj;\r\n        } else if (stmt instanceof Let) {\r\n            this._let(stmt, context);\r\n        } else if (stmt instanceof Var) {\r\n            this._var(stmt, context);\r\n        } else if (stmt instanceof Const) {\r\n            this._const(stmt, context);\r\n        } else if (stmt instanceof Override) {\r\n            this._override(stmt, context);\r\n        } else if (stmt instanceof Function) {\r\n            this._function(stmt, context);\r\n        } else if (stmt instanceof If) {\r\n            return this._if(stmt, context);\r\n        } else if (stmt instanceof Switch) {\r\n            return this._switch(stmt, context);\r\n        } else if (stmt instanceof For) {\r\n            return this._for(stmt, context);\r\n        } else if (stmt instanceof While) {\r\n            return this._while(stmt, context);\r\n        } else if (stmt instanceof Loop) {\r\n            return this._loop(stmt, context);\r\n        } else if (stmt instanceof Continuing) {\r\n            const subContext = context.clone();\r\n            subContext.currentFunctionName = context.currentFunctionName;\r\n            return this._execStatements(stmt.body, subContext);\r\n        } else if (stmt instanceof Assign) {\r\n            this._assign(stmt, context);\r\n        } else if (stmt instanceof Increment) {\r\n            this._increment(stmt, context);\r\n        } else if (stmt instanceof Struct) {\r\n            return null;\r\n        } else if (stmt instanceof Override) {\r\n            const name = stmt.name;\r\n            if (context.getVariable(name) === null) {\r\n                context.setVariable(name, new ScalarData(0, this.getTypeInfo(\"u32\")));\r\n                //console.error(`Override constant ${name} not found. Line ${stmt.line}`);\r\n            }\r\n        } else if (stmt instanceof Call) {\r\n            this._call(stmt, context);\r\n        } else if (stmt instanceof Diagnostic) {\r\n            return null; // Nothing to do here.\r\n        } else if (stmt instanceof Alias) {\r\n            return null; // Nothing to do here.\r\n        } else {\r\n            console.error(`Invalid statement type.`, stmt, `Line ${stmt.line}`);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    evalExpression(node: Node, context: ExecContext): Data | null {\r\n        if (node instanceof BinaryOperator) {\r\n            return this._evalBinaryOp(node, context);\r\n        } else if (node instanceof LiteralExpr) {\r\n            return this._evalLiteral(node, context);\r\n        } else if (node instanceof VariableExpr) {\r\n            return this._evalVariable(node, context);\r\n        } else if (node instanceof CallExpr) {\r\n            return this._evalCall(node, context);\r\n        } else if (node instanceof CreateExpr) {\r\n            return this._evalCreate(node, context);\r\n        } else if (node instanceof ConstExpr) {\r\n            return this._evalConst(node, context);\r\n        } else if (node instanceof BitcastExpr) {\r\n            return this._evalBitcast(node, context);\r\n        } else if (node instanceof UnaryOperator) {\r\n            return this._evalUnaryOp(node, context);\r\n        }\r\n        console.error(`Invalid expression type`, node, `Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    getTypeInfo(type: Type | string): TypeInfo | null {\r\n        if (type instanceof Type) {\r\n            const t = this.reflection.getTypeInfo(type as Type);\r\n            if (t !== null) {\r\n                return t;\r\n            }\r\n        }\r\n\r\n        let t = this.typeInfo[type as string] ?? null;\r\n        if (t !== null) {\r\n            return t;\r\n        }\r\n\r\n        t = this.reflection.getTypeInfoByName(type as string);\r\n        return t;\r\n    }\r\n\r\n    _setOverrides(constants: Object, context: ExecContext): void {\r\n        for (const k in constants) {\r\n            const v = constants[k];\r\n            const override = this.reflection.getOverrideInfo(k);\r\n            if (override !== null) {\r\n                if (override.type === null) {\r\n                    override.type = this.getTypeInfo(\"u32\");\r\n                }\r\n                if (override.type.name === \"u32\" || override.type.name === \"i32\" || override.type.name === \"f32\" || override.type.name === \"f16\") {\r\n                    context.setVariable(k, new ScalarData(v, override.type));\r\n                } else if (override.type.name === \"bool\") {\r\n                    context.setVariable(k, new ScalarData(v ? 1 : 0, override.type));\r\n                } else if (override.type.name === \"vec2\" || override.type.name === \"vec3\" || override.type.name === \"vec4\" ||\r\n                    override.type.name === \"vec2f\" || override.type.name === \"vec3f\" || override.type.name === \"vec4f\" ||\r\n                    override.type.name === \"vec2i\" || override.type.name === \"vec3i\" || override.type.name === \"vec4i\" ||\r\n                    override.type.name === \"vec2u\" || override.type.name === \"vec3u\" || override.type.name === \"vec4u\" ||\r\n                    override.type.name === \"vec2h\" || override.type.name === \"vec3h\" || override.type.name === \"vec4h\") {\r\n                    context.setVariable(k, new VectorData(v, override.type));\r\n                } else {\r\n                    console.error(`Invalid constant type for ${k}`);\r\n                }\r\n            } else {\r\n                console.error(`Override ${k} does not exist in the shader.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    _dispatchWorkgroup(f: FunctionRef, workgroup_id: number[], context: ExecContext): void {\r\n        const workgroupSize = [1, 1, 1];\r\n        for (const attr of f.node.attributes) {\r\n            if (attr.name === \"workgroup_size\") {\r\n                if (attr.value.length > 0) {\r\n                    // The value could be an override constant\r\n                    const v = context.getVariableValue(attr.value[0]);\r\n                    if (v instanceof ScalarData) {\r\n                        workgroupSize[0] = v.value;\r\n                    } else {\r\n                        workgroupSize[0] = parseInt(attr.value[0]);\r\n                    }\r\n                }\r\n                if (attr.value.length > 1) {\r\n                    const v = context.getVariableValue(attr.value[1]);\r\n                    if (v instanceof ScalarData) {\r\n                        workgroupSize[1] = v.value;\r\n                    } else {\r\n                        workgroupSize[1] = parseInt(attr.value[1]);\r\n                    }\r\n                }\r\n                if (attr.value.length > 2) {\r\n                    const v = context.getVariableValue(attr.value[2]);\r\n                    if (v instanceof ScalarData) {\r\n                        workgroupSize[2] = v.value;\r\n                    } else {\r\n                        workgroupSize[2] = parseInt(attr.value[2]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const vec3u = this.getTypeInfo(\"vec3u\");\r\n        const u32 = this.getTypeInfo(\"u32\");\r\n        context.setVariable(\"@workgroup_size\", new VectorData(workgroupSize, vec3u));\r\n\r\n        const width = workgroupSize[0];\r\n        const height = workgroupSize[1];\r\n        const depth = workgroupSize[2];\r\n\r\n        for (let z = 0, li = 0; z < depth; ++z) {\r\n            for (let y = 0; y < height; ++y) {\r\n                for (let x = 0; x < width; ++x, ++li) {\r\n                    const local_invocation_id = [x, y, z];\r\n                    const global_invocation_id = [\r\n                        x + workgroup_id[0] * workgroupSize[0],\r\n                        y + workgroup_id[1] * workgroupSize[1],\r\n                        z + workgroup_id[2] * workgroupSize[2]];\r\n\r\n                    context.setVariable(\"@local_invocation_id\", new VectorData(local_invocation_id, vec3u));\r\n                    context.setVariable(\"@global_invocation_id\", new VectorData(global_invocation_id, vec3u));\r\n                    context.setVariable(\"@local_invocation_index\", new ScalarData(li, u32));\r\n\r\n                    this._dispatchExec(f, context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    _dispatchExec(f: FunctionRef, context: ExecContext): void {\r\n        // Update any built-in input args.\r\n        // TODO: handle input structs.\r\n        for (const arg of f.node.args) {\r\n            for (const attr of arg.attributes) {\r\n                if (attr.name === \"builtin\") {\r\n                    const globalName = `@${attr.value}`;\r\n                    const globalVar = context.getVariable(globalName);\r\n                    if (globalVar !== undefined) {\r\n                        context.variables.set(arg.name, globalVar);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._execStatements(f.node.body, context);\r\n    }\r\n\r\n    getVariableName(node: Node, context: ExecContext): string | null {\r\n        while (node instanceof UnaryOperator) {\r\n            node = node.right;\r\n        }\r\n\r\n        if (node instanceof VariableExpr) {\r\n            return (node as VariableExpr).name;\r\n        } else {\r\n            console.error(`Unknown variable type`, node, 'Line', node.line);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _execStatements(statements: Node[], context: ExecContext): Data | null {\r\n        for (const stmt of statements) {\r\n            // Block statements are declared as arrays of statements.\r\n            if (stmt instanceof Array) {\r\n                const subContext = context.clone();\r\n                const res = this._execStatements(stmt, subContext);\r\n                if (res) {\r\n                    return res;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const res = this.execStatement(stmt, context);\r\n            if (res) {\r\n                return res;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _call(node: Call, context: ExecContext): void {\r\n        const subContext = context.clone();\r\n        subContext.currentFunctionName = node.name;\r\n\r\n        const f = context.getFunction(node.name);\r\n        if (!f) {\r\n            if (node.isBuiltin) {\r\n                this._callBuiltinFunction(node, subContext);\r\n            } else {\r\n                const typeInfo = this.getTypeInfo(node.name);\r\n                if (typeInfo) {\r\n                    this._evalCreate(node, context);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        for (let ai = 0; ai < f.node.args.length; ++ai) {\r\n            const arg = f.node.args[ai];\r\n            const value = this.evalExpression(node.args[ai], subContext);\r\n            subContext.setVariable(arg.name, value, arg);\r\n        }\r\n\r\n        this._execStatements(f.node.body, subContext);\r\n    }\r\n\r\n    _increment(node: Increment, context: ExecContext): void {\r\n        const name = this.getVariableName(node.variable, context);\r\n        const v = context.getVariable(name);\r\n        if (!v) {\r\n            console.error(`Variable ${name} not found. Line ${node.line}`);\r\n            return;\r\n        }\r\n        if (node.operator === \"++\") {\r\n            if (v.value instanceof ScalarData) {\r\n                v.value.value++;\r\n            } else {\r\n                console.error(`Variable ${name} is not a scalar. Line ${node.line}`);\r\n            }\r\n        } else if (node.operator === \"--\") {\r\n            if (v.value instanceof ScalarData) {\r\n                v.value.value--;\r\n            } else {\r\n                console.error(`Variable ${name} is not a scalar. Line ${node.line}`);\r\n            }\r\n        } else {\r\n            console.error(`Unknown increment operator ${node.operator}. Line ${node.line}`);\r\n        }\r\n    }\r\n\r\n    _getVariableData(node: Node, context: ExecContext): Data | null {\r\n        if (node instanceof VariableExpr) {\r\n            const name = this.getVariableName(node, context);\r\n            const _var = context.getVariable(name);\r\n            if (_var === null) {\r\n                console.error(`Variable ${name} not found. Line ${node.line}`);\r\n                return null;\r\n            }\r\n            return _var.value.getSubData(this, node.postfix, context);\r\n        }\r\n\r\n        if (node instanceof UnaryOperator) {\r\n            if (node.operator === \"*\") {\r\n                const refData = this._getVariableData(node.right, context);\r\n                if (!(refData instanceof PointerData)) {\r\n                    console.error(`Variable ${node.right} is not a pointer. Line ${node.line}`);\r\n                    return null;\r\n                }\r\n\r\n                return refData.reference.getSubData(this, node.postfix, context);\r\n            } else if (node.operator === \"&\") {\r\n                const refData = this._getVariableData(node.right, context);\r\n                return new PointerData(refData);\r\n            } \r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _assign(node: Assign, context: ExecContext): void {\r\n        let v: Data | null = null;\r\n        let name: string = \"<var>\";\r\n\r\n        let postfix: Expression | null = null;\r\n\r\n        if (node.variable instanceof UnaryOperator) {\r\n            const varData = this._getVariableData(node.variable, context);\r\n            const assignValue = this.evalExpression(node.value, context);\r\n            const op = node.operator;\r\n\r\n            if (op === \"=\") {\r\n                if (varData instanceof ScalarData || varData instanceof VectorData || varData instanceof MatrixData) {\r\n                    if (assignValue instanceof ScalarData || assignValue instanceof VectorData || assignValue instanceof MatrixData &&\r\n                        varData.data.length === assignValue.data.length) {\r\n                        varData.data.set(assignValue.data);\r\n                        return;\r\n                    } else {\r\n                        console.error(`Invalid assignment. Line ${node.line}`);\r\n                    }\r\n                } else if (varData instanceof TypedData && assignValue instanceof TypedData) {\r\n                    if ((varData.buffer.byteLength - varData.offset) >= (assignValue.buffer.byteLength - assignValue.offset)) {\r\n                        if (varData.buffer.byteLength % 4 === 0) {\r\n                            new Uint32Array(varData.buffer, varData.offset, varData.typeInfo.size / 4).set(new Uint32Array(assignValue.buffer, assignValue.offset, assignValue.typeInfo.size / 4));\r\n                        } else {\r\n                            new Uint8Array(varData.buffer, varData.offset, varData.typeInfo.size).set(new Uint8Array(assignValue.buffer, assignValue.offset, assignValue.typeInfo.size));\r\n                        }\r\n                        return;\r\n                    }\r\n                }\r\n                console.error(`Invalid assignment. Line ${node.line}`);\r\n                return null;\r\n            } else if (op === \"+=\") {\r\n                if (varData instanceof ScalarData || varData instanceof VectorData || varData instanceof MatrixData) {\r\n                    if (assignValue instanceof ScalarData || assignValue instanceof VectorData || assignValue instanceof MatrixData) {\r\n                        varData.data.set(assignValue.data.map((v: number, i: number) => varData.data[i] + v));\r\n                        return;\r\n                    } else {\r\n                        console.error(`Invalid assignment . Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid assignment. Line ${node.line}`);\r\n                    return;\r\n                }\r\n            } else if (op === \"-=\") {\r\n                if (varData instanceof ScalarData || varData instanceof VectorData || varData instanceof MatrixData) {\r\n                    if (assignValue instanceof ScalarData || assignValue instanceof VectorData || assignValue instanceof MatrixData) {\r\n                        varData.data.set(assignValue.data.map((v: number, i: number) => varData.data[i] - v));\r\n                        return;\r\n                    } else {\r\n                        console.error(`Invalid assignment. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid assignment. Line ${node.line}`);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (node.variable instanceof UnaryOperator) {\r\n            if (node.variable.operator === \"*\") {\r\n                name = this.getVariableName(node.variable.right, context);\r\n                const _var = context.getVariable(name);\r\n                if (_var && _var.value instanceof PointerData) {\r\n                    v = _var.value.reference;\r\n                } else {\r\n                    console.error(`Variable ${name} is not a pointer. Line ${node.line}`);\r\n                    return;\r\n                }\r\n\r\n                let postfix = node.variable.postfix;\r\n                if (!postfix) {\r\n                    let rNode = node.variable.right;\r\n                    while (rNode instanceof UnaryOperator) {\r\n                        if (rNode.postfix) {\r\n                            postfix = rNode.postfix;\r\n                            break;\r\n                        }\r\n                        rNode = rNode.right;\r\n                    }\r\n                }\r\n                if (postfix) {\r\n                    v = v.getSubData(this, postfix, context);\r\n                }\r\n            }\r\n        } else {\r\n            postfix = node.variable.postfix;\r\n            name = this.getVariableName(node.variable, context);\r\n            const _var = context.getVariable(name);\r\n            if (_var === null) {\r\n                console.error(`Variable ${name} not found. Line ${node.line}`);\r\n                return;\r\n            }\r\n            v = _var.value;\r\n        }\r\n\r\n        if (v instanceof PointerData) {\r\n            v = v.reference;\r\n        }\r\n\r\n        if (v === null) {\r\n            console.error(`Variable ${name} not found. Line ${node.line}`);\r\n            return;\r\n        }\r\n\r\n        const value = this.evalExpression(node.value, context);\r\n\r\n        const op = node.operator;\r\n        if (op !== \"=\") {\r\n            const currentValue = v.getSubData(this, postfix, context);\r\n\r\n            if (currentValue instanceof VectorData && value instanceof ScalarData) {\r\n                const cv = currentValue.data;\r\n                const v = value.value;\r\n\r\n                if (op === \"+=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] += v;\r\n                    }\r\n                } else if (op === \"-=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] -= v;\r\n                    }\r\n                } else if (op === \"*=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] *= v;\r\n                    }\r\n                } else if (op === \"/=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] /= v;\r\n                    }\r\n                } else if (op === \"%=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] %= v;\r\n                    }\r\n                } else if (op === \"&=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] &= v;\r\n                    }\r\n                } else if (op === \"|=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] |= v;\r\n                    }\r\n                } else if (op === \"^=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] ^= v;\r\n                    }\r\n                } else if (op === \"<<=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] <<= v;\r\n                    }\r\n                } else if (op === \">>=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] >>= v;\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid operator ${op}. Line ${node.line}`);\r\n                }\r\n            } else if (currentValue instanceof VectorData && value instanceof VectorData) {\r\n                const cv = currentValue.data;\r\n                const v = value.data;\r\n                if (cv.length !== v.length) {\r\n                    console.error(`Vector length mismatch. Line ${node.line}`);\r\n                    return;\r\n                }\r\n\r\n                if (op === \"+=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] += v[i];\r\n                    }\r\n                } else if (op === \"-=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] -= v[i];\r\n                    }\r\n                } else if (op === \"*=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] *= v[i];\r\n                    }\r\n                } else if (op === \"/=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] /= v[i];\r\n                    }\r\n                } else if (op === \"%=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] %= v[i];\r\n                    }\r\n                } else if (op === \"&=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] &= v[i];\r\n                    }\r\n                } else if (op === \"|=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] |= v[i];\r\n                    }\r\n                } else if (op === \"^=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] ^= v[i];\r\n                    }\r\n                } else if (op === \"<<=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] <<= v[i];\r\n                    }\r\n                } else if (op === \">>=\") {\r\n                    for (let i = 0; i < cv.length; ++i) {\r\n                        cv[i] >>= v[i];\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid operator ${op}. Line ${node.line}`);\r\n                }\r\n            } else if (currentValue instanceof ScalarData && value instanceof ScalarData) {\r\n                if (op === \"+=\") {\r\n                    currentValue.value += value.value;\r\n                } else if (op === \"-=\") {\r\n                    currentValue.value -= value.value;\r\n                } else if (op === \"*=\") {\r\n                    currentValue.value *= value.value;\r\n                } else if (op === \"/=\") {\r\n                    currentValue.value /= value.value;\r\n                } else if (op === \"%=\") {\r\n                    currentValue.value %= value.value;\r\n                } else if (op === \"&=\") {\r\n                    currentValue.value &= value.value;\r\n                } else if (op === \"|=\") {\r\n                    currentValue.value |= value.value;\r\n                } else if (op === \"^=\") {\r\n                    currentValue.value ^= value.value;\r\n                } else if (op === \"<<=\") {\r\n                    currentValue.value <<= value.value;\r\n                } else if (op === \">>=\") {\r\n                    currentValue.value >>= value.value;\r\n                } else {\r\n                    console.error(`Invalid operator ${op}. Line ${node.line}`);\r\n                }\r\n            } else {\r\n                console.error(`Invalid type for ${node.operator} operator. Line ${node.line}`);\r\n                return;\r\n            }\r\n\r\n            // If the variable is a TypedData, as in a struct or array, and we're assigning a\r\n            // sub portion of it, set the data in the original buffer.\r\n            if (v instanceof TypedData) {\r\n                v.setDataValue(this, currentValue, postfix, context);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (v instanceof TypedData) {\r\n            v.setDataValue(this, value, postfix, context);\r\n        } else if (postfix) {\r\n            if (!(v instanceof VectorData) && !(v instanceof MatrixData)) {\r\n                console.error(`Variable ${name} is not a vector or matrix. Line ${node.line}`);\r\n                return;\r\n            }\r\n\r\n            if (postfix instanceof ArrayIndex) {\r\n                const idx = (this.evalExpression(postfix.index, context) as ScalarData).value;\r\n\r\n                if (v instanceof VectorData) {\r\n                    if (value instanceof ScalarData) {\r\n                        v.data[idx] = value.value;\r\n                    } else {\r\n                        console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                } else if (v instanceof MatrixData) {\r\n                    const idx = (this.evalExpression(postfix.index, context) as ScalarData).value;\r\n                    if (idx < 0) {\r\n                        console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                    if (value instanceof VectorData) {\r\n                        const typeName = v.typeInfo.getTypeName();\r\n                        if (typeName === \"mat2x2\" || typeName === \"mat2x2f\" || typeName === \"mat2x2h\") {\r\n                            if (idx < 2 && value.data.length === 2) {\r\n                                v.data[idx * 2] = value.data[0];\r\n                                v.data[idx * 2 + 1] = value.data[1];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat2x3\" || typeName === \"mat2x3f\" || typeName === \"mat2x3h\") {\r\n                            if (idx < 2 && value.data.length === 3) {\r\n                                v.data[idx * 3] = value.data[0];\r\n                                v.data[idx * 3 + 1] = value.data[1];\r\n                                v.data[idx * 3 + 2] = value.data[2];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat2x4\" || typeName === \"mat2x4f\" || typeName === \"mat2x4h\") {\r\n                            if (idx < 2 && value.data.length === 4) {\r\n                                v.data[idx * 4] = value.data[0];\r\n                                v.data[idx * 4 + 1] = value.data[1];\r\n                                v.data[idx * 4 + 2] = value.data[2];\r\n                                v.data[idx * 4 + 3] = value.data[3];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat3x2\" || typeName === \"mat3x2f\" || typeName === \"mat3x2h\") {\r\n                            if (idx < 3 && value.data.length === 2) {\r\n                                v.data[idx * 2] = value.data[0];\r\n                                v.data[idx * 2 + 1] = value.data[1];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat3x3\" || typeName === \"mat3x3f\" || typeName === \"mat3x3h\") {\r\n                            if (idx < 3 && value.data.length === 3) {\r\n                                v.data[idx * 3] = value.data[0];\r\n                                v.data[idx * 3 + 1] = value.data[1];\r\n                                v.data[idx * 3 + 2] = value.data[2];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat3x4\" || typeName === \"mat3x4f\" || typeName === \"mat3x4h\") {\r\n                            if (idx < 3 && value.data.length === 4) {\r\n                                v.data[idx * 4] = value.data[0];\r\n                                v.data[idx * 4 + 1] = value.data[1];\r\n                                v.data[idx * 4 + 2] = value.data[2];\r\n                                v.data[idx * 4 + 3] = value.data[3];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat4x2\" || typeName === \"mat4x2f\" || typeName === \"mat4x2h\") {\r\n                            if (idx < 4 && value.data.length === 2) {\r\n                                v.data[idx * 2] = value.data[0];\r\n                                v.data[idx * 2 + 1] = value.data[1];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat4x3\" || typeName === \"mat4x3f\" || typeName === \"mat4x3h\") {\r\n                            if (idx < 4 && value.data.length === 3) {\r\n                                v.data[idx * 3] = value.data[0];\r\n                                v.data[idx * 3 + 1] = value.data[1];\r\n                                v.data[idx * 3 + 2] = value.data[2];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else if (typeName === \"mat4x4\" || typeName === \"mat4x4f\" || typeName === \"mat4x4h\") {\r\n                            if (idx < 4 && value.data.length === 4) {\r\n                                v.data[idx * 4] = value.data[0];\r\n                                v.data[idx * 4 + 1] = value.data[1];\r\n                                v.data[idx * 4 + 2] = value.data[2];\r\n                                v.data[idx * 4 + 3] = value.data[3];\r\n                            } else {\r\n                                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                        } else {\r\n                            console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                    } else {\r\n                        console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                    return;\r\n                }\r\n            } else if (postfix instanceof StringExpr) {\r\n                const member = postfix.value;\r\n                if (!(v instanceof VectorData)) {\r\n                    console.error(`Invalid assignment to ${member}. Variable ${name} is not a vector. Line ${node.line}`);\r\n                    return;\r\n                }\r\n                if (value instanceof ScalarData) {\r\n                    if (member.length > 1) {\r\n                        console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                    if (member === \"x\") {\r\n                        v.data[0] = value.value;\r\n                    } else if (member === \"y\") {\r\n                        if (v.data.length < 2) {\r\n                            console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                        v.data[1] = value.value;\r\n                    } else if (member === \"z\") {\r\n                        if (v.data.length < 3) {\r\n                            console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                        v.data[2] = value.value;\r\n                    } else if (member === \"w\") {\r\n                        if (v.data.length < 4) {\r\n                            console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                        v.data[3] = value.value;\r\n                    }\r\n                } else if (value instanceof VectorData) {\r\n                    if (member.length !== value.data.length) {\r\n                        console.error(`Invalid assignment to ${member} for variable ${name}. Line ${node.line}`);\r\n                        return;\r\n                    }\r\n                    for (let i = 0; i < member.length; ++i) {\r\n                        const m = member[i];\r\n                        if (m === \"x\" || m === \"r\") {\r\n                            v.data[0] = value.data[i];\r\n                        } else if (m === \"y\" || m === \"g\") {\r\n                            if (value.data.length < 2) {\r\n                                console.error(`Invalid assignment to ${m} for variable ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                            v.data[1] = value.data[i];\r\n                        } else if (m === \"z\" || m === \"b\") {\r\n                            if (value.data.length < 3) {\r\n                                console.error(`Invalid assignment to ${m} for variable ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                            v.data[2] = value.data[i];\r\n                        } else if (m === \"w\" || m === \"a\") {\r\n                            if (value.data.length < 4) {\r\n                                console.error(`Invalid assignment to ${m} for variable ${name}. Line ${node.line}`);\r\n                                return;\r\n                            }\r\n                            v.data[3] = value.data[i];\r\n                        } else {\r\n                            console.error(`Invalid assignment to ${m} for variable ${name}. Line ${node.line}`);\r\n                            return;\r\n                        }\r\n                    }\r\n                } else {\r\n                    console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n                    return;\r\n                }\r\n            }\r\n        } else {\r\n            if (v instanceof ScalarData && value instanceof ScalarData) {\r\n                v.value = value.value;\r\n            } else if (v instanceof VectorData && value instanceof VectorData) {\r\n                v.data.set(value.data);\r\n            } else if (v instanceof MatrixData && value instanceof MatrixData) {\r\n                v.data.set(value.data);\r\n            } else {\r\n                console.error(`Invalid assignment to ${name}. Line ${node.line}`);\r\n            }\r\n            //v.value = value;\r\n        }\r\n        return;\r\n    }\r\n\r\n    _function(node: Function, context: ExecContext): void {\r\n        const f = new FunctionRef(node);\r\n        context.functions.set(node.name, f);\r\n    }\r\n\r\n    _const(node: Const, context: ExecContext): void {\r\n        let value = null;\r\n        if (node.value !== null) {\r\n            value = this.evalExpression(node.value, context);\r\n        }\r\n        context.createVariable(node.name, value, node);\r\n    }\r\n\r\n    _override(node: Override, context: ExecContext): void {\r\n        // Only set override value if it hasn't been provided as a constant override\r\n        const v = context.getVariable(node.name);\r\n        if (v === null || v.value === null) {\r\n            let value = null;\r\n            if (node.value !== null) {\r\n                value = this.evalExpression(node.value, context);\r\n            }\r\n            context.createVariable(node.name, value, node);\r\n        }\r\n    }\r\n\r\n    _let(node: Let, context: ExecContext): void {\r\n        let value: Data | null = null;\r\n        if (node.value !== null) {\r\n            value = this.evalExpression(node.value, context);\r\n            if (value === null) {\r\n                console.error(`Invalid value for variable ${node.name}. Line ${node.line}`);\r\n                return;\r\n            }\r\n            if (!(node.value instanceof UnaryOperator)) {\r\n                value = value.clone();\r\n            }\r\n        } else {\r\n            const typeName = node.type.name;\r\n            if (typeName === \"f32\" || typeName === \"i32\" || typeName === \"u32\" ||\r\n                typeName === \"bool\" || typeName === \"f16\" ||\r\n                typeName === \"vec2\" || typeName === \"vec3\" || typeName === \"vec4\" ||\r\n                typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\" ||\r\n                typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\" ||\r\n                typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\" ||\r\n                typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\" ||\r\n                typeName === \"vec2b\" || typeName === \"vec3b\" || typeName === \"vec4b\" ||\r\n                typeName === \"mat2x2\" || typeName === \"mat2x3\" || typeName === \"mat2x4\" ||\r\n                typeName === \"mat3x2\" || typeName === \"mat3x3\" || typeName === \"mat3x4\" ||\r\n                typeName === \"mat4x2\" || typeName === \"mat4x3\" || typeName === \"mat4x4\" ||\r\n                typeName === \"mat2x2f\" || typeName === \"mat2x3f\" || typeName === \"mat2x4f\" ||\r\n                typeName === \"mat3x2f\" || typeName === \"mat3x3f\" || typeName === \"mat3x4f\" ||\r\n                typeName === \"mat4x2f\" || typeName === \"mat4x3f\" || typeName === \"mat4x4f\" ||\r\n                typeName === \"mat2x2h\" || typeName === \"mat2x3h\" || typeName === \"mat2x4h\" ||\r\n                typeName === \"mat3x2h\" || typeName === \"mat3x3h\" || typeName === \"mat3x4h\" ||\r\n                typeName === \"mat4x2h\" || typeName === \"mat4x3h\" || typeName === \"mat4x4h\" ||\r\n                typeName === \"array\") {\r\n                const defType = new CreateExpr(node.type, []);\r\n                value = this._evalCreate(defType, context);\r\n            }\r\n        }\r\n        context.createVariable(node.name, value, node);\r\n    }\r\n\r\n    _var(node: Var, context: ExecContext): void {\r\n        let value = null;\r\n        if (node.value !== null) {\r\n            value = this.evalExpression(node.value, context);\r\n            if (value === null) {\r\n                console.error(`Invalid value for variable ${node.name}. Line ${node.line}`);\r\n                return;\r\n            }\r\n            if (!(node.value instanceof UnaryOperator)) {\r\n                value = value.clone();\r\n            }\r\n        } else {\r\n            if (node.type === null) {\r\n                console.error(`Variable ${node.name} has no type. Line ${node.line}`);\r\n                return;\r\n            }\r\n\r\n            const typeName = node.type.name;\r\n            if (typeName === \"f32\" || typeName === \"i32\" || typeName === \"u32\" ||\r\n                typeName === \"bool\" || typeName === \"f16\" ||\r\n                typeName === \"vec2\" || typeName === \"vec3\" || typeName === \"vec4\" ||\r\n                typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\" ||\r\n                typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\" ||\r\n                typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\" ||\r\n                typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\" ||\r\n                typeName === \"vec2b\" || typeName === \"vec3b\" || typeName === \"vec4b\" ||\r\n                typeName === \"mat2x2\" || typeName === \"mat2x3\" || typeName === \"mat2x4\" ||\r\n                typeName === \"mat3x2\" || typeName === \"mat3x3\" || typeName === \"mat3x4\" ||\r\n                typeName === \"mat4x2\" || typeName === \"mat4x3\" || typeName === \"mat4x4\" ||\r\n                typeName === \"mat2x2f\" || typeName === \"mat2x3f\" || typeName === \"mat2x4f\" ||\r\n                typeName === \"mat3x2f\" || typeName === \"mat3x3f\" || typeName === \"mat3x4f\" ||\r\n                typeName === \"mat4x2f\" || typeName === \"mat4x3f\" || typeName === \"mat4x4f\" ||\r\n                typeName === \"mat2x2h\" || typeName === \"mat2x3h\" || typeName === \"mat2x4h\" ||\r\n                typeName === \"mat3x2h\" || typeName === \"mat3x3h\" || typeName === \"mat3x4h\" ||\r\n                typeName === \"mat4x2h\" || typeName === \"mat4x3h\" || typeName === \"mat4x4h\" ||\r\n                node.type instanceof ArrayType || node.type instanceof Struct || node.type instanceof TemplateType) {\r\n                const defType = new CreateExpr(node.type, []);\r\n                value = this._evalCreate(defType, context);\r\n            }\r\n        }\r\n\r\n        context.createVariable(node.name, value, node);\r\n    }\r\n\r\n    _switch(node: Switch, context: ExecContext) : Data | null {\r\n        context = context.clone();\r\n        const condition = this.evalExpression(node.condition, context);\r\n        if (!(condition instanceof ScalarData)) {\r\n            console.error(`Invalid if condition. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        let defaultCase: SwitchCase | null = null;\r\n\r\n        for (const c of node.cases) {\r\n            if (c instanceof Case) {\r\n                for (const selector of c.selectors) {\r\n                    if (selector instanceof DefaultSelector) {\r\n                        defaultCase = c;\r\n                        continue;\r\n                    }\r\n\r\n                    const selectorValue = this.evalExpression(selector, context);\r\n                    if (!(selectorValue instanceof ScalarData)) {\r\n                        console.error(`Invalid case selector. Line ${node.line}`);\r\n                        return null;\r\n                    }\r\n\r\n                    if (selectorValue.value === condition.value) {\r\n                        return this._execStatements(c.body, context);\r\n                    }\r\n                }\r\n            } else if (c instanceof Default) {\r\n                defaultCase = c;\r\n            }\r\n        }\r\n\r\n        if (defaultCase) {\r\n            return this._execStatements(defaultCase.body, context);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _if(node: If, context: ExecContext): Data | null {\r\n        context = context.clone();\r\n        const condition = this.evalExpression(node.condition, context);\r\n        if (!(condition instanceof ScalarData)) {\r\n            console.error(`Invalid if condition. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        if (condition.value) {\r\n            return this._execStatements(node.body, context);\r\n        }\r\n\r\n        for (const e of node.elseif) {\r\n            const condition = this.evalExpression(e.condition, context);\r\n            if (!(condition instanceof ScalarData)) {\r\n                console.error(`Invalid if condition. Line ${node.line}`);\r\n                return null;\r\n            }\r\n            if (condition.value) {\r\n                return this._execStatements(e.body, context);\r\n            }\r\n        }\r\n\r\n        if (node.else) {\r\n            return this._execStatements(node.else, context);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _getScalarValue(v: Data | null): number {\r\n        if (v instanceof ScalarData) {\r\n            return v.value;\r\n        }\r\n        console.error(`Expected scalar value.`, v);\r\n        return 0;\r\n    }\r\n\r\n    _for(node: For, context: ExecContext): Data | null {\r\n        context = context.clone();\r\n        this.execStatement(node.init, context);\r\n        while (this._getScalarValue(this.evalExpression(node.condition, context))) {\r\n            const res = this._execStatements(node.body, context);\r\n            if (res === WgslExec._breakObj) {\r\n                break;\r\n            }\r\n            if (res !== null && res !== WgslExec._continueObj) {\r\n                return res;\r\n            }\r\n            this.execStatement(node.increment, context);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _loop(node: Loop, context: ExecContext): Data | null {\r\n        context = context.clone();\r\n\r\n        while (true) {\r\n            const res = this._execStatements(node.body, context);\r\n            if (res === WgslExec._breakObj) {\r\n                break;\r\n            } else if (res === WgslExec._continueObj) {\r\n                if (node.continuing) {\r\n                    const cres = this._execStatements(node.continuing.body, context);\r\n                    if (cres === WgslExec._breakObj) {\r\n                        break;\r\n                    }\r\n                }\r\n            } else if (res !== null) {\r\n                return res;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _while(node: While, context: ExecContext): Data | null {\r\n        context = context.clone();\r\n        while (this._getScalarValue(this.evalExpression(node.condition, context))) {\r\n            const res = this._execStatements(node.body, context);\r\n            if (res === WgslExec._breakObj) {\r\n                break;\r\n            } else if (res === WgslExec._continueObj) {\r\n                continue;\r\n            } else if (res !== null) {\r\n                return res;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _evalBitcast(node: BitcastExpr, context: ExecContext): Data | null {\r\n        const value = this.evalExpression(node.value, context);\r\n        const type = node.type;\r\n\r\n        if (value instanceof ScalarData) {\r\n            const v = castScalar(value.value, value.typeInfo.name, type.name);\r\n            return new ScalarData(v, this.getTypeInfo(type));\r\n        }\r\n\r\n        if (value instanceof VectorData) {\r\n            const fromType = value.typeInfo.getTypeName();\r\n            let fromCast = \"\";\r\n            if (fromType.endsWith(\"f\")) {\r\n                fromCast = \"f32\";\r\n            } else if (fromType.endsWith(\"i\")) {\r\n                fromCast = \"i32\";\r\n            } else if (fromType.endsWith(\"u\")) {\r\n                fromCast = \"u32\";\r\n            } else if (fromType.endsWith(\"b\")) {\r\n                fromCast = \"bool\";\r\n            } else if (fromType.endsWith(\"h\")) {\r\n                fromCast = \"f16\";\r\n            } else {\r\n                console.error(`Unknown vector type ${fromType}. Line ${node.line}`);\r\n                return null;\r\n            }\r\n\r\n            const toType = type.getTypeName();\r\n            let toCast = \"\";\r\n            if (toType.endsWith(\"f\")) {\r\n                toCast = \"f32\";\r\n            } else if (toType.endsWith(\"i\")) {\r\n                toCast = \"i32\";\r\n            } else if (toType.endsWith(\"u\")) {\r\n                toCast = \"u32\";\r\n            } else if (toType.endsWith(\"b\")) {\r\n                toCast = \"bool\";\r\n            } else if (toType.endsWith(\"h\")) {\r\n                toCast = \"f16\";\r\n            } else {\r\n                console.error(`Unknown vector type ${toCast}. Line ${node.line}`);\r\n                return null;\r\n            }\r\n\r\n            const v = castVector(Array.from(value.data), fromCast, toCast);\r\n            return new VectorData(v, this.getTypeInfo(type));\r\n        }\r\n\r\n        console.error(`TODO: bitcast for ${value.typeInfo.name}. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _evalConst(node: ConstExpr, context: ExecContext): Data | null {\r\n        const data = context.getVariableValue(node.name).clone();\r\n        return data.getSubData(this, node.postfix, context);\r\n    }\r\n\r\n    _evalCreate(node: CreateExpr | CallExpr | Call, context: ExecContext): Data | null {\r\n        if (node instanceof CreateExpr) {\r\n            if (node.type === null) {\r\n                return VoidData.void;\r\n            }\r\n\r\n            const typeName = node.type.getTypeName();\r\n\r\n            switch (typeName) {\r\n                // Constructor Built-in Functions\r\n                // Value Constructor Built-in Functions\r\n                case \"bool\":\r\n                case \"i32\":\r\n                case \"u32\":\r\n                case \"f32\":\r\n                case \"f16\":\r\n                    return this._callConstructorValue(node, context);\r\n                case \"vec2\":\r\n                case \"vec3\":\r\n                case \"vec4\":\r\n                case \"vec2f\":\r\n                case \"vec3f\":\r\n                case \"vec4f\":\r\n                case \"vec2h\":\r\n                case \"vec3h\":\r\n                case \"vec4h\":\r\n                case \"vec2i\":\r\n                case \"vec3i\":\r\n                case \"vec4i\":\r\n                case \"vec2u\":\r\n                case \"vec3u\":\r\n                case \"vec4u\":\r\n                case \"vec2b\":\r\n                case \"vec3b\":\r\n                case \"vec4b\":\r\n                    return this._callConstructorVec(node, context);\r\n                case \"mat2x2\":\r\n                case \"mat2x2f\":\r\n                case \"mat2x2h\":\r\n                case \"mat2x3\":\r\n                case \"mat2x3f\":\r\n                case \"mat2x3h\":\r\n                case \"mat2x4\":\r\n                case \"mat2x4f\":\r\n                case \"mat2x4h\":\r\n                case \"mat3x2\":\r\n                case \"mat3x2f\":\r\n                case \"mat3x2h\":\r\n                case \"mat3x3\":\r\n                case \"mat3x3f\":\r\n                case \"mat3x3h\":\r\n                case \"mat3x4\":\r\n                case \"mat3x4f\":\r\n                case \"mat3x4h\":\r\n                case \"mat4x2\":\r\n                case \"mat4x2f\":\r\n                case \"mat4x2h\":\r\n                case \"mat4x3\":\r\n                case \"mat4x3f\":\r\n                case \"mat4x3h\":\r\n                case \"mat4x4\":\r\n                case \"mat4x4f\":\r\n                case \"mat4x4h\":\r\n                    return this._callConstructorMatrix(node, context);\r\n            }\r\n        }\r\n\r\n        const typeName = (node instanceof CreateExpr) ? node.type.name : node.name;\r\n        const typeInfo = (node instanceof CreateExpr) ? this.getTypeInfo(node.type) : this.getTypeInfo(node.name);\r\n        if (typeInfo === null) {\r\n            console.error(`Unknown type ${typeName}. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        if (typeInfo.size === 0) {\r\n            return null;\r\n        }\r\n\r\n        const data = new TypedData(new ArrayBuffer(typeInfo.size), typeInfo, 0);\r\n\r\n        // Assign the values in node.args to the data.\r\n        if (typeInfo instanceof StructInfo) {\r\n            if (node.args) {\r\n                for (let i = 0; i < node.args.length; ++i) {\r\n                    const memberInfo = typeInfo.members[i];\r\n                    const arg = node.args[i];\r\n                    const value = this.evalExpression(arg, context);\r\n                    data.setData(this, value, memberInfo.type, memberInfo.offset, context);\r\n                }\r\n            }\r\n        } else if (typeInfo instanceof ArrayInfo) {\r\n            let offset = 0;\r\n            if (node.args) {\r\n                for (let i = 0; i < node.args.length; ++i) {\r\n                    const arg = node.args[i];\r\n                    const value = this.evalExpression(arg, context);\r\n                    if (typeInfo.format === null) {\r\n                        if (value.typeInfo?.name === \"x32\") {\r\n                            typeInfo.format = this.getTypeInfo(\"i32\");\r\n                        } else {\r\n                            typeInfo.format = value.typeInfo;\r\n                        }\r\n                    }\r\n                    data.setData(this, value, typeInfo.format, offset, context);\r\n                    offset += typeInfo.stride;\r\n                }\r\n            }\r\n        } else {\r\n            console.error(`Unknown type \"${typeName}\". Line ${node.line}`);\r\n        }\r\n\r\n        if (node instanceof CreateExpr) {\r\n            return data.getSubData(this, node.postfix, context);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    _evalLiteral(node: LiteralExpr, context: ExecContext): Data | null {\r\n        const typeInfo = this.getTypeInfo(node.type);\r\n        const typeName = typeInfo.name;\r\n        if (typeName === \"x32\" || typeName === \"u32\" || typeName === \"f32\" || typeName === \"f16\" ||\r\n            typeName === \"i32\" || typeName === \"bool\") {\r\n            const data = new ScalarData(node.scalarValue, typeInfo);\r\n            return data;\r\n        }\r\n        if (typeName === \"vec2\" || typeName === \"vec3\" || typeName === \"vec4\" ||\r\n            typeName === \"vec2f\" || typeName === \"vec3f\" || typeName === \"vec4f\" ||\r\n            typeName === \"vec2h\" || typeName === \"vec3h\" || typeName === \"vec4h\" ||\r\n            typeName === \"vec2i\" || typeName === \"vec3i\" || typeName === \"vec4i\" ||\r\n            typeName === \"vec2u\" || typeName === \"vec3u\" || typeName === \"vec4u\") {\r\n            return this._callConstructorVec(node, context);\r\n        }\r\n        if (typeName === \"mat2x2\" || typeName === \"mat2x3\" || typeName === \"mat2x4\" ||\r\n            typeName === \"mat3x2\" || typeName === \"mat3x3\" || typeName === \"mat3x4\" ||\r\n            typeName === \"mat4x2\" || typeName === \"mat4x3\" || typeName === \"mat4x4\" ||\r\n            typeName === \"mat2x2f\" || typeName === \"mat2x3f\" || typeName === \"mat2x4f\" ||\r\n            typeName === \"mat3x2f\" || typeName === \"mat3x3f\" || typeName === \"mat3x4f\" ||\r\n            typeName === \"mat4x2f\" || typeName === \"mat4x3f\" || typeName === \"mat4x4f\" ||\r\n            typeName === \"mat2x2h\" || typeName === \"mat2x3h\" || typeName === \"mat2x4h\" ||\r\n            typeName === \"mat3x2h\" || typeName === \"mat3x3h\" || typeName === \"mat3x4h\" ||\r\n            typeName === \"mat4x2h\" || typeName === \"mat4x3h\" || typeName === \"mat4x4h\") {\r\n            return this._callConstructorMatrix(node, context);\r\n        }\r\n        return node.value;\r\n    }\r\n\r\n    _evalVariable(node: VariableExpr, context: ExecContext): Data | null {\r\n        const value = context.getVariableValue(node.name);\r\n        if (value === null) {\r\n            return value;\r\n        }\r\n        return value.getSubData(this, node.postfix, context);\r\n    }\r\n\r\n    static _priority = new Map<string, number>([[\"f32\", 0], [\"f16\", 1], [\"u32\", 2], [\"i32\", 3], [\"x32\", 3]]);\r\n    _maxFormatTypeInfo(x: TypeInfo[]): TypeInfo | null {\r\n        let t = x[0];\r\n        if (t.name === \"f32\") {\r\n            return t;\r\n        }\r\n        for (let i = 1; i < x.length; ++i) {\r\n            const tv = WgslExec._priority.get(t.name);\r\n            const xv = WgslExec._priority.get(x[i].name);\r\n            if (xv < tv) {\r\n                t = x[i];\r\n            }\r\n        }\r\n\r\n        if (t.name === \"x32\") {\r\n            return this.getTypeInfo(\"i32\");\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    _evalUnaryOp(node: UnaryOperator, context: ExecContext): Data | null {\r\n        const _r = this.evalExpression(node.right, context);\r\n\r\n        if (node.operator === \"&\") { \r\n            return new PointerData(_r);\r\n        } else if (node.operator === \"*\") {\r\n            if (_r instanceof PointerData) {\r\n                return _r.reference.getSubData(this, node.postfix, context);\r\n            }\r\n            console.error(`Invalid dereference. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const r = _r instanceof ScalarData ? _r.value : \r\n            _r instanceof VectorData ? Array.from(_r.data) : null;\r\n\r\n        switch (node.operator) {\r\n            case \"+\": {\r\n                if (isArray(r)) {\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => +x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_r.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(+rn, t);\r\n            }\r\n            case \"-\": {\r\n                if (isArray(r)) {\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => -x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_r.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(-rn, t);\r\n            }\r\n            case \"!\": {\r\n                if (isArray(r)) {\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => !x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_r.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(!rn ? 1 : 0, t);\r\n            }\r\n            case \"~\": {\r\n                if (isArray(r)) {\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ~x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_r.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(~rn, t);\r\n            }\r\n        }\r\n        console.error(`Invalid unary operator ${node.operator}. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _isMatrixType(data: Data): boolean {\r\n        const typeName = data.typeInfo.getTypeName();\r\n        return typeName.startsWith(\"mat\");\r\n    }\r\n\r\n    _isVectorType(data: Data): boolean {\r\n        const typeName = data.typeInfo.getTypeName();\r\n        return typeName.startsWith(\"vec\");\r\n    }\r\n\r\n    _evalBinaryOp(node: BinaryOperator, context: ExecContext): Data | null {\r\n        const _l = this.evalExpression(node.left, context);\r\n        const _r = this.evalExpression(node.right, context);\r\n\r\n        const l = _l instanceof ScalarData ? _l.value : \r\n            _l instanceof VectorData ? Array.from(_l.data) :\r\n            _l instanceof MatrixData ? Array.from(_l.data) : \r\n            _l instanceof TypedData ? _l.toArray() :\r\n            null;\r\n        const r = _r instanceof ScalarData ? _r.value : \r\n            _r instanceof VectorData ? Array.from(_r.data) : \r\n            _r instanceof MatrixData ? Array.from(_r.data) :\r\n            _r instanceof TypedData ? _r.toArray() :\r\n            null;\r\n\r\n        switch (node.operator) {\r\n            case \"+\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x + ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x + rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln + x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln + rn, t);\r\n            }\r\n            case \"-\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x - ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x - rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln - x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln - rn, t);\r\n            }\r\n            case \"*\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (this._isMatrixType(_l) && this._isMatrixType(_r)) {\r\n                        const result = matrixMultiply(la, _l.typeInfo, ra, _r.typeInfo);\r\n                        if (result === null) {\r\n                            console.error(`Matrix multiplication failed. Line ${node.line}.`);\r\n                            return null;\r\n                        }\r\n                        const colsB = MatrixTypeSize[_r.typeInfo.name][0];\r\n                        const rowsA = MatrixTypeSize[_l.typeInfo.name][1];\r\n                        const type = this.getTypeInfo(`mat${colsB}x${rowsA}f`);\r\n                        return new MatrixData(result, type);\r\n                    } else if (this._isMatrixType(_l) && this._isVectorType(_r)) {\r\n                        const result = matrixVectorMultiply(la, _l.typeInfo, ra, _r.typeInfo);\r\n                        if (result === null) {\r\n                            console.error(`Matrix vector multiplication failed. Line ${node.line}.`);\r\n                            return null;\r\n                        }\r\n                        return new VectorData(result, _r.typeInfo);\r\n                    } else if (this._isVectorType(_l) && this._isMatrixType(_r)) {\r\n                        const result = vectorMatrixMultiply(la, _l.typeInfo, ra, _r.typeInfo);\r\n                        if (result === null) {\r\n                            console.error(`Matrix vector multiplication failed. Line ${node.line}.`);\r\n                            return null;\r\n                        }\r\n                        return new VectorData(result, _l.typeInfo);\r\n                    } else {\r\n                        if (la.length !== ra.length) {\r\n                            console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                            return null;\r\n                        }\r\n                        const result = la.map((x: number, i: number) => x * ra[i]);\r\n                        return new VectorData(result, _l.typeInfo);\r\n                    }\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x * rn);\r\n                    if (this._isMatrixType(_l)) {\r\n                        return new MatrixData(result, _l.typeInfo);\r\n                    }\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln * x);\r\n                    if (_r instanceof MatrixData) {\r\n                        return new MatrixData(result, _r.typeInfo);\r\n                    }\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln * rn, t);\r\n            }\r\n            case \"%\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x % ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x % rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln % x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln % rn, t);\r\n            }\r\n            case \"/\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x / ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x / rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln / x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln / rn, t);\r\n            }\r\n            case \"&\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x & ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x & rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln & x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln & rn, t);\r\n            }\r\n            case \"|\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x | ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x | rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln | x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln | rn, t);\r\n            }\r\n            case \"^\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x ^ ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x ^ rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln ^ x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln ^ rn, t);\r\n            }\r\n            case \"<<\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x << ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x << rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln << x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln << rn, t);\r\n            }\r\n            case \">>\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x >> ra[i]);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x >> rn);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln >> x);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                const t = this._maxFormatTypeInfo([_l.typeInfo, _r.typeInfo]);\r\n                return new ScalarData(ln >> rn, t);\r\n            }\r\n            case \">\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x > ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x > rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln > x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln > rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"<\":\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x < ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x < rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln < x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln < rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            case \"==\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x === ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x == rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln == x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln === rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"!=\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x !== ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x !== rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln !== x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln !== rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \">=\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x >= ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x >= rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln >= x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln >= rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"<=\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x <= ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x <= rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln <= x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln <= rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"&&\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x && ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x && rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln && x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln && rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n            case \"||\": {\r\n                if (isArray(l) && isArray(r)) {\r\n                    const la = l as number[];\r\n                    const ra = r as number[];\r\n                    if (la.length !== ra.length) {\r\n                        console.error(`Vector length mismatch. Line ${node.line}.`);\r\n                        return null;\r\n                    }\r\n                    const result = la.map((x: number, i: number) => x || ra[i] ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(l)) {\r\n                    const la = l as number[];\r\n                    const rn = r as number;\r\n                    const result = la.map((x: number, i: number) => x || rn ? 1 : 0);\r\n                    return new VectorData(result, _l.typeInfo);\r\n                } else if (isArray(r)) {\r\n                    const ln = l as number;\r\n                    const ra = r as number[];\r\n                    const result = ra.map((x: number, i: number) => ln || x ? 1 : 0);\r\n                    return new VectorData(result, _r.typeInfo);\r\n                }\r\n                const ln = l as number;\r\n                const rn = r as number;\r\n                return new ScalarData(ln || rn ? 1 : 0, this.getTypeInfo(\"bool\"));\r\n            }\r\n        }\r\n        console.error(`Unknown operator ${node.operator}. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _evalCall(node: CallExpr, context: ExecContext): Data | null {\r\n        if (node.cachedReturnValue !== null) {\r\n            return node.cachedReturnValue;\r\n        }\r\n\r\n        const subContext = context.clone();\r\n        subContext.currentFunctionName = node.name;\r\n\r\n        const f = context.getFunction(node.name);\r\n        if (!f) {\r\n            if (node.isBuiltin) {\r\n                return this._callBuiltinFunction(node, subContext);\r\n            }\r\n\r\n            const typeInfo = this.getTypeInfo(node.name);\r\n            if (typeInfo) {\r\n                return this._evalCreate(node, context);\r\n            }\r\n\r\n            console.error(`Unknown function \"${node.name}\". Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        for (let ai = 0; ai < f.node.args.length; ++ai) {\r\n            const arg = f.node.args[ai];\r\n            const value = this.evalExpression(node.args[ai], subContext);\r\n            subContext.createVariable(arg.name, value, arg);\r\n        }\r\n\r\n        return this._execStatements(f.node.body, subContext);\r\n    }\r\n\r\n    _callBuiltinFunction(node: CallExpr | Call, context: ExecContext): Data | null {\r\n        switch (node.name) {\r\n            // Logical Built-in Functions\r\n            case \"all\":\r\n                return this.builtins.All(node, context);\r\n            case \"any\":\r\n                return this.builtins.Any(node, context);\r\n            case \"select\":\r\n                return this.builtins.Select(node, context);\r\n\r\n            // Array Built-in Functions\r\n            case \"arrayLength\":\r\n                return this.builtins.ArrayLength(node, context);\r\n\r\n            // Numeric Built-in Functions\r\n            case \"abs\":\r\n                return this.builtins.Abs(node, context);\r\n            case \"acos\":\r\n                return this.builtins.Acos(node, context);\r\n            case \"acosh\":\r\n                return this.builtins.Acosh(node, context);\r\n            case \"asin\":\r\n                return this.builtins.Asin(node, context);\r\n            case \"asinh\":\r\n                return this.builtins.Asinh(node, context);\r\n            case \"atan\":\r\n                return this.builtins.Atan(node, context);\r\n            case \"atanh\":\r\n                return this.builtins.Atanh(node, context);\r\n            case \"atan2\":\r\n                return this.builtins.Atan2(node, context);\r\n            case \"ceil\":\r\n                return this.builtins.Ceil(node, context);\r\n            case \"clamp\":\r\n                return this.builtins.Clamp(node, context);\r\n            case \"cos\":\r\n                return this.builtins.Cos(node, context);\r\n            case \"cosh\":\r\n                return this.builtins.Cosh(node, context);\r\n            case \"countLeadingZeros\":\r\n                return this.builtins.CountLeadingZeros(node, context);\r\n            case \"countOneBits\":\r\n                return this.builtins.CountOneBits(node, context);\r\n            case \"countTrailingZeros\":\r\n                return this.builtins.CountTrailingZeros(node, context);\r\n            case \"cross\":\r\n                return this.builtins.Cross(node, context);\r\n            case \"degrees\":\r\n                return this.builtins.Degrees(node, context);\r\n            case \"determinant\":\r\n                return this.builtins.Determinant(node, context);\r\n            case \"distance\":\r\n                return this.builtins.Distance(node, context);\r\n            case \"dot\":\r\n                return this.builtins.Dot(node, context);\r\n            case \"dot4U8Packed\":\r\n                return this.builtins.Dot4U8Packed(node, context);\r\n            case \"dot4I8Packed\":\r\n                return this.builtins.Dot4I8Packed(node, context);\r\n            case \"exp\":\r\n                return this.builtins.Exp(node, context);\r\n            case \"exp2\":\r\n                return this.builtins.Exp2(node, context);\r\n            case \"extractBits\":\r\n                return this.builtins.ExtractBits(node, context);\r\n            case \"faceForward\":\r\n                return this.builtins.FaceForward(node, context);\r\n            case \"firstLeadingBit\":\r\n                return this.builtins.FirstLeadingBit(node, context);\r\n            case \"firstTrailingBit\":\r\n                return this.builtins.FirstTrailingBit(node, context);\r\n            case \"floor\":\r\n                return this.builtins.Floor(node, context);\r\n            case \"fma\":\r\n                return this.builtins.Fma(node, context);\r\n            case \"fract\":\r\n                return this.builtins.Fract(node, context);\r\n            case \"frexp\":\r\n                return this.builtins.Frexp(node, context);\r\n            case \"insertBits\":\r\n                return this.builtins.InsertBits(node, context);\r\n            case \"inverseSqrt\":\r\n                return this.builtins.InverseSqrt(node, context);\r\n            case \"ldexp\":\r\n                return this.builtins.Ldexp(node, context);\r\n            case \"length\":\r\n                return this.builtins.Length(node, context);\r\n            case \"log\":\r\n                return this.builtins.Log(node, context);\r\n            case \"log2\":\r\n                return this.builtins.Log2(node, context);\r\n            case \"max\":\r\n                return this.builtins.Max(node, context);\r\n            case \"min\":\r\n                return this.builtins.Min(node, context);\r\n            case \"mix\":\r\n                return this.builtins.Mix(node, context);\r\n            case \"modf\":\r\n                return this.builtins.Modf(node, context);\r\n            case \"normalize\":\r\n                return this.builtins.Normalize(node, context);\r\n            case \"pow\":\r\n                return this.builtins.Pow(node, context);\r\n            case \"quantizeToF16\":\r\n                return this.builtins.QuantizeToF16(node, context);\r\n            case \"radians\":\r\n                return this.builtins.Radians(node, context);\r\n            case \"reflect\":\r\n                return this.builtins.Reflect(node, context);\r\n            case \"refract\":\r\n                return this.builtins.Refract(node, context);\r\n            case \"reverseBits\":\r\n                return this.builtins.ReverseBits(node, context);\r\n            case \"round\":\r\n                return this.builtins.Round(node, context);\r\n            case \"saturate\":\r\n                return this.builtins.Saturate(node, context);\r\n            case \"sign\":\r\n                return this.builtins.Sign(node, context);\r\n            case \"sin\":\r\n                return this.builtins.Sin(node, context);\r\n            case \"sinh\":\r\n                return this.builtins.Sinh(node, context);\r\n            case \"smoothstep\":\r\n                return this.builtins.SmoothStep(node, context);\r\n            case \"sqrt\":\r\n                return this.builtins.Sqrt(node, context);\r\n            case \"step\":\r\n                return this.builtins.Step(node, context);\r\n            case \"tan\":\r\n                return this.builtins.Tan(node, context);\r\n            case \"tanh\":\r\n                return this.builtins.Tanh(node, context);\r\n            case \"transpose\":\r\n                return this.builtins.Transpose(node, context);\r\n            case \"trunc\":\r\n                return this.builtins.Trunc(node, context);\r\n\r\n            // Derivative Built-in Functions\r\n            case \"dpdx\":\r\n                return this.builtins.Dpdx(node, context);\r\n            case \"dpdxCoarse\":\r\n                return this.builtins.DpdxCoarse(node, context);\r\n            case \"dpdxFine\":\r\n                return this.builtins.DpdxFine(node, context);\r\n            case \"dpdy\":\r\n                return this.builtins.Dpdy(node, context);\r\n            case \"dpdyCoarse\":\r\n                return this.builtins.DpdyCoarse(node, context);\r\n            case \"dpdyFine\":\r\n                return this.builtins.DpdyFine(node, context);\r\n            case \"fwidth\":\r\n                return this.builtins.Fwidth(node, context);\r\n            case \"fwidthCoarse\":\r\n                return this.builtins.FwidthCoarse(node, context);\r\n            case \"fwidthFine\":\r\n                return this.builtins.FwidthFine(node, context);\r\n\r\n            // Texture Built-in Functions\r\n            case \"textureDimensions\":\r\n                return this.builtins.TextureDimensions(node, context);\r\n            case \"textureGather\":\r\n                return this.builtins.TextureGather(node, context);\r\n            case \"textureGatherCompare\":\r\n                return this.builtins.TextureGatherCompare(node, context);\r\n            case \"textureLoad\":\r\n                return this.builtins.TextureLoad(node, context);\r\n            case \"textureNumLayers\":\r\n                return this.builtins.TextureNumLayers(node, context);\r\n            case \"textureNumLevels\":\r\n                return this.builtins.TextureNumLevels(node, context);\r\n            case \"textureNumSamples\":\r\n                return this.builtins.TextureNumSamples(node, context);\r\n            case \"textureSample\":\r\n                return this.builtins.TextureSample(node, context);\r\n            case \"textureSampleBias\":\r\n                return this.builtins.TextureSampleBias(node, context);\r\n            case \"textureSampleCompare\":\r\n                return this.builtins.TextureSampleCompare(node, context);\r\n            case \"textureSampleCompareLevel\":\r\n                return this.builtins.TextureSampleCompareLevel(node, context);\r\n            case \"textureSampleGrad\":\r\n                return this.builtins.TextureSampleGrad(node, context);\r\n            case \"textureSampleLevel\":\r\n                return this.builtins.TextureSampleLevel(node, context);\r\n            case \"textureSampleBaseClampToEdge\":\r\n                return this.builtins.TextureSampleBaseClampToEdge(node, context);\r\n            case \"textureStore\":\r\n                return this.builtins.TextureStore(node, context);\r\n\r\n            // Atomic Built-in Functions\r\n            case \"atomicLoad\":\r\n                return this.builtins.AtomicLoad(node, context);\r\n            case \"atomicStore\":\r\n                return this.builtins.AtomicStore(node, context);\r\n            case \"atomicAdd\":\r\n                return this.builtins.AtomicAdd(node, context);\r\n            case \"atomicSub\":\r\n                return this.builtins.AtomicSub(node, context);\r\n            case \"atomicMax\":\r\n                return this.builtins.AtomicMax(node, context);\r\n            case \"atomicMin\":\r\n                return this.builtins.AtomicMin(node, context);\r\n            case \"atomicAnd\":\r\n                return this.builtins.AtomicAnd(node, context);\r\n            case \"atomicOr\":\r\n                return this.builtins.AtomicOr(node, context);\r\n            case \"atomicXor\":\r\n                return this.builtins.AtomicXor(node, context);\r\n            case \"atomicExchange\":\r\n                return this.builtins.AtomicExchange(node, context);\r\n            case \"atomicCompareExchangeWeak\":\r\n                return this.builtins.AtomicCompareExchangeWeak(node, context);\r\n\r\n            // Data Packing Built-in Functions\r\n            case \"pack4x8snorm\":\r\n                return this.builtins.Pack4x8snorm(node, context);\r\n            case \"pack4x8unorm\":\r\n                return this.builtins.Pack4x8unorm(node, context);\r\n            case \"pack4xI8\":\r\n                return this.builtins.Pack4xI8(node, context);\r\n            case \"pack4xU8\":\r\n                return this.builtins.Pack4xU8(node, context);\r\n            case \"pack4x8Clamp\":\r\n                return this.builtins.Pack4x8Clamp(node, context);\r\n            case \"pack4xU8Clamp\":\r\n                return this.builtins.Pack4xU8Clamp(node, context);\r\n            case \"pack2x16snorm\":\r\n                return this.builtins.Pack2x16snorm(node, context);\r\n            case \"pack2x16unorm\":\r\n                return this.builtins.Pack2x16unorm(node, context);\r\n            case \"pack2x16float\":\r\n                return this.builtins.Pack2x16float(node, context);\r\n\r\n            // Data Unpacking Built-in Functions\r\n            case \"unpack4x8snorm\":\r\n                return this.builtins.Unpack4x8snorm(node, context);\r\n            case \"unpack4x8unorm\":\r\n                return this.builtins.Unpack4x8unorm(node, context);\r\n            case \"unpack4xI8\":\r\n                return this.builtins.Unpack4xI8(node, context);\r\n            case \"unpack4xU8\":\r\n                return this.builtins.Unpack4xU8(node, context);\r\n            case \"unpack2x16snorm\":\r\n                return this.builtins.Unpack2x16snorm(node, context);\r\n            case \"unpack2x16unorm\":\r\n                return this.builtins.Unpack2x16unorm(node, context);\r\n            case \"unpack2x16float\":\r\n                return this.builtins.Unpack2x16float(node, context);\r\n\r\n            // Synchronization Built-in Functions\r\n            case \"storageBarrier\":\r\n                return this.builtins.StorageBarrier(node, context);\r\n            case \"textureBarrier\":\r\n                return this.builtins.TextureBarrier(node, context);\r\n            case \"workgroupBarrier\":\r\n                return this.builtins.WorkgroupBarrier(node, context);\r\n            case \"workgroupUniformLoad\":\r\n                return this.builtins.WorkgroupUniformLoad(node, context);\r\n\r\n            // Subgroup Built-in Functions\r\n            case \"subgroupAdd\":\r\n                return this.builtins.SubgroupAdd(node, context);\r\n            case \"subgroupExclusiveAdd\":\r\n                return this.builtins.SubgroupExclusiveAdd(node, context);\r\n            case \"subgroupInclusiveAdd\":\r\n                return this.builtins.SubgroupInclusiveAdd(node, context);\r\n            case \"subgroupAll\":\r\n                return this.builtins.SubgroupAll(node, context);\r\n            case \"subgroupAnd\":\r\n                return this.builtins.SubgroupAnd(node, context);\r\n            case \"subgroupAny\":\r\n                return this.builtins.SubgroupAny(node, context);\r\n            case \"subgroupBallot\":\r\n                return this.builtins.SubgroupBallot(node, context);\r\n            case \"subgroupBroadcast\":\r\n                return this.builtins.SubgroupBroadcast(node, context);\r\n            case \"subgroupBroadcastFirst\":\r\n                return this.builtins.SubgroupBroadcastFirst(node, context);\r\n            case \"subgroupElect\":\r\n                return this.builtins.SubgroupElect(node, context);\r\n            case \"subgroupMax\":\r\n                return this.builtins.SubgroupMax(node, context);\r\n            case \"subgroupMin\":\r\n                return this.builtins.SubgroupMin(node, context);\r\n            case \"subgroupMul\":\r\n                return this.builtins.SubgroupMul(node, context);\r\n            case \"subgroupExclusiveMul\":\r\n                return this.builtins.SubgroupExclusiveMul(node, context);\r\n            case \"subgroupInclusiveMul\":\r\n                return this.builtins.SubgroupInclusiveMul(node, context);\r\n            case \"subgroupOr\":\r\n                return this.builtins.SubgroupOr(node, context);\r\n            case \"subgroupShuffle\":\r\n                return this.builtins.SubgroupShuffle(node, context);\r\n            case \"subgroupShuffleDown\":\r\n                return this.builtins.SubgroupShuffleDown(node, context);\r\n            case \"subgroupShuffleUp\":\r\n                return this.builtins.SubgroupShuffleUp(node, context);\r\n            case \"subgroupShuffleXor\":\r\n                return this.builtins.SubgroupShuffleXor(node, context);\r\n            case \"subgroupXor\":\r\n                return this.builtins.SubgroupXor(node, context);\r\n\r\n            // Quad Operations\r\n            case \"quadBroadcast\":\r\n                return this.builtins.QuadBroadcast(node, context);\r\n            case \"quadSwapDiagonal\":\r\n                return this.builtins.QuadSwapDiagonal(node, context);\r\n            case \"quadSwapX\":\r\n                return this.builtins.QuadSwapX(node, context);\r\n            case \"quadSwapY\":\r\n                return this.builtins.QuadSwapY(node, context);\r\n        }\r\n\r\n        const f = context.getFunction(node.name);\r\n        if (f) {\r\n            const subContext = context.clone();\r\n            for (let ai = 0; ai < f.node.args.length; ++ai) {\r\n                const arg = f.node.args[ai];\r\n                const value = this.evalExpression(node.args[ai], subContext);\r\n                subContext.setVariable(arg.name, value, arg);\r\n            }\r\n            return this._execStatements(f.node.body, subContext);\r\n        }\r\n\r\n        //console.error(`Function ${node.name} not found. Line ${node.line}`);\r\n        return null;\r\n    }\r\n\r\n    _callConstructorValue(node: CreateExpr, context: ExecContext): Data | null {\r\n        if (!node.args || node.args.length === 0) {\r\n            return new ScalarData(0, this.getTypeInfo(node.type));\r\n        }\r\n        const v = this.evalExpression(node.args[0], context);\r\n        v.typeInfo = this.getTypeInfo(node.type);\r\n        return v.getSubData(this, node.postfix, context).clone();\r\n    }\r\n\r\n    _callConstructorVec(node: CreateExpr | LiteralExpr, context: ExecContext): Data | null {\r\n        const typeInfo = this.getTypeInfo(node.type);\r\n        const typeName = node.type.getTypeName();\r\n\r\n        const count = VectorTypeSize[typeName];\r\n        if (count === undefined) {\r\n            console.error(`Invalid vec constructor ${typeName}. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const values: number[] = [];\r\n        if (node instanceof LiteralExpr) {\r\n            if (node.isVector) {\r\n                const a = node.vectorValue;\r\n                for (const v of a) {\r\n                    values.push(v);\r\n                }\r\n            } else {\r\n                values.push(node.scalarValue);\r\n            }\r\n        } else {\r\n            if (node.args) {\r\n                for (const arg of node.args) {\r\n                    const argValue = this.evalExpression(arg, context) ;\r\n                    if (argValue instanceof VectorData) {\r\n                        const vd = argValue.data;\r\n                        for (let i = 0; i < vd.length; ++i) {\r\n                            let e = vd[i];\r\n                            values.push(e);\r\n                        }\r\n                    } else if (argValue instanceof ScalarData) {\r\n                        let v = argValue.value;\r\n                        values.push(v);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (node.type instanceof TemplateType && node.type.format === null) {\r\n            node.type.format = TemplateType.f32; // TODO: get the format from the type of the arg.\r\n        }\r\n\r\n        if (values.length === 0) {\r\n            const values = new Array(count).fill(0);\r\n            return new VectorData(values, typeInfo).getSubData(this, node.postfix, context);\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            while (values.length < count) {\r\n                values.push(values[0]);\r\n            }\r\n        }\r\n\r\n        if (values.length < count) {\r\n            console.error(`Invalid vec constructor. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const data = new VectorData(values.length > count ? values.slice(0, count) : values, typeInfo);\r\n        return data.getSubData(this, node.postfix, context);\r\n    }\r\n\r\n    _callConstructorMatrix(node: CreateExpr | LiteralExpr, context: ExecContext): Data | null {\r\n        const typeInfo = this.getTypeInfo(node.type);\r\n        const typeName = node.type.getTypeName();\r\n\r\n        const count = MatrixTypeSize[typeName];\r\n        if (count === undefined) {\r\n            console.error(`Invalid matrix constructor ${typeName}. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        const values = [];\r\n        if (node instanceof LiteralExpr) {\r\n            if (node.isVector) {\r\n                const a = node.vectorValue;\r\n                for (const v of a) {\r\n                    values.push(v);\r\n                }\r\n            } else {\r\n                values.push(node.scalarValue);\r\n            }\r\n        } else {\r\n            if (node.args) {\r\n                for (const arg of node.args) {\r\n                    const argValue = this.evalExpression(arg, context) ;\r\n                    if (argValue instanceof VectorData) {\r\n                        values.push(...argValue.data);\r\n                    } else if (argValue instanceof ScalarData) {\r\n                        values.push(argValue.value);\r\n                    } else if (argValue instanceof MatrixData) {\r\n                        values.push(...argValue.data);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((typeInfo instanceof TemplateInfo) && typeInfo.format === null) {\r\n            typeInfo.format = this.getTypeInfo(\"f32\");\r\n        }\r\n\r\n        if (values.length === 0) {\r\n            const values = new Array(count[2]).fill(0);\r\n            return new MatrixData(values, typeInfo).getSubData(this, node.postfix, context);\r\n        }\r\n\r\n        if (values.length !== count[2]) {\r\n            console.error(`Invalid matrix constructor. Line ${node.line}`);\r\n            return null;\r\n        }\r\n\r\n        return new MatrixData(values, typeInfo).getSubData(this, node.postfix, context);\r\n    }\r\n}\r\n","import { Const, Alias, Struct } from \"../wgsl_ast.js\";\r\n\r\nexport class ParseContext {\r\n  constants: Map<string, Const> = new Map();\r\n  aliases: Map<string, Alias> = new Map();\r\n  structs: Map<string, Struct> = new Map();\r\n}\r\n","import { WgslScanner, Token, TokenType, TokenTypes } from \"./wgsl_scanner.js\";\r\nimport * as AST from \"./wgsl_ast.js\";\r\nimport { WgslExec } from \"./wgsl_exec.js\";\r\nimport { TemplateInfo } from \"./reflect/info.js\";\r\nimport { ScalarData } from \"./wgsl_ast.js\";\r\nimport { ParseContext } from \"./ast/parse_context.js\";\r\n\r\n/// Parse a sequence of tokens from the WgslScanner into an Abstract Syntax Tree (AST).\r\nexport class WgslParser {\r\n  _tokens: Token[] = [];\r\n  _current: number = 0;\r\n  _currentLine: number = 1;\r\n  _deferArrayCountEval: Object[] = [];\r\n  _currentLoop: AST.Statement[] = [];\r\n  _context = new ParseContext();\r\n  _exec = new WgslExec();\r\n  _forwardTypeCount: number = 0;;\r\n\r\n  parse(tokensOrCode: Token[] | string): AST.Statement[] {\r\n    this._initialize(tokensOrCode);\r\n\r\n    this._deferArrayCountEval.length = 0;\r\n\r\n    const statements: AST.Statement[] = [];\r\n    while (!this._isAtEnd()) {\r\n      const statement = this._global_decl_or_directive();\r\n      if (!statement) {\r\n        break;\r\n      }\r\n      statements.push(statement);\r\n    }\r\n\r\n    // Since constants can be declared after they are used, and\r\n    // constants can be used to size arrays, defer calculating the\r\n    // size until after the shader has finished parsing.\r\n    if (this._deferArrayCountEval.length > 0) {\r\n      for (const arrayDecl of this._deferArrayCountEval) {\r\n        const arrayType = arrayDecl[\"arrayType\"];\r\n        const countNode = arrayDecl[\"countNode\"];\r\n\r\n        if (countNode instanceof AST.VariableExpr) {\r\n          const variable = countNode as AST.VariableExpr;\r\n          const name = variable.name;\r\n          const constant = this._context.constants.get(name);\r\n          if (constant) {\r\n            try {\r\n              const count = constant.constEvaluate(this._exec);\r\n              arrayType.count = count;\r\n            } catch (e) {\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this._deferArrayCountEval.length = 0;\r\n    }\r\n\r\n    if (this._forwardTypeCount > 0) {\r\n      for (const statement of statements) {\r\n        statement.search((node) => {\r\n          if (node instanceof AST.Member) {\r\n            node.type = this._forwardType(node.type);\r\n          } else if (node instanceof AST.PointerType) {\r\n            node.type = this._forwardType(node.type);\r\n          } else if (node instanceof AST.ArrayType) {\r\n            node.format = this._forwardType(node.format);\r\n          } else if (node instanceof AST.Var || node instanceof AST.Let || node instanceof AST.Const) {\r\n            node.type = this._forwardType(node.type);\r\n          } else if (node instanceof AST.Function) {\r\n            node.returnType = this._forwardType(node.returnType);\r\n          } else if (node instanceof AST.Argument) {\r\n            node.type = this._forwardType(node.type);\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    return statements;\r\n  }\r\n\r\n  _forwardType(t: AST.Type | null): AST.Type | null {\r\n    if (t instanceof AST.ForwardType) {\r\n      const ft = this._getType(t.name);\r\n      if (ft) {\r\n        return ft;\r\n      }\r\n    } else if (t instanceof AST.PointerType) {\r\n      t.type = this._forwardType(t.type);\r\n    } else if (t instanceof AST.ArrayType) {\r\n      t.format = this._forwardType(t.format);\r\n    }\r\n    return t;\r\n  }\r\n\r\n  _initialize(tokensOrCode: Token[] | string) {\r\n    if (tokensOrCode) {\r\n      if (typeof tokensOrCode == \"string\") {\r\n        const scanner = new WgslScanner(tokensOrCode);\r\n        this._tokens = scanner.scanTokens();\r\n      } else {\r\n        this._tokens = tokensOrCode;\r\n      }\r\n    } else {\r\n      this._tokens = [];\r\n    }\r\n    this._current = 0;\r\n  }\r\n\r\n  _updateNode<T extends AST.Node>(n: T, l?: number): T {\r\n    n.line = l ?? this._currentLine;\r\n    return n;\r\n  }\r\n\r\n  _error(token: Token, message: string | null): Object {\r\n    return {\r\n      token,\r\n      message,\r\n      toString: function () {\r\n        return `${message}`;\r\n      },\r\n    };\r\n  }\r\n\r\n  _isAtEnd(): boolean {\r\n    return (\r\n      this._current >= this._tokens.length ||\r\n      this._peek().type == TokenTypes.eof\r\n    );\r\n  }\r\n\r\n  _match(types: TokenType | TokenType[]): boolean {\r\n    if (types instanceof TokenType) {\r\n      if (this._check(types)) {\r\n        this._advance();\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0, l = types.length; i < l; ++i) {\r\n      const type = types[i];\r\n      if (this._check(type)) {\r\n        this._advance();\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _consume(types: TokenType | TokenType[], message: string | null): Token {\r\n    if (this._check(types)) {\r\n      return this._advance();\r\n    }\r\n    throw this._error(this._peek(), `${message}. Line:${this._currentLine}`);\r\n  }\r\n\r\n  _check(types: TokenType | TokenType[]): boolean {\r\n    if (this._isAtEnd()) {\r\n      return false;\r\n    }\r\n    const tk = this._peek();\r\n    if (types instanceof Array) {\r\n      const t = tk.type;\r\n      let hasNameType = false;\r\n      for (const type of types) {\r\n        if (t === type) {\r\n          return true;\r\n        }\r\n        if (type === TokenTypes.tokens.name) {\r\n          hasNameType =  true;\r\n        }\r\n      }\r\n      if (hasNameType) {\r\n        // ident can include any of the other keywords, so special case it.\r\n        const match = (TokenTypes.tokens.name.rule as RegExp).exec(tk.lexeme);\r\n        if (match && match.index == 0 && match[0] == tk.lexeme) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    if (tk.type === types) {\r\n      return true;\r\n    }\r\n\r\n    // ident can include any of the other keywords, so special case it.\r\n    if (types === TokenTypes.tokens.name) {\r\n      const match = (TokenTypes.tokens.name.rule as RegExp).exec(tk.lexeme);\r\n      return match && match.index == 0 && match[0] == tk.lexeme;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _advance(): Token {\r\n    this._currentLine = this._peek()?.line ?? -1;\r\n    if (!this._isAtEnd()) {\r\n      this._current++;\r\n    }\r\n    return this._previous();\r\n  }\r\n\r\n  _peek(): Token {\r\n    return this._tokens[this._current];\r\n  }\r\n\r\n  _previous(): Token {\r\n    return this._tokens[this._current - 1];\r\n  }\r\n\r\n  _global_decl_or_directive(): AST.Statement | null {\r\n    // semicolon\r\n    // global_variable_decl semicolon\r\n    // global_constant_decl semicolon\r\n    // type_alias semicolon\r\n    // struct_decl\r\n    // function_decl\r\n    // enable_directive\r\n\r\n    // Ignore any stand-alone semicolons\r\n    while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd());\r\n\r\n    if (this._match(TokenTypes.keywords.alias)) {\r\n      const type = this._type_alias();\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      this._exec.reflection.updateAST([type]);\r\n      return type;\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.diagnostic)) {\r\n      const directive = this._diagnostic();\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      this._exec.reflection.updateAST([directive]);\r\n      return directive;\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.requires)) {\r\n      const requires = this._requires_directive();\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      this._exec.reflection.updateAST([requires]);\r\n      return requires;\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.enable)) {\r\n      const enable = this._enable_directive();\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      this._exec.reflection.updateAST([enable]);\r\n      return enable;\r\n    }\r\n\r\n    // The following statements have an optional attribute*\r\n    const attrs = this._attribute();\r\n\r\n    if (this._check(TokenTypes.keywords.var)) {\r\n      const _var = this._global_variable_decl();\r\n      if (_var != null) {\r\n        _var.attributes = attrs;\r\n      }\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n      this._exec.reflection.updateAST([_var]);\r\n      return _var;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.override)) {\r\n      const _override = this._override_variable_decl();\r\n      if (_override != null) {\r\n        _override.attributes = attrs;\r\n      }\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n      this._exec.reflection.updateAST([_override]);\r\n      return _override;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.let)) {\r\n      const _let = this._global_let_decl();\r\n      if (_let != null) {\r\n        _let.attributes = attrs;\r\n      }\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n      this._exec.reflection.updateAST([_let]);\r\n      return _let;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.const)) {\r\n      const _const = this._global_const_decl();\r\n      if (_const != null) {\r\n        _const.attributes = attrs;\r\n      }\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n      this._exec.reflection.updateAST([_const]);\r\n      return _const;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.struct)) {\r\n      const _struct = this._struct_decl();\r\n      if (_struct != null) {\r\n        _struct.attributes = attrs;\r\n      }\r\n      this._exec.reflection.updateAST([_struct]);\r\n      return _struct;\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.fn)) {\r\n      const _fn = this._function_decl();\r\n      if (_fn != null) {\r\n        _fn.attributes = attrs;\r\n      }\r\n      this._exec.reflection.updateAST([_fn]);\r\n      return _fn;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _function_decl(): AST.Function | null {\r\n    // attribute* function_header compound_statement\r\n    // function_header: fn ident paren_left param_list? paren_right (arrow attribute* type_decl)?\r\n    if (!this._match(TokenTypes.keywords.fn)) {\r\n      return null;\r\n    }\r\n\r\n    const startLine = this._currentLine;\r\n\r\n    const name = this._consume(\r\n      TokenTypes.tokens.ident,\r\n      \"Expected function name.\"\r\n    ).toString();\r\n\r\n    this._consume(\r\n      TokenTypes.tokens.paren_left,\r\n      \"Expected '(' for function arguments.\"\r\n    );\r\n\r\n    const args: AST.Argument[] = [];\r\n    if (!this._check(TokenTypes.tokens.paren_right)) {\r\n      do {\r\n        if (this._check(TokenTypes.tokens.paren_right)) {\r\n          break;\r\n        }\r\n        const argAttrs = this._attribute();\r\n\r\n        const name = this._consume(\r\n          TokenTypes.tokens.name,\r\n          \"Expected argument name.\"\r\n        ).toString();\r\n\r\n        this._consume(\r\n          TokenTypes.tokens.colon,\r\n          \"Expected ':' for argument type.\"\r\n        );\r\n\r\n        const typeAttrs = this._attribute();\r\n        const type = this._type_decl();\r\n        if (type != null) {\r\n          type.attributes = typeAttrs;\r\n\r\n          args.push(this._updateNode(new AST.Argument(name, type, argAttrs)));\r\n        }\r\n      } while (this._match(TokenTypes.tokens.comma));\r\n    }\r\n\r\n    this._consume(\r\n      TokenTypes.tokens.paren_right,\r\n      \"Expected ')' after function arguments.\"\r\n    );\r\n\r\n    let _return: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.arrow)) {\r\n      const attrs = this._attribute();\r\n      _return = this._type_decl();\r\n      if (_return != null) {\r\n        _return.attributes = attrs;\r\n      }\r\n    }\r\n\r\n    const body = this._compound_statement();\r\n\r\n    const endLine = this._currentLine;\r\n\r\n    return this._updateNode(new AST.Function(name, args, _return, body, startLine, endLine), startLine);\r\n  }\r\n\r\n  _compound_statement(): AST.Statement[] {\r\n    // brace_left statement* brace_right\r\n    const statements: AST.Statement[] = [];\r\n\r\n    this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for block.\");\r\n    while (!this._check(TokenTypes.tokens.brace_right)) {\r\n      const statement = this._statement();\r\n      if (statement !== null) {\r\n        statements.push(statement as AST.Statement);\r\n      }\r\n    }\r\n    this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for block.\");\r\n\r\n    return statements;\r\n  }\r\n\r\n  _statement(): AST.Statement | AST.Statement[] | null {\r\n    // semicolon\r\n    // return_statement semicolon\r\n    // if_statement\r\n    // switch_statement\r\n    // loop_statement\r\n    // for_statement\r\n    // func_call_statement semicolon\r\n    // variable_statement semicolon\r\n    // break_statement semicolon\r\n    // continue_statement semicolon\r\n    // continuing_statement compound_statement\r\n    // discard semicolon\r\n    // assignment_statement semicolon\r\n    // compound_statement\r\n    // increment_statement semicolon\r\n    // decrement_statement semicolon\r\n    // static_assert_statement semicolon\r\n\r\n    // Ignore any stand-alone semicolons\r\n    while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd());\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.if)) {\r\n      return this._if_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.switch)) {\r\n      return this._switch_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.loop)) {\r\n      return this._loop_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.for)) {\r\n      return this._for_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.while)) {\r\n      return this._while_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.continuing)) {\r\n      return this._continuing_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.keywords.static_assert)) {\r\n      return this._static_assert_statement();\r\n    }\r\n\r\n    if (this._check(TokenTypes.tokens.brace_left)) {\r\n      return this._compound_statement();\r\n    }\r\n\r\n    let result: AST.Statement | null = null;\r\n    if (this._check(TokenTypes.keywords.return)) {\r\n      result = this._return_statement();\r\n    } else if (this._check([TokenTypes.keywords.var, TokenTypes.keywords.let, TokenTypes.keywords.const])) {\r\n      result = this._variable_statement();\r\n    } else if (this._match(TokenTypes.keywords.discard)) {\r\n      result = this._updateNode(new AST.Discard());\r\n    } else if (this._match(TokenTypes.keywords.break)) {\r\n      const breakStmt = this._updateNode(new AST.Break());\r\n      if (this._currentLoop.length > 0) {\r\n        const loop = this._currentLoop[this._currentLoop.length - 1];\r\n        breakStmt.loopId = loop.id;\r\n      } else {\r\n        // This break statement is not inside a loop.\r\n        //throw this._error(this._peek(), `Break statement must be inside a loop. Line: ${breakStmt.line}`);\r\n      }\r\n      result = breakStmt;\r\n      if (this._check(TokenTypes.keywords.if)) {\r\n        // break-if\r\n        this._advance();\r\n        breakStmt.condition = this._optional_paren_expression();\r\n      }\r\n    } else if (this._match(TokenTypes.keywords.continue)) {\r\n      const continueStmt = this._updateNode(new AST.Continue());\r\n      if (this._currentLoop.length > 0) {\r\n        const loop = this._currentLoop[this._currentLoop.length - 1];\r\n        continueStmt.loopId = loop.id;\r\n      } else {\r\n        // This continue statement is not inside a loop.\r\n        throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${continueStmt.line}`);\r\n      }\r\n      result = continueStmt;\r\n    } else {\r\n      result =\r\n        this._increment_decrement_statement() ||\r\n        this._func_call_statement() ||\r\n        this._assignment_statement();\r\n    }\r\n\r\n    if (result != null) {\r\n      this._consume(\r\n        TokenTypes.tokens.semicolon,\r\n        \"Expected ';' after statement.\"\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  _static_assert_statement(): AST.StaticAssert | null {\r\n    if (!this._match(TokenTypes.keywords.static_assert)) {\r\n      return null;\r\n    }\r\n    const line = this._currentLine;\r\n    const expression = this._optional_paren_expression();\r\n    return this._updateNode(new AST.StaticAssert(expression), line);\r\n  }\r\n\r\n  _while_statement(): AST.While | null {\r\n    if (!this._match(TokenTypes.keywords.while)) {\r\n      return null;\r\n    }\r\n\r\n    const whileLoop = this._updateNode(new AST.While(null, null));\r\n    this._currentLoop.push(whileLoop);\r\n\r\n    whileLoop.condition = this._optional_paren_expression();\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    whileLoop.body = this._compound_statement();\r\n\r\n    this._currentLoop.pop();\r\n\r\n    return whileLoop;\r\n  }\r\n\r\n  _continuing_statement(): AST.Continuing | null {\r\n    const loopId = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;\r\n    if (!this._match(TokenTypes.keywords.continuing)) {\r\n      return null;\r\n    }\r\n    const line = this._currentLine;\r\n    const block = this._compound_statement();\r\n    return this._updateNode(new AST.Continuing(block, loopId), line);\r\n  }\r\n\r\n  _for_statement(): AST.For | null {\r\n    // for paren_left for_header paren_right compound_statement\r\n    if (!this._match(TokenTypes.keywords.for)) {\r\n      return null;\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\r\n\r\n    const forLoop = this._updateNode(new AST.For(null, null, null, null));\r\n\r\n    this._currentLoop.push(forLoop);\r\n\r\n    // for_header: (variable_statement assignment_statement func_call_statement)? semicolon short_circuit_or_expression? semicolon (assignment_statement func_call_statement)?\r\n    forLoop.init = !this._check(TokenTypes.tokens.semicolon)\r\n      ? this._for_init()\r\n      : null;\r\n    this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n    forLoop.condition = !this._check(TokenTypes.tokens.semicolon)\r\n      ? this._short_circuit_or_expression()\r\n      : null;\r\n    this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\r\n    forLoop.increment = !this._check(TokenTypes.tokens.paren_right)\r\n      ? this._for_increment()\r\n      : null;\r\n\r\n    this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    forLoop.body = this._compound_statement();\r\n\r\n    this._currentLoop.pop();\r\n\r\n    return forLoop;\r\n  }\r\n\r\n  _for_init(): AST.Statement | null {\r\n    // (variable_statement assignment_statement func_call_statement)?\r\n    return (\r\n      this._variable_statement() ||\r\n      this._func_call_statement() ||\r\n      this._assignment_statement()\r\n    );\r\n  }\r\n\r\n  _for_increment(): AST.Statement | null {\r\n    // (assignment_statement func_call_statement increment_statement)?\r\n    return (\r\n      this._func_call_statement() ||\r\n      this._increment_decrement_statement() ||\r\n      this._assignment_statement()\r\n    );\r\n  }\r\n\r\n  _variable_statement(): AST.Var | AST.Let | AST.Const | null {\r\n    // variable_decl\r\n    // variable_decl equal short_circuit_or_expression\r\n    // let (ident variable_ident_decl) equal short_circuit_or_expression\r\n    // const (ident variable_ident_decl) equal short_circuit_or_expression\r\n    if (this._check(TokenTypes.keywords.var)) {\r\n      const _var = this._variable_decl();\r\n      if (_var === null) {\r\n        throw this._error(this._peek(), \"Variable declaration expected.\");\r\n      }\r\n      let value: AST.Expression | null = null;\r\n      if (this._match(TokenTypes.tokens.equal)) {\r\n        value = this._short_circuit_or_expression();\r\n      }\r\n\r\n      return this._updateNode(new AST.Var(\r\n        _var.name,\r\n        _var.type,\r\n        _var.storage,\r\n        _var.access,\r\n        value\r\n      ), _var.line);\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.let)) {\r\n      const line = this._currentLine;\r\n      const name = this._consume(\r\n        TokenTypes.tokens.name,\r\n        \"Expected name for let.\"\r\n      ).toString();\r\n      let type: AST.Type | null = null;\r\n      if (this._match(TokenTypes.tokens.colon)) {\r\n        const typeAttrs = this._attribute();\r\n        type = this._type_decl();\r\n        if (type != null) {\r\n          type.attributes = typeAttrs;\r\n        }\r\n      }\r\n      this._consume(TokenTypes.tokens.equal, \"Expected '=' for let.\");\r\n      const value = this._short_circuit_or_expression();\r\n      return this._updateNode(new AST.Let(name, type, null, null, value), line);\r\n    }\r\n\r\n    if (this._match(TokenTypes.keywords.const)) {\r\n      const line = this._currentLine;\r\n      const name = this._consume(\r\n        TokenTypes.tokens.name,\r\n        \"Expected name for const.\"\r\n      ).toString();\r\n      let type: AST.Type | null = null;\r\n      if (this._match(TokenTypes.tokens.colon)) {\r\n        const typeAttrs = this._attribute();\r\n        type = this._type_decl();\r\n        if (type != null) {\r\n          type.attributes = typeAttrs;\r\n        }\r\n      }\r\n      this._consume(TokenTypes.tokens.equal, \"Expected '=' for const.\");\r\n      const value = this._short_circuit_or_expression();\r\n      if (type === null && value instanceof AST.LiteralExpr) {\r\n        type = value.type;\r\n      }\r\n      return this._updateNode(new AST.Const(name, type, null, null, value), line);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _increment_decrement_statement(): AST.Statement | null {\r\n    const savedPos = this._current;\r\n\r\n    const _var = this._unary_expression();\r\n    if (_var == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!this._check(TokenTypes.increment_operators)) {\r\n      this._current = savedPos;\r\n      return null;\r\n    }\r\n\r\n    const token = this._consume(\r\n      TokenTypes.increment_operators,\r\n      \"Expected increment operator\"\r\n    );\r\n\r\n    return this._updateNode(new AST.Increment(\r\n      token.type === TokenTypes.tokens.plus_plus\r\n        ? AST.IncrementOperator.increment\r\n        : AST.IncrementOperator.decrement,\r\n      _var));\r\n  }\r\n\r\n  _assignment_statement(): AST.Assign | null {\r\n    // (unary_expression underscore) equal short_circuit_or_expression\r\n    let _var: AST.Expression | null = null;\r\n    const line = this._currentLine;\r\n\r\n    if (this._check(TokenTypes.tokens.brace_right)) {\r\n      return null;\r\n    }\r\n\r\n    let isUnderscore = this._match(TokenTypes.tokens.underscore);\r\n    if (!isUnderscore) {\r\n      _var = this._unary_expression();\r\n    }\r\n\r\n    if (!isUnderscore && _var == null) {\r\n      return null;\r\n    }\r\n\r\n    const type = this._consume(\r\n      TokenTypes.assignment_operators,\r\n      \"Expected assignment operator.\");\r\n\r\n    const value = this._short_circuit_or_expression();\r\n\r\n    return this._updateNode(new AST.Assign(\r\n      AST.AssignOperator.parse(type.lexeme),\r\n      _var as AST.Expression,\r\n      value), line);\r\n  }\r\n\r\n  _func_call_statement(): AST.Call | null {\r\n    // ident argument_expression_list\r\n    if (!this._check(TokenTypes.tokens.ident)) {\r\n      return null;\r\n    }\r\n\r\n    const line = this._currentLine;\r\n\r\n    const savedPos = this._current;\r\n    const name = this._consume(\r\n      TokenTypes.tokens.ident,\r\n      \"Expected function name.\"\r\n    );\r\n    const args = this._argument_expression_list();\r\n\r\n    if (args === null) {\r\n      this._current = savedPos;\r\n      return null;\r\n    }\r\n\r\n    return this._updateNode(new AST.Call(name.lexeme, args), line);\r\n  }\r\n\r\n  _loop_statement(): AST.Loop | null {\r\n    // loop brace_left statement* continuing_statement? brace_right\r\n    if (!this._match(TokenTypes.keywords.loop)) {\r\n      return null;\r\n    }\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for loop.\");\r\n\r\n    const loop = this._updateNode(new AST.Loop([], null));\r\n    this._currentLoop.push(loop);\r\n\r\n    // statement*\r\n    let statement = this._statement();\r\n    while (statement !== null) {\r\n      if (Array.isArray(statement)) {\r\n        for (let s of statement) {\r\n          loop.body.push(s);\r\n        }\r\n      } else {\r\n        loop.body.push(statement);\r\n      }\r\n      // Keep continuing in the loop body statements so it can be\r\n      // executed in the stackframe of the body statements.\r\n      if (statement instanceof AST.Continuing) {\r\n        loop.continuing = statement;\r\n        // Continuing should be the last statement in the loop.\r\n        break;\r\n      }\r\n      statement = this._statement();\r\n    }\r\n\r\n    this._currentLoop.pop();\r\n\r\n    this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for loop.\");\r\n\r\n    return loop;\r\n  }\r\n\r\n  _switch_statement(): AST.Switch | null {\r\n    // switch optional_paren_expression brace_left switch_body+ brace_right\r\n    if (!this._match(TokenTypes.keywords.switch)) {\r\n      return null;\r\n    }\r\n\r\n    const switchStmt = this._updateNode(new AST.Switch(null, []));\r\n\r\n    this._currentLoop.push(switchStmt);\r\n\r\n    switchStmt.condition = this._optional_paren_expression();\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for switch.\");\r\n    switchStmt.cases = this._switch_body();\r\n    if (switchStmt.cases == null || switchStmt.cases.length == 0) {\r\n      throw this._error(this._previous(), \"Expected 'case' or 'default'.\");\r\n    }\r\n    this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for switch.\");\r\n\r\n    this._currentLoop.pop();\r\n\r\n    return switchStmt;\r\n  }\r\n\r\n  _switch_body(): AST.SwitchCase[] {\r\n    // case case_selectors optional_colon brace_left case_body? brace_right\r\n    // default optional_colon brace_left case_body? brace_right\r\n    const cases: AST.SwitchCase[] = [];\r\n\r\n    let hasDefault = false;\r\n    while (this._check([TokenTypes.keywords.default, TokenTypes.keywords.case])) {\r\n      if (this._match(TokenTypes.keywords.case)) {\r\n        const selectors = this._case_selectors();\r\n        for (const selector of selectors) {\r\n          if (selector instanceof AST.DefaultSelector) {\r\n            if (hasDefault) {\r\n              throw this._error(this._previous(), \"Multiple default cases in switch statement.\");\r\n            }\r\n            hasDefault = true;\r\n            break;\r\n          }\r\n        }\r\n\r\n        this._match(TokenTypes.tokens.colon); // colon is optional\r\n\r\n        let attributes = null;\r\n        if (this._check(TokenTypes.tokens.attr)) {\r\n          attributes = this._attribute();\r\n        }\r\n\r\n        this._consume(TokenTypes.tokens.brace_left, \"Exected '{' for switch case.\");\r\n\r\n        const body = this._case_body();\r\n\r\n        this._consume(TokenTypes.tokens.brace_right, \"Exected '}' for switch case.\");\r\n\r\n        cases.push(this._updateNode(new AST.Case(selectors, body)));\r\n      }\r\n\r\n      if (this._match(TokenTypes.keywords.default)) {\r\n        if (hasDefault) {\r\n          throw this._error(this._previous(), \"Multiple default cases in switch statement.\");\r\n        }\r\n        this._match(TokenTypes.tokens.colon); // colon is optional\r\n\r\n        let attributes = null;\r\n        if (this._check(TokenTypes.tokens.attr)) {\r\n          attributes = this._attribute();\r\n        }\r\n\r\n        this._consume(TokenTypes.tokens.brace_left, \"Exected '{' for switch default.\");\r\n\r\n        const body = this._case_body();\r\n\r\n        this._consume(TokenTypes.tokens.brace_right, \"Exected '}' for switch default.\");\r\n\r\n        cases.push(this._updateNode(new AST.Default(body)));\r\n      }\r\n    }\r\n\r\n    return cases;\r\n  }\r\n\r\n  _case_selectors(): AST.Expression[] {\r\n    // case_selector (comma case_selector)* comma?\r\n    // case_selector: expression | default\r\n    const selectors = [];\r\n\r\n    if (this._match(TokenTypes.keywords.default)) {\r\n      selectors.push(this._updateNode(new AST.DefaultSelector()));\r\n    } else {\r\n      selectors.push(this._shift_expression());\r\n    }\r\n\r\n    while (this._match(TokenTypes.tokens.comma)) {\r\n      if (this._match(TokenTypes.keywords.default)) {\r\n        selectors.push(this._updateNode(new AST.DefaultSelector()));\r\n      } else {\r\n        selectors.push(this._shift_expression());\r\n      }\r\n    }\r\n\r\n    return selectors;\r\n  }\r\n\r\n  _case_body(): AST.Statement[] {\r\n    // statement case_body?\r\n    // fallthrough semicolon\r\n    if (this._match(TokenTypes.keywords.fallthrough)) {\r\n      this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\r\n      return [];\r\n    }\r\n\r\n    let statement = this._statement();\r\n    if (statement == null) {\r\n      return [];\r\n    }\r\n\r\n    if (!(statement instanceof Array)) {\r\n      statement = [statement];\r\n    }\r\n\r\n    const nextStatement = this._case_body();\r\n    if (nextStatement.length == 0) {\r\n      return statement;\r\n    }\r\n\r\n    return [...statement, nextStatement[0]];\r\n  }\r\n\r\n  _if_statement(): AST.If | null {\r\n    // if optional_paren_expression compound_statement elseif_statement? else_statement?\r\n    if (!this._match(TokenTypes.keywords.if)) {\r\n      return null;\r\n    }\r\n\r\n    const line = this._currentLine;\r\n\r\n    const condition = this._optional_paren_expression();\r\n\r\n    let attributes = null;\r\n    if (this._check(TokenTypes.tokens.attr)) {\r\n      attributes = this._attribute();\r\n    }\r\n\r\n    const block = this._compound_statement();\r\n\r\n    let elseif: AST.ElseIf[] | null = [];\r\n    if (this._match_elseif()) {\r\n      let attributes = null;\r\n      if (this._check(TokenTypes.tokens.attr)) {\r\n        attributes = this._attribute();\r\n      }\r\n      elseif = this._elseif_statement(elseif);\r\n    }\r\n\r\n    let _else: AST.Statement[] | null = null;\r\n    if (this._match(TokenTypes.keywords.else)) {\r\n      let attributes = null;\r\n      if (this._check(TokenTypes.tokens.attr)) {\r\n        attributes = this._attribute();\r\n      }\r\n      _else = this._compound_statement();\r\n    }\r\n\r\n    return this._updateNode(new AST.If(condition, block, elseif, _else), line);\r\n  }\r\n\r\n  _match_elseif(): boolean {\r\n    if (this._tokens[this._current].type === TokenTypes.keywords.else &&\r\n      this._tokens[this._current + 1].type === TokenTypes.keywords.if) {\r\n      this._advance();\r\n      this._advance();\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _elseif_statement(elseif: AST.ElseIf[] = []): AST.ElseIf[] {\r\n    // else_if optional_paren_expression compound_statement elseif_statement?\r\n    const condition = this._optional_paren_expression();\r\n    const block = this._compound_statement();\r\n    elseif.push(this._updateNode(new AST.ElseIf(condition, block)));\r\n    if (this._match_elseif()) {\r\n      let attributes = null;\r\n      if (this._check(TokenTypes.tokens.attr)) {\r\n        attributes = this._attribute();\r\n      }\r\n      this._elseif_statement(elseif);\r\n    }\r\n    return elseif;\r\n  }\r\n\r\n  _return_statement(): AST.Return | null {\r\n    // return short_circuit_or_expression?\r\n    if (!this._match(TokenTypes.keywords.return)) {\r\n      return null;\r\n    }\r\n    const value = this._short_circuit_or_expression();\r\n    return this._updateNode(new AST.Return(value));\r\n  }\r\n\r\n  _short_circuit_or_expression(): AST.Expression {\r\n    // short_circuit_and_expression\r\n    // short_circuit_or_expression or_or short_circuit_and_expression\r\n    let expr = this._short_circuit_and_expr();\r\n    while (this._match(TokenTypes.tokens.or_or)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._short_circuit_and_expr()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _short_circuit_and_expr(): AST.Expression {\r\n    // inclusive_or_expression\r\n    // short_circuit_and_expression and_and inclusive_or_expression\r\n    let expr = this._inclusive_or_expression();\r\n    while (this._match(TokenTypes.tokens.and_and)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._inclusive_or_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _inclusive_or_expression(): AST.Expression {\r\n    // exclusive_or_expression\r\n    // inclusive_or_expression or exclusive_or_expression\r\n    let expr = this._exclusive_or_expression();\r\n    while (this._match(TokenTypes.tokens.or)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._exclusive_or_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _exclusive_or_expression(): AST.Expression {\r\n    // and_expression\r\n    // exclusive_or_expression xor and_expression\r\n    let expr = this._and_expression();\r\n    while (this._match(TokenTypes.tokens.xor)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._and_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _and_expression(): AST.Expression {\r\n    // equality_expression\r\n    // and_expression and equality_expression\r\n    let expr = this._equality_expression();\r\n    while (this._match(TokenTypes.tokens.and)) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._equality_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _equality_expression(): AST.Expression {\r\n    // relational_expression\r\n    // relational_expression equal_equal relational_expression\r\n    // relational_expression not_equal relational_expression\r\n    const expr = this._relational_expression();\r\n    if (this._match([TokenTypes.tokens.equal_equal, TokenTypes.tokens.not_equal])) {\r\n      return this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._relational_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _relational_expression(): AST.Expression {\r\n    // shift_expression\r\n    // relational_expression less_than shift_expression\r\n    // relational_expression greater_than shift_expression\r\n    // relational_expression less_than_equal shift_expression\r\n    // relational_expression greater_than_equal shift_expression\r\n    let expr = this._shift_expression();\r\n    while (this._match([\r\n        TokenTypes.tokens.less_than,\r\n        TokenTypes.tokens.greater_than,\r\n        TokenTypes.tokens.less_than_equal,\r\n        TokenTypes.tokens.greater_than_equal,\r\n      ])) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._shift_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _shift_expression(): AST.Expression {\r\n    // additive_expression\r\n    // shift_expression shift_left additive_expression\r\n    // shift_expression shift_right additive_expression\r\n    let expr = this._additive_expression();\r\n    while (this._match([TokenTypes.tokens.shift_left, TokenTypes.tokens.shift_right])) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._additive_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _additive_expression(): AST.Expression {\r\n    // multiplicative_expression\r\n    // additive_expression plus multiplicative_expression\r\n    // additive_expression minus multiplicative_expression\r\n    let expr = this._multiplicative_expression();\r\n    while (this._match([TokenTypes.tokens.plus, TokenTypes.tokens.minus])) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._multiplicative_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _multiplicative_expression(): AST.Expression {\r\n    // unary_expression\r\n    // multiplicative_expression star unary_expression\r\n    // multiplicative_expression forward_slash unary_expression\r\n    // multiplicative_expression modulo unary_expression\r\n    let expr = this._unary_expression();\r\n    while (this._match([\r\n        TokenTypes.tokens.star,\r\n        TokenTypes.tokens.forward_slash,\r\n        TokenTypes.tokens.modulo,\r\n      ])) {\r\n      expr = this._updateNode(new AST.BinaryOperator(\r\n        this._previous().toString(),\r\n        expr,\r\n        this._unary_expression()\r\n      ));\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _unary_expression(): AST.Expression {\r\n    // singular_expression\r\n    // minus unary_expression\r\n    // bang unary_expression\r\n    // tilde unary_expression\r\n    // star unary_expression\r\n    // and unary_expression\r\n    if (this._match([\r\n        TokenTypes.tokens.minus,\r\n        TokenTypes.tokens.bang,\r\n        TokenTypes.tokens.tilde,\r\n        TokenTypes.tokens.star,\r\n        TokenTypes.tokens.and,\r\n      ])) {\r\n      return this._updateNode(new AST.UnaryOperator(\r\n        this._previous().toString(),\r\n        this._unary_expression()\r\n      ));\r\n    }\r\n    return this._singular_expression();\r\n  }\r\n\r\n  _singular_expression(): AST.Expression {\r\n    // primary_expression postfix_expression ?\r\n    const expr = this._primary_expression();\r\n    const p = this._postfix_expression();\r\n    if (p) {\r\n      expr.postfix = p;\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  _postfix_expression(): AST.Expression | null {\r\n    // bracket_left short_circuit_or_expression bracket_right postfix_expression?\r\n    if (this._match(TokenTypes.tokens.bracket_left)) {\r\n      const expr = this._short_circuit_or_expression();\r\n      this._consume(TokenTypes.tokens.bracket_right, \"Expected ']'.\");\r\n      const arrayIndex = this._updateNode(new AST.ArrayIndex(expr));\r\n      const p = this._postfix_expression();\r\n      if (p) {\r\n        arrayIndex.postfix = p;\r\n      }\r\n      return arrayIndex;\r\n    }\r\n\r\n    // period ident postfix_expression?\r\n    if (this._match(TokenTypes.tokens.period)) {\r\n      const name = this._consume(TokenTypes.tokens.name, \"Expected member name.\");\r\n      const p = this._postfix_expression();\r\n      const expr = this._updateNode(new AST.StringExpr(name.lexeme));\r\n      if (p) {\r\n        expr.postfix = p;\r\n      }\r\n      return expr;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _getStruct(name: string): AST.Type | null {\r\n    if (this._context.aliases.has(name)) {\r\n      const alias = this._context.aliases.get(name).type;\r\n      return alias;\r\n    }\r\n    if (this._context.structs.has(name)) {\r\n      const struct = this._context.structs.get(name);\r\n      return struct;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _getType(name: string): AST.Type {\r\n    const struct = this._getStruct(name);\r\n    if (struct !== null) {\r\n      return struct;\r\n    }\r\n    switch (name) {\r\n      case \"void\":\r\n        return AST.Type.void;\r\n      case \"bool\":\r\n        return AST.Type.bool;\r\n      case \"i32\":\r\n        return AST.Type.i32;\r\n      case \"u32\":\r\n        return AST.Type.u32;\r\n      case \"f32\":\r\n        return AST.Type.f32;\r\n      case \"f16\":\r\n        return AST.Type.f16;\r\n      case \"vec2f\":\r\n        return AST.TemplateType.vec2f;\r\n      case \"vec3f\":\r\n        return AST.TemplateType.vec3f;\r\n      case \"vec4f\":\r\n        return AST.TemplateType.vec4f;\r\n      case \"vec2i\":\r\n        return AST.TemplateType.vec2i;\r\n      case \"vec3i\":\r\n        return AST.TemplateType.vec3i;\r\n      case \"vec4i\":\r\n        return AST.TemplateType.vec4i;\r\n      case \"vec2u\":\r\n        return AST.TemplateType.vec2u;\r\n      case \"vec3u\":\r\n        return AST.TemplateType.vec3u;\r\n      case \"vec4u\":\r\n        return AST.TemplateType.vec4u;\r\n      case \"vec2h\":\r\n        return AST.TemplateType.vec2h;\r\n      case \"vec3h\":\r\n        return AST.TemplateType.vec3h;\r\n      case \"vec4h\":\r\n        return AST.TemplateType.vec4h;\r\n      case \"mat2x2f\":\r\n        return AST.TemplateType.mat2x2f;\r\n      case \"mat2x3f\":\r\n        return AST.TemplateType.mat2x3f;\r\n      case \"mat2x4f\":\r\n        return AST.TemplateType.mat2x4f;\r\n      case \"mat3x2f\":\r\n        return AST.TemplateType.mat3x2f;\r\n      case \"mat3x3f\":\r\n        return AST.TemplateType.mat3x3f;\r\n      case \"mat3x4f\":\r\n        return AST.TemplateType.mat3x4f;\r\n      case \"mat4x2f\":\r\n        return AST.TemplateType.mat4x2f;\r\n      case \"mat4x3f\":\r\n        return AST.TemplateType.mat4x3f;\r\n      case \"mat4x4f\":\r\n        return AST.TemplateType.mat4x4f;\r\n      case \"mat2x2h\":\r\n        return AST.TemplateType.mat2x2h;\r\n      case \"mat2x3h\":\r\n        return AST.TemplateType.mat2x3h;\r\n      case \"mat2x4h\":\r\n        return AST.TemplateType.mat2x4h;\r\n      case \"mat3x2h\":\r\n        return AST.TemplateType.mat3x2h;\r\n      case \"mat3x3h\":\r\n        return AST.TemplateType.mat3x3h;\r\n      case \"mat3x4h\":\r\n        return AST.TemplateType.mat3x4h;\r\n      case \"mat4x2h\":\r\n        return AST.TemplateType.mat4x2h;\r\n      case \"mat4x3h\":\r\n        return AST.TemplateType.mat4x3h;\r\n      case \"mat4x4h\":\r\n        return AST.TemplateType.mat4x4h;\r\n\r\n      case \"mat2x2i\":\r\n        return AST.TemplateType.mat2x2i;\r\n      case \"mat2x3i\":\r\n        return AST.TemplateType.mat2x3i;\r\n      case \"mat2x4i\":\r\n        return AST.TemplateType.mat2x4i;\r\n      case \"mat3x2i\":\r\n        return AST.TemplateType.mat3x2i;\r\n      case \"mat3x3i\":\r\n        return AST.TemplateType.mat3x3i;\r\n      case \"mat3x4i\":\r\n        return AST.TemplateType.mat3x4i;\r\n      case \"mat4x2i\":\r\n        return AST.TemplateType.mat4x2i;\r\n      case \"mat4x3i\":\r\n        return AST.TemplateType.mat4x3i;\r\n      case \"mat4x4i\":\r\n        return AST.TemplateType.mat4x4i;\r\n\r\n      case \"mat2x2u\":\r\n        return AST.TemplateType.mat2x2u;\r\n      case \"mat2x3u\":\r\n        return AST.TemplateType.mat2x3u;\r\n      case \"mat2x4u\":\r\n        return AST.TemplateType.mat2x4u;\r\n      case \"mat3x2u\":\r\n        return AST.TemplateType.mat3x2u;\r\n      case \"mat3x3u\":\r\n        return AST.TemplateType.mat3x3u;\r\n      case \"mat3x4u\":\r\n        return AST.TemplateType.mat3x4u;\r\n      case \"mat4x2u\":\r\n        return AST.TemplateType.mat4x2u;\r\n      case \"mat4x3u\":\r\n        return AST.TemplateType.mat4x3u;\r\n      case \"mat4x4u\":\r\n        return AST.TemplateType.mat4x4u;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _validateTypeRange(value: number, type: AST.Type) {\r\n    if (type.name === \"i32\") {\r\n      if (value < -2147483648 || value > 2147483647) {\r\n        throw this._error(this._previous(), `Value out of range for i32: ${value}. Line: ${this._currentLine}.`);\r\n      }\r\n    } else if (type.name === \"u32\") {\r\n      if (value < 0 || value > 4294967295) {\r\n        throw this._error(this._previous(), `Value out of range for u32: ${value}. Line: ${this._currentLine}.`);\r\n      }\r\n    }\r\n  }\r\n\r\n  _primary_expression(): AST.Expression {\r\n    // ident argument_expression_list?\r\n    if (this._match(TokenTypes.tokens.ident)) {\r\n      const name = this._previous().toString();\r\n      if (this._check(TokenTypes.tokens.paren_left)) {\r\n        const args = this._argument_expression_list();\r\n        const type = this._getType(name);\r\n        if (type !== null) {\r\n          return this._updateNode(new AST.CreateExpr(type, args));\r\n        }\r\n        return this._updateNode(new AST.CallExpr(name, args));\r\n      }\r\n      if (this._context.constants.has(name)) {\r\n        const c = this._context.constants.get(name);\r\n        return this._updateNode(new AST.ConstExpr(name, c.value));\r\n      }\r\n      return this._updateNode(new AST.VariableExpr(name));\r\n    }\r\n\r\n    // const_literal\r\n    if (this._match(TokenTypes.tokens.int_literal)) {\r\n      const s = this._previous().toString();\r\n      let type = s.endsWith(\"i\") || s.endsWith(\"i\") ? AST.Type.i32 :\r\n          s.endsWith(\"u\") || s.endsWith(\"U\") ? AST.Type.u32 : AST.Type.x32;\r\n      const i = parseInt(s);\r\n      this._validateTypeRange(i, type);\r\n      return this._updateNode(new AST.LiteralExpr(new ScalarData(i, this._exec.getTypeInfo(type)), type));\r\n    } else if (this._match(TokenTypes.tokens.uint_literal)) {\r\n      const u = parseInt(this._previous().toString());\r\n      this._validateTypeRange(u, AST.Type.u32);\r\n      return this._updateNode(new AST.LiteralExpr(new ScalarData(u, this._exec.getTypeInfo(AST.Type.u32)), AST.Type.u32));\r\n    } else if (this._match([TokenTypes.tokens.decimal_float_literal, TokenTypes.tokens.hex_float_literal])) {\r\n      let fs = this._previous().toString();\r\n      let isF16 = fs.endsWith(\"h\");\r\n      if (isF16) {\r\n        fs = fs.substring(0, fs.length - 1);\r\n      }\r\n      const f = parseFloat(fs);\r\n      this._validateTypeRange(f, isF16 ? AST.Type.f16 : AST.Type.f32);\r\n      const type = isF16 ? AST.Type.f16 : AST.Type.f32;\r\n      return this._updateNode(new AST.LiteralExpr(new ScalarData(f, this._exec.getTypeInfo(type)), type));\r\n    } else if (this._match([TokenTypes.keywords.true, TokenTypes.keywords.false])) {\r\n      let b = this._previous().toString() === TokenTypes.keywords.true.rule;\r\n      return this._updateNode(new AST.LiteralExpr(new ScalarData(b ? 1 : 0, this._exec.getTypeInfo(AST.Type.bool)), AST.Type.bool));\r\n    }\r\n\r\n    // paren_expression\r\n    if (this._check(TokenTypes.tokens.paren_left)) {\r\n      return this._paren_expression();\r\n    }\r\n\r\n    // bitcast less_than type_decl greater_than paren_expression\r\n    if (this._match(TokenTypes.keywords.bitcast)) {\r\n      this._consume(TokenTypes.tokens.less_than, \"Expected '<'.\");\r\n      const type = this._type_decl();\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>'.\");\r\n      const value = this._paren_expression();\r\n      return this._updateNode(new AST.BitcastExpr(type, value));\r\n    }\r\n\r\n    // type_decl argument_expression_list\r\n    const type = this._type_decl();\r\n    const args = this._argument_expression_list();\r\n    return this._updateNode(new AST.CreateExpr(type, args));\r\n  }\r\n\r\n  _argument_expression_list(): AST.Expression[] | null {\r\n    // paren_left ((short_circuit_or_expression comma)* short_circuit_or_expression comma?)? paren_right\r\n    if (!this._match(TokenTypes.tokens.paren_left)) {\r\n      return null;\r\n    }\r\n\r\n    const args: AST.Expression[] = [];\r\n    do {\r\n      if (this._check(TokenTypes.tokens.paren_right)) {\r\n        break;\r\n      }\r\n      const arg = this._short_circuit_or_expression();\r\n      args.push(arg);\r\n    } while (this._match(TokenTypes.tokens.comma));\r\n    this._consume(\r\n      TokenTypes.tokens.paren_right,\r\n      \"Expected ')' for argument list\"\r\n    );\r\n\r\n    return args;\r\n  }\r\n\r\n  _optional_paren_expression(): AST.Expression {\r\n    // [paren_left] short_circuit_or_expression [paren_right]\r\n    this._match(TokenTypes.tokens.paren_left);\r\n    const expr = this._short_circuit_or_expression();\r\n    this._match(TokenTypes.tokens.paren_right);\r\n    return expr;\r\n  }\r\n\r\n  _paren_expression(): AST.Expression {\r\n    // paren_left short_circuit_or_expression paren_right\r\n    this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\r\n    const expr = this._short_circuit_or_expression();\r\n    this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\r\n    return expr;\r\n  }\r\n\r\n  _struct_decl(): AST.Struct | null {\r\n    // attribute* struct ident struct_body_decl\r\n    if (!this._match(TokenTypes.keywords.struct)) {\r\n      return null;\r\n    }\r\n\r\n    const startLine = this._currentLine;\r\n\r\n    const name = this._consume(TokenTypes.tokens.ident, \"Expected name for struct.\").toString();\r\n\r\n    // struct_body_decl: brace_left (struct_member comma)* struct_member comma? brace_right\r\n    this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for struct body.\");\r\n    const members: AST.Member[] = [];\r\n    while (!this._check(TokenTypes.tokens.brace_right)) {\r\n      // struct_member: attribute* variable_ident_decl\r\n      const memberAttrs = this._attribute();\r\n\r\n      const memberName = this._consume(TokenTypes.tokens.name, \"Expected variable name.\").toString();\r\n\r\n      this._consume(TokenTypes.tokens.colon, \"Expected ':' for struct member type.\");\r\n\r\n      const typeAttrs = this._attribute();\r\n      const memberType = this._type_decl();\r\n      if (memberType != null) {\r\n        memberType.attributes = typeAttrs;\r\n      }\r\n\r\n      if (!this._check(TokenTypes.tokens.brace_right)) {\r\n        this._consume(TokenTypes.tokens.comma, \"Expected ',' for struct member.\");\r\n      } else {\r\n        this._match(TokenTypes.tokens.comma); // trailing comma optional.\r\n      }\r\n\r\n      members.push(this._updateNode(new AST.Member(memberName, memberType, memberAttrs)));\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.brace_right, \"Expected '}' after struct body.\");\r\n\r\n    const endLine = this._currentLine;\r\n\r\n    const structNode = this._updateNode(new AST.Struct(name, members, startLine, endLine), startLine);\r\n    this._context.structs.set(name, structNode);\r\n    return structNode;\r\n  }\r\n\r\n  _global_variable_decl(): AST.Var | null {\r\n    // attribute* variable_decl (equal const_expression)?\r\n    const _var = this._variable_decl();\r\n    if (!_var) {\r\n      return null;\r\n    }\r\n\r\n    if (this._match(TokenTypes.tokens.equal)) {\r\n      const expr = this._const_expression();\r\n      _var.value = expr;\r\n    }\r\n\r\n    if (_var.type !== null && _var.value instanceof AST.LiteralExpr) {\r\n      if (_var.value.type.name !== \"x32\") {\r\n        const t1 = _var.type.getTypeName();\r\n        const t2 = _var.value.type.getTypeName();\r\n        if (t1 !== t2) {\r\n          throw this._error(this._peek(), `Invalid cast from ${_var.value.type.name} to ${_var.type.name}. Line:${this._currentLine}`);\r\n        }\r\n      }\r\n      if (_var.value.isScalar) {\r\n        this._validateTypeRange(_var.value.scalarValue, _var.type);\r\n      }\r\n      _var.value.type = _var.type;\r\n    } else if (_var.type === null && _var.value instanceof AST.LiteralExpr) {\r\n      _var.type = _var.value.type.name === \"x32\" ? AST.Type.i32 : _var.value.type;\r\n      if (_var.value.isScalar) {\r\n        this._validateTypeRange(_var.value.scalarValue, _var.type);\r\n      }\r\n    }\r\n    return _var;\r\n  }\r\n\r\n  _override_variable_decl(): AST.Override | null {\r\n    // attribute* override_decl (equal const_expression)?\r\n    const _override = this._override_decl();\r\n    if (_override && this._match(TokenTypes.tokens.equal)) {\r\n      _override.value = this._const_expression();\r\n    }\r\n\r\n    return _override;\r\n  }\r\n\r\n  _global_const_decl(): AST.Const | null {\r\n    // attribute* const (ident variable_ident_decl) global_const_initializer?\r\n    if (!this._match(TokenTypes.keywords.const)) {\r\n      return null;\r\n    }\r\n\r\n    const name = this._consume(\r\n      TokenTypes.tokens.name,\r\n      \"Expected variable name\"\r\n    );\r\n\r\n    const line = this._currentLine;\r\n\r\n    let type: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.colon)) {\r\n      const attrs = this._attribute();\r\n      type = this._type_decl();\r\n      if (type != null) {\r\n        type.attributes = attrs;\r\n      }\r\n    }\r\n    let value: AST.Expression | null = null;\r\n\r\n    this._consume(TokenTypes.tokens.equal, \"const declarations require an assignment\")\r\n\r\n    const valueExpr = this._short_circuit_or_expression();\r\n    try {\r\n      let type = [AST.Type.f32];\r\n      let constValue = valueExpr.constEvaluate(this._exec, type);\r\n\r\n      if (constValue instanceof ScalarData) {\r\n        this._validateTypeRange(constValue.value, type[0]);\r\n      }\r\n\r\n      if (type[0] instanceof AST.TemplateType && type[0].format === null &&\r\n        constValue.typeInfo instanceof TemplateInfo && constValue.typeInfo.format !== null) {\r\n        if (constValue.typeInfo.format.name === \"f16\") {\r\n          type[0].format = AST.Type.f16;\r\n        } else if (constValue.typeInfo.format.name === \"f32\") {\r\n          type[0].format = AST.Type.f32;\r\n        } else if (constValue.typeInfo.format.name === \"i32\") {\r\n          type[0].format = AST.Type.i32;\r\n        } else if (constValue.typeInfo.format.name === \"u32\") {\r\n          type[0].format = AST.Type.u32;\r\n        } else if (constValue.typeInfo.format.name === \"bool\") {\r\n          type[0].format = AST.Type.bool;\r\n        } else {\r\n          console.error(`TODO: impelement template format type ${constValue.typeInfo.format.name}`);\r\n        }\r\n      }\r\n\r\n      value = this._updateNode(new AST.LiteralExpr(constValue, type[0]));\r\n      this._exec.context.setVariable(name.toString(), constValue);\r\n    } catch {\r\n      value = valueExpr;\r\n    }\r\n\r\n    if (type !== null && value instanceof AST.LiteralExpr) {\r\n      if (value.type.name !== \"x32\") {\r\n        const t1 = type.getTypeName();\r\n        const t2 = value.type.getTypeName();\r\n        if (t1 !== t2) {\r\n          throw this._error(this._peek(), `Invalid cast from ${value.type.name} to ${type.name}. Line:${this._currentLine}`);\r\n        }\r\n      }\r\n      value.type = type;\r\n      if (value.isScalar) {\r\n        this._validateTypeRange(value.scalarValue, value.type);\r\n      }\r\n    } else if (type === null && value instanceof AST.LiteralExpr) {\r\n      type = value?.type ?? AST.Type.f32;\r\n      if (type === AST.Type.x32) {\r\n        type = AST.Type.i32;\r\n      }\r\n    }\r\n\r\n    const c = this._updateNode(new AST.Const(name.toString(), type, \"\", \"\", value), line);\r\n    this._context.constants.set(c.name, c);\r\n    return c;\r\n  }\r\n\r\n  _global_let_decl(): AST.Let | null {\r\n    // attribute* let (ident variable_ident_decl) global_const_initializer?\r\n    if (!this._match(TokenTypes.keywords.let)) {\r\n      return null;\r\n    }\r\n\r\n    const line = this._currentLine;\r\n\r\n    const name = this._consume(\r\n      TokenTypes.tokens.name,\r\n      \"Expected variable name\"\r\n    );\r\n\r\n    let type: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.colon)) {\r\n      const attrs = this._attribute();\r\n      type = this._type_decl();\r\n      if (type != null) {\r\n        type.attributes = attrs;\r\n      }\r\n    }\r\n\r\n    let value: AST.Expression | null = null;\r\n    if (this._match(TokenTypes.tokens.equal)) {\r\n      value = this._const_expression();\r\n    }\r\n\r\n    if (type !== null && value instanceof AST.LiteralExpr) {\r\n      if (value.type.name !== \"x32\") {\r\n        const t1 = type.getTypeName();\r\n        const t2 = value.type.getTypeName();\r\n        if (t1 !== t2) {\r\n          throw this._error(this._peek(), `Invalid cast from ${value.type.name} to ${type.name}. Line:${this._currentLine}`);\r\n        }\r\n      }\r\n      value.type = type;\r\n    } else if (type === null && value instanceof AST.LiteralExpr) {\r\n      type = value.type.name === \"x32\" ? AST.Type.i32 : value.type;\r\n    }\r\n\r\n    if (value instanceof AST.LiteralExpr) {\r\n      if (value.isScalar) {\r\n        this._validateTypeRange(value.scalarValue, type);\r\n      }\r\n    }\r\n    return this._updateNode(new AST.Let(name.toString(), type, \"\", \"\", value), line);\r\n  }\r\n\r\n  _const_expression(): AST.Expression {\r\n    // type_decl paren_left ((const_expression comma)* const_expression comma?)? paren_right\r\n    // const_literal\r\n    return this._short_circuit_or_expression();\r\n  }\r\n\r\n  _variable_decl(): AST.Var | null {\r\n    // var variable_qualifier? (ident variable_ident_decl)\r\n    if (!this._match(TokenTypes.keywords.var)) {\r\n      return null;\r\n    }\r\n\r\n    const line = this._currentLine;\r\n\r\n    // variable_qualifier: less_than storage_class (comma access_mode)? greater_than\r\n    let storage: string = \"\";\r\n    let access: string = \"\";\r\n    if (this._match(TokenTypes.tokens.less_than)) {\r\n      storage = this._consume(TokenTypes.storage_class, \"Expected storage_class.\").toString();\r\n      if (this._match(TokenTypes.tokens.comma))\r\n        access = this._consume(TokenTypes.access_mode, \"Expected access_mode.\").toString();\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>'.\");\r\n    }\r\n\r\n    const name = this._consume(\r\n      TokenTypes.tokens.name,\r\n      \"Expected variable name\"\r\n    );\r\n\r\n    let type: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.colon)) {\r\n      const attrs = this._attribute();\r\n      type = this._type_decl();\r\n      if (type != null) {\r\n        type.attributes = attrs;\r\n      }\r\n    }\r\n\r\n    return this._updateNode(new AST.Var(name.toString(), type, storage, access, null), line);\r\n  }\r\n\r\n  _override_decl(): AST.Override | null {\r\n    // override (ident variable_ident_decl)\r\n    if (!this._match(TokenTypes.keywords.override)) {\r\n      return null;\r\n    }\r\n\r\n    const name = this._consume(TokenTypes.tokens.name, \"Expected variable name\");\r\n    let type: AST.Type | null = null;\r\n    if (this._match(TokenTypes.tokens.colon)) {\r\n      const attrs = this._attribute();\r\n      type = this._type_decl();\r\n      if (type != null) {\r\n        type.attributes = attrs;\r\n      }\r\n    }\r\n\r\n    return this._updateNode(new AST.Override(name.toString(), type, null));\r\n  }\r\n\r\n  _diagnostic(): AST.Diagnostic | null {\r\n    // diagnostic(severity_control_name, diagnostic_rule_name)\r\n    this._consume(TokenTypes.tokens.paren_left, \"Expected '('\");\r\n    const severity = this._consume(\r\n      TokenTypes.tokens.ident,\r\n      \"Expected severity control name.\"\r\n    );\r\n    this._consume(TokenTypes.tokens.comma, \"Expected ','\");\r\n    const rule = this._consume(\r\n      TokenTypes.tokens.ident,\r\n      \"Expected diagnostic rule name.\"\r\n    );\r\n    let ruleMessage = rule.toString();\r\n    if (this._match(TokenTypes.tokens.period)) {\r\n      const message = this._consume(\r\n        TokenTypes.tokens.ident,\r\n        \"Expected diagnostic message.\"\r\n      );\r\n      ruleMessage += `.${message.toString()}`;\r\n    }\r\n\r\n    this._consume(TokenTypes.tokens.paren_right, \"Expected ')'\");\r\n    return this._updateNode(new AST.Diagnostic(severity.toString(), ruleMessage));\r\n  }\r\n\r\n  _enable_directive(): AST.Enable {\r\n    // enable ident semicolon\r\n    const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\r\n    return this._updateNode(new AST.Enable(name.toString()));\r\n  }\r\n\r\n  _requires_directive(): AST.Requires {\r\n    // requires extension [, extension]* semicolon\r\n    const extensions: string[] = [this._consume(TokenTypes.tokens.ident, \"identity expected.\").toString()];\r\n    while (this._match(TokenTypes.tokens.comma)) {\r\n      const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\r\n      extensions.push(name.toString());\r\n    }\r\n    return this._updateNode(new AST.Requires(extensions));\r\n  }\r\n\r\n  _type_alias(): AST.Alias {\r\n    // type ident equal type_decl\r\n    const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\r\n    this._consume(TokenTypes.tokens.equal, \"Expected '=' for type alias.\");\r\n\r\n    let aliasType = this._type_decl();\r\n    if (aliasType === null) {\r\n      throw this._error(this._peek(), \"Expected Type for Alias.\");\r\n    }\r\n    if (this._context.aliases.has(aliasType.name)) {\r\n      aliasType = this._context.aliases.get(aliasType.name).type;\r\n    }\r\n\r\n    const aliasNode = this._updateNode(new AST.Alias(name.toString(), aliasType));\r\n    this._context.aliases.set(aliasNode.name, aliasNode);\r\n\r\n    return aliasNode;\r\n  }\r\n\r\n  _type_decl(): AST.Type | null {\r\n    // ident\r\n    // bool\r\n    // float32\r\n    // int32\r\n    // uint32\r\n    // vec2 less_than type_decl greater_than\r\n    // vec3 less_than type_decl greater_than\r\n    // vec4 less_than type_decl greater_than\r\n    // mat2x2 less_than type_decl greater_than\r\n    // mat2x3 less_than type_decl greater_than\r\n    // mat2x4 less_than type_decl greater_than\r\n    // mat3x2 less_than type_decl greater_than\r\n    // mat3x3 less_than type_decl greater_than\r\n    // mat3x4 less_than type_decl greater_than\r\n    // mat4x2 less_than type_decl greater_than\r\n    // mat4x3 less_than type_decl greater_than\r\n    // mat4x4 less_than type_decl greater_than\r\n    // atomic less_than type_decl greater_than\r\n    // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n    // array_type_decl\r\n    // texture_sampler_types\r\n\r\n    if (this._check([\r\n        TokenTypes.tokens.ident,\r\n        ...TokenTypes.texel_format,\r\n        TokenTypes.keywords.bool,\r\n        TokenTypes.keywords.f32,\r\n        TokenTypes.keywords.i32,\r\n        TokenTypes.keywords.u32,\r\n      ])) {\r\n      const type = this._advance();\r\n      const typeName = type.toString();\r\n      if (this._context.structs.has(typeName)) {\r\n        return this._context.structs.get(typeName);\r\n      }\r\n      if (this._context.aliases.has(typeName)) {\r\n        return this._context.aliases.get(typeName).type;\r\n      }\r\n\r\n      const t = this._getType(typeName);\r\n      // Don't \"forward declare\" built-in types\r\n      if (!t) {\r\n        const node = this._updateNode(new AST.ForwardType(typeName));\r\n        this._forwardTypeCount++;\r\n        return node;\r\n      }\r\n\r\n      return this._updateNode(new AST.Type(typeName));\r\n    }\r\n\r\n    // texture_sampler_types\r\n    let type = this._texture_sampler_types();\r\n    if (type) {\r\n      return type;\r\n    }\r\n\r\n    if (this._check(TokenTypes.template_types)) {\r\n      let type = this._advance().toString();\r\n      let format: AST.Type | null = null;\r\n      let access: string | null = null;\r\n      if (this._match(TokenTypes.tokens.less_than)) {\r\n        format = this._type_decl();\r\n        access = null;\r\n        if (this._match(TokenTypes.tokens.comma)) {\r\n          access = this._consume(TokenTypes.access_mode, \"Expected access_mode for pointer\").toString();\r\n        }\r\n        this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for type.\");\r\n      }\r\n      const node = this._updateNode(new AST.TemplateType(type, format, access));\r\n      return node;\r\n    }\r\n\r\n    // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n    if (this._match(TokenTypes.keywords.ptr)) {\r\n      let pointer = this._previous().toString();\r\n      this._consume(TokenTypes.tokens.less_than, \"Expected '<' for pointer.\");\r\n      const storage = this._consume(TokenTypes.storage_class, \"Expected storage_class for pointer\");\r\n      this._consume(TokenTypes.tokens.comma, \"Expected ',' for pointer.\");\r\n      const decl = this._type_decl();\r\n      let access: string | null = null;\r\n      if (this._match(TokenTypes.tokens.comma)) {\r\n        access = this._consume(TokenTypes.access_mode, \"Expected access_mode for pointer\").toString();\r\n      }\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for pointer.\");\r\n      const node = this._updateNode(new AST.PointerType(pointer, storage.toString(), decl, access));\r\n      return node;\r\n    }\r\n\r\n    // The following type_decl's have an optional attribyte_list*\r\n    const attrs = this._attribute();\r\n\r\n    // attribute* array\r\n    // attribute* array less_than type_decl (comma element_count_expression)? greater_than\r\n    if (this._match(TokenTypes.keywords.array)) {\r\n      let format = null;\r\n      let countInt = -1;\r\n      const array = this._previous();\r\n      let countNode: AST.Expression | null = null;\r\n      if (this._match(TokenTypes.tokens.less_than)) {\r\n        format = this._type_decl();\r\n        if (this._context.aliases.has(format.name)) {\r\n          format = this._context.aliases.get(format.name).type;\r\n        }\r\n        let count: string = \"\";\r\n        if (this._match(TokenTypes.tokens.comma)) {\r\n          countNode = this._shift_expression();\r\n          // If we can't evaluate the node, defer evaluating it until after the shader has\r\n          // finished being parsed, because const statements can be declared **after** they\r\n          // are used.\r\n          try {\r\n            count = countNode.constEvaluate(this._exec).toString();\r\n            countNode = null;\r\n          } catch (e) {\r\n            count = \"1\";\r\n          }\r\n        }\r\n        this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for array.\");\r\n        countInt = count ? parseInt(count) : 0;\r\n      }\r\n      const arrayType = this._updateNode(new AST.ArrayType(array.toString(), attrs, format, countInt));\r\n      if (countNode) {\r\n        this._deferArrayCountEval.push({ arrayType, countNode });\r\n      }\r\n      return arrayType;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _texture_sampler_types(): AST.SamplerType | null {\r\n    // sampler_type\r\n    if (this._match(TokenTypes.sampler_type)) {\r\n      return this._updateNode(new AST.SamplerType(this._previous().toString(), null, null));\r\n    }\r\n\r\n    // depth_texture_type\r\n    if (this._match(TokenTypes.depth_texture_type)) {\r\n      return this._updateNode(new AST.SamplerType(this._previous().toString(), null, null));\r\n    }\r\n\r\n    // sampled_texture_type less_than type_decl greater_than\r\n    // multisampled_texture_type less_than type_decl greater_than\r\n    if (this._match(TokenTypes.sampled_texture_type) ||\r\n      this._match(TokenTypes.multisampled_texture_type)) {\r\n      const sampler = this._previous();\r\n      this._consume(\r\n        TokenTypes.tokens.less_than,\r\n        \"Expected '<' for sampler type.\"\r\n      );\r\n      const format = this._type_decl();\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for sampler type.\");\r\n      return this._updateNode(new AST.SamplerType(sampler.toString(), format, null));\r\n    }\r\n\r\n    // storage_texture_type less_than texel_format comma access_mode greater_than\r\n    if (this._match(TokenTypes.storage_texture_type)) {\r\n      const sampler = this._previous();\r\n      this._consume(TokenTypes.tokens.less_than, \"Expected '<' for sampler type.\");\r\n      const format = this._consume(TokenTypes.texel_format, \"Invalid texel format.\").toString();\r\n      this._consume(TokenTypes.tokens.comma, \"Expected ',' after texel format.\");\r\n      const access = this._consume(TokenTypes.access_mode, \"Expected access mode for storage texture type.\").toString();\r\n      this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for sampler type.\");\r\n      return this._updateNode(new AST.SamplerType(sampler.toString(), format, access));\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _attribute(): AST.Attribute[] | null {\r\n    // attr ident paren_left (literal_or_ident comma)* literal_or_ident paren_right\r\n    // attr ident\r\n\r\n    let attributes: AST.Attribute[] = [];\r\n\r\n    while (this._match(TokenTypes.tokens.attr)) {\r\n      const name = this._consume(\r\n        TokenTypes.attribute_name,\r\n        \"Expected attribute name\"\r\n      );\r\n      const attr = this._updateNode(new AST.Attribute(name.toString(), null));\r\n      if (this._match(TokenTypes.tokens.paren_left)) {\r\n        // literal_or_ident\r\n        attr.value = this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString();\r\n        if (this._check(TokenTypes.tokens.comma)) {\r\n          this._advance();\r\n          do {\r\n            const v = this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString();\r\n            if (!(attr.value instanceof Array)) {\r\n              attr.value = [attr.value as string];\r\n            }\r\n            attr.value.push(v);\r\n          } while (this._match(TokenTypes.tokens.comma));\r\n        }\r\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'\");\r\n      }\r\n      attributes.push(attr);\r\n    }\r\n\r\n    if (attributes.length == 0) {\r\n      return null;\r\n    }\r\n\r\n    return attributes;\r\n  }\r\n}\r\n","import { WgslParser } from \"./wgsl_parser.js\";\r\nimport { Reflect } from \"./reflect/reflect.js\";\r\n\r\nexport * from \"./reflect/info.js\";\r\n\r\nexport class WgslReflect extends Reflect {\r\n  constructor(code?: string) {\r\n    super();\r\n    if (code) {\r\n      this.update(code);\r\n    }\r\n  }\r\n\r\n  update(code: string): void {\r\n    const parser = new WgslParser();\r\n    const ast = parser.parse(code);\r\n    this.updateAST(ast);\r\n  }\r\n}\r\n","import { Node, CallExpr, Continue, Expression, Break } from \"../wgsl_ast.js\";\r\n\r\nexport class Command {\r\n    get line(): number { return -1; }\r\n}\r\n\r\nexport class StatementCommand extends Command {\r\n    node: Node;\r\n\r\n    constructor(node: Node) {\r\n        super();\r\n        this.node = node;\r\n    }\r\n\r\n    get line(): number { return this.node.line; }\r\n}\r\n\r\nexport class CallExprCommand extends Command {\r\n    node: CallExpr;\r\n    statement: Node;\r\n\r\n    constructor(node: CallExpr, statement: Node) {\r\n        super();\r\n        this.node = node;\r\n        this.statement = statement;\r\n    }\r\n\r\n    get line(): number { return this.statement.line; }\r\n}\r\n\r\nexport class ContinueTargetCommand extends Command {\r\n    id: number;\r\n\r\n    constructor(id: number) {\r\n        super();\r\n        this.id = id;\r\n    }\r\n}\r\n\r\nexport class BreakTargetCommand extends Command {\r\n    id: number;\r\n\r\n    constructor(id: number) {\r\n        super();\r\n        this.id = id;\r\n    }\r\n}\r\n\r\nexport class ContinueCommand extends Command {\r\n    id: number;\r\n    node: Continue;\r\n\r\n    constructor(id: number, node: Continue) {\r\n        super();\r\n        this.id = id;\r\n        this.node = node;\r\n    }\r\n\r\n    get line(): number { return this.node.line; }\r\n}\r\n\r\nexport class BreakCommand extends Command {\r\n    id: number;\r\n    condition: Expression | null;\r\n    node: Break;\r\n\r\n    constructor(id: number, condition: Expression | null, node: Break) {\r\n        super();\r\n        this.id = id;\r\n        this.condition = condition;\r\n        this.node = node;\r\n    }\r\n\r\n    get line(): number { return this.node.line; }\r\n}\r\n\r\n\r\nexport class GotoCommand extends Command {\r\n    condition: Node | null;\r\n    position: number;\r\n    lineNo: number = -1;\r\n\r\n    constructor(condition: Node | null, position: number, line: number) {\r\n        super();\r\n        this.condition = condition;\r\n        this.position = position;\r\n        this.lineNo = line;\r\n    }\r\n\r\n    get line(): number {\r\n        return this.condition?.line ?? this.lineNo;\r\n    }\r\n}\r\n\r\nexport class BlockCommand extends Command {\r\n    statements: Array<Node> = [];\r\n\r\n    constructor(statements: Array<Node>) {\r\n      super();\r\n      this.statements = statements;\r\n    }\r\n\r\n    get line(): number {\r\n      return this.statements.length > 0 ? this.statements[0].line : -1;\r\n    }\r\n}\r\n","import { Command } from \"./command.js\";\r\nimport { CallExpr } from \"../wgsl_ast.js\";\r\nimport { ExecContext } from \"./exec_context.js\";\r\n\r\nexport class StackFrame {\r\n    parent: StackFrame | null = null;\r\n    context: ExecContext;\r\n    commands: Command[] = [];\r\n    current: number = 0;\r\n    parentCallExpr: CallExpr | null = null;\r\n\r\n    constructor(context: ExecContext, parent?: StackFrame) {\r\n        this.context = context;\r\n        this.parent = parent ?? null;\r\n    }\r\n\r\n    get isAtEnd(): boolean { return this.current >= this.commands.length; }\r\n\r\n    getNextCommand(): Command | null {\r\n        if (this.current >= this.commands.length) {\r\n            return null;\r\n        }\r\n        const command = this.commands[this.current];\r\n        this.current++;\r\n        return command;\r\n    }\r\n\r\n    getCurrentCommand(): Command | null {\r\n        if (this.current >= this.commands.length) {\r\n            return null;\r\n        }\r\n        return this.commands[this.current];\r\n    }\r\n}\r\n","import { StackFrame } from \"./stack_frame.js\";\r\n\r\nexport class ExecStack {\r\n    states: StackFrame[] = [];\r\n\r\n    get isEmpty(): boolean { return this.states.length == 0; }\r\n\r\n    get last(): StackFrame | null { return this.states[this.states.length - 1] ?? null; }\r\n\r\n    pop(): void {\r\n        this.states.pop();\r\n    }\r\n}\r\n","import * as AST from \"./wgsl_ast.js\";\r\nimport { WgslExec } from \"./wgsl_exec.js\";\r\nimport { WgslParser } from \"./wgsl_parser.js\";\r\nimport { ExecContext, FunctionRef } from \"./exec/exec_context.js\";\r\nimport { Command, StatementCommand, CallExprCommand, GotoCommand, BlockCommand,\r\n        ContinueTargetCommand, ContinueCommand, BreakCommand, BreakTargetCommand } from \"./exec/command.js\";\r\nimport { StackFrame } from \"./exec/stack_frame.js\";\r\nimport { ExecStack } from \"./exec/exec_stack.js\";\r\nimport { ScalarData, VectorData, MatrixData, TextureData, TypedData, VoidData, ArrayType, LiteralExpr } from \"./wgsl_ast.js\";\r\n\r\ntype RuntimeStateCallbackType = () => void;\r\n\r\nexport class WgslDebug {\r\n    _code: string;\r\n    _exec: WgslExec;\r\n    _execStack: ExecStack;\r\n    _dispatchId: number[];\r\n    _runTimer: any = null;\r\n    breakpoints: Set<number> = new Set();\r\n    runStateCallback: RuntimeStateCallbackType | null = null;\r\n\r\n    constructor(code: string, runStateCallback?: RuntimeStateCallbackType) {\r\n        this._code = code;\r\n        const parser = new WgslParser();\r\n        const ast = parser.parse(code);\r\n        this._exec = new WgslExec(ast);\r\n        this.runStateCallback = runStateCallback ?? null\r\n    }\r\n\r\n    getVariableValue(name: string): number | number[] | null {\r\n        const context = this.context;\r\n        const v = context.getVariable(name)?.value ?? null;\r\n        if (v === null) {\r\n            return null;\r\n        }\r\n        if (v instanceof ScalarData) {\r\n            return v.value;\r\n        }\r\n        if (v instanceof VectorData) {\r\n            return Array.from(v.data);\r\n        }\r\n        if (v instanceof MatrixData) {\r\n            return Array.from(v.data);\r\n        }\r\n        console.error(`Unsupported return variable type ${v.typeInfo.name}`);\r\n        return null;\r\n    }\r\n\r\n    reset(): void {\r\n        this._exec = new WgslExec(this._exec.ast);\r\n        this.startDebug();\r\n    }\r\n\r\n    startDebug(): void {\r\n        this._execStack = new ExecStack();\r\n        const state = this._createState(this._exec.ast, this._exec.context);\r\n        this._execStack.states.push(state);\r\n    }\r\n\r\n    get context(): ExecContext {\r\n        const state = this.currentState;\r\n        if (state === null) {\r\n            return this._exec.context;\r\n        }\r\n        return state.context;\r\n    }\r\n\r\n    get currentState(): StackFrame | null {\r\n        while (true) {\r\n            if (this._execStack.isEmpty) {\r\n                return null;\r\n            }\r\n\r\n            let state = this._execStack.last;\r\n            if (state === null) {\r\n                return null;\r\n            }\r\n\r\n            if (state.isAtEnd) {\r\n                this._execStack.pop();\r\n                if (this._execStack.isEmpty) {\r\n                    return null;\r\n                }\r\n                state = this._execStack.last;\r\n            }\r\n\r\n            return state;\r\n        }\r\n    }\r\n\r\n    get currentCommand(): Command | null {\r\n        while (true) {\r\n            if (this._execStack.isEmpty) {\r\n                return null;\r\n            }\r\n\r\n            let state = this._execStack.last;\r\n            if (state === null) {\r\n                return null;\r\n            }\r\n\r\n            if (state.isAtEnd) {\r\n                this._execStack.pop();\r\n                if (this._execStack.isEmpty) {\r\n                    return null;\r\n                }\r\n                state = this._execStack.last;\r\n            }\r\n\r\n            const command = state.getCurrentCommand();\r\n            if (command === null) {\r\n                continue;\r\n            }\r\n\r\n            return command;\r\n        }\r\n    }\r\n\r\n    toggleBreakpoint(line: number) {\r\n        if (this.breakpoints.has(line)) {\r\n            this.breakpoints.delete(line);\r\n        } else {\r\n            this.breakpoints.add(line);\r\n        }\r\n    }\r\n\r\n    clearBreakpoints() {\r\n        this.breakpoints.clear();\r\n    }\r\n\r\n    get isRunning() {\r\n        return this._runTimer !== null;\r\n    }\r\n\r\n    run() {\r\n        if (this.isRunning) {\r\n            return;\r\n        }\r\n        this._runTimer = setInterval(() => {\r\n            const command = this.currentCommand;\r\n            if (command) {\r\n                if (this.breakpoints.has(command.line)) {\r\n                    clearInterval(this._runTimer!);\r\n                    this._runTimer = null;\r\n                    if (this.runStateCallback !== null) {\r\n                        this.runStateCallback();\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            if (!this.stepNext(true)) {\r\n                clearInterval(this._runTimer!);\r\n                this._runTimer = null;\r\n                if (this.runStateCallback !== null) {\r\n                    this.runStateCallback();\r\n                }\r\n            }\r\n        }, 0);\r\n        if (this.runStateCallback !== null) {\r\n            this.runStateCallback();\r\n        }\r\n    }\r\n\r\n    pause() {\r\n        if (this._runTimer !== null) {\r\n            clearInterval(this._runTimer);\r\n            this._runTimer = null;\r\n            if (this.runStateCallback !== null) {\r\n                this.runStateCallback();\r\n            }\r\n        }\r\n    }\r\n\r\n    _setOverrides(constants: Object, context: ExecContext): void {\r\n        for (const k in constants) {\r\n            const v = constants[k];\r\n            const override = this._exec.reflection.getOverrideInfo(k);\r\n            if (override !== null) {\r\n                if (override.type === null) {\r\n                    override.type = this._exec.getTypeInfo(\"u32\");\r\n                }\r\n                if (override.type.name === \"u32\" || override.type.name === \"i32\" || override.type.name === \"f32\" || override.type.name === \"f16\") {\r\n                    context.setVariable(k, new ScalarData(v, override.type));\r\n                } else if (override.type.name === \"bool\") {\r\n                    context.setVariable(k, new ScalarData(v ? 1 : 0, override.type));\r\n                } else if (override.type.name === \"vec2\" || override.type.name === \"vec3\" || override.type.name === \"vec4\" ||\r\n                    override.type.name === \"vec2f\" || override.type.name === \"vec3f\" || override.type.name === \"vec4f\" ||\r\n                    override.type.name === \"vec2i\" || override.type.name === \"vec3i\" || override.type.name === \"vec4i\" ||\r\n                    override.type.name === \"vec2u\" || override.type.name === \"vec3u\" || override.type.name === \"vec4u\" ||\r\n                    override.type.name === \"vec2h\" || override.type.name === \"vec3h\" || override.type.name === \"vec4h\") {\r\n                    context.setVariable(k, new VectorData(v, override.type));\r\n                } else {\r\n                    console.error(`Invalid constant type for ${k}`);\r\n                }\r\n            } else {\r\n                console.error(`Override ${k} does not exist in the shader.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    debugWorkgroup(kernel: string, dispatchId: number[], \r\n        dispatchCount: number | number[], bindGroups: Object, config?: Object): boolean {\r\n\r\n        this._execStack = new ExecStack();\r\n\r\n        const context = this._exec.context;\r\n        context.currentFunctionName = kernel;\r\n\r\n        this._dispatchId = dispatchId;\r\n\r\n        config = config ?? {};\r\n        if (config[\"constants\"]) {\r\n            this._setOverrides(config[\"constants\"], context);\r\n        }\r\n\r\n        // Use this to debug the top level statements, otherwise call _execStatements.\r\n        /*const state = new _ExecState(this._exec.context);\r\n        this._execStack.states.push(state);\r\n        for (const statement of this._exec.ast) {\r\n            state.commands.push(new Command(CommandType.Statement, statement));\r\n        }*/\r\n        this._exec._execStatements(this._exec.ast, context);\r\n\r\n        const kernelFn = context.getFunction(kernel);\r\n        if (!kernelFn) {\r\n            console.error(`Function ${kernel} not found`);\r\n            return false;\r\n        }\r\n\r\n        const kernelRefl = this._exec.reflection.getFunctionInfo(kernel);\r\n\r\n        if (typeof dispatchCount === \"number\") {\r\n            dispatchCount = [dispatchCount, 1, 1];\r\n        } else if (dispatchCount.length === 0) {\r\n            console.error(`Invalid dispatch count`);\r\n            return false;\r\n        } else if (dispatchCount.length === 1) {\r\n            dispatchCount = [dispatchCount[0], 1, 1];\r\n        } else if (dispatchCount.length === 2) {\r\n            dispatchCount = [dispatchCount[0], dispatchCount[1], 1];\r\n        } else if (dispatchCount.length > 3) {\r\n            dispatchCount = [dispatchCount[0], dispatchCount[1], dispatchCount[2]];\r\n        }\r\n\r\n        const depth = dispatchCount[2];\r\n        const height = dispatchCount[1];\r\n        const width = dispatchCount[0];\r\n\r\n        const vec3u = this._exec.typeInfo[\"vec3u\"];\r\n        context.setVariable(\"@num_workgroups\", new VectorData(dispatchCount, vec3u));\r\n\r\n        for (const set in bindGroups) {\r\n            for (const binding in bindGroups[set]) {\r\n                const entry = bindGroups[set][binding];\r\n\r\n                context.variables.forEach((v) => {\r\n                    const node = v.node;\r\n                    if (node?.attributes) {\r\n                        let b = null;\r\n                        let s = null;\r\n                        for (const attr of node.attributes) {\r\n                            if (attr.name === \"binding\") {\r\n                                b = attr.value;\r\n                            } else if (attr.name === \"group\") {\r\n                                s = attr.value;\r\n                            }\r\n                        }\r\n                        if (binding == b && set == s) {\r\n                            let found = false;\r\n                            for (const resource of kernelRefl.resources) {\r\n                                if (resource.name === v.name && resource.group === parseInt(set) && resource.binding === parseInt(binding)) {\r\n                                    found = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (found) {\r\n                                const typeInfo = this._exec.getTypeInfo(node.type);\r\n                                if (entry.texture !== undefined && entry.descriptor !== undefined) {\r\n                                    // Texture\r\n                                    v.value = new TextureData(entry.texture, typeInfo, entry.descriptor,\r\n                                        entry.texture.view ?? null);\r\n                                } else if (entry.uniform !== undefined) {\r\n                                    // Uniform buffer\r\n                                    v.value = new TypedData(entry.uniform, typeInfo);\r\n                                } else {\r\n                                    if (typeInfo.isStruct || typeInfo.isArray) {\r\n                                        // Storage buffer\r\n                                        v.value = new TypedData(entry, typeInfo);\r\n                                    } else {\r\n                                        // all other types\r\n                                        // trashy, create an array size one and pull the first element, couldn't find a better way to support a ton of types.\r\n                                        const arrayType = new ArrayType(`array<${node.type.name}>`, [], node.type, 1)\r\n                                        let i32 = this._exec.getTypeInfo('i32');\r\n                                        const index = new AST.ArrayIndex(new AST.LiteralExpr(new ScalarData(new Int32Array([0]), i32), AST.Type.u32));\r\n                                        v.value = new TypedData(entry, this._exec.getTypeInfo(arrayType)).getSubData(new WgslExec(), index, null);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        let found = false;\r\n        for (let z = 0; z < depth && !found; ++z) {\r\n            for (let y = 0; y < height && !found; ++y) {\r\n                for (let x = 0; x < width && !found; ++x) {\r\n                    context.setVariable(\"@workgroup_id\", new VectorData([x, y, z], vec3u));\r\n                    if (this._dispatchWorkgroup(kernelFn, [x, y, z], context)) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return found;\r\n    }\r\n\r\n    _shouldExecuteNextCommand(): boolean {\r\n        const command = this.currentCommand;\r\n        if (command === null) {\r\n            return false;\r\n        }\r\n        if (command instanceof GotoCommand) {\r\n            if (command.condition === null) {\r\n                return true;\r\n            }\r\n        } else if (command instanceof ContinueTargetCommand || command instanceof BreakTargetCommand) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    stepInto() {\r\n        if (this.isRunning) {\r\n            return;\r\n        }\r\n        this.stepNext(true);\r\n    }\r\n\r\n    stepOver() {\r\n        if (this.isRunning) {\r\n            return;\r\n        }\r\n        this.stepNext(false);\r\n    }\r\n\r\n    stepOut() {\r\n        const state = this.currentState;\r\n        if (state === null) {\r\n            return;\r\n        }\r\n        const parentState = state.parent;\r\n\r\n        if (this.isRunning) {\r\n            clearInterval(this._runTimer);\r\n            this._runTimer = null;\r\n        }\r\n\r\n        this._runTimer = setInterval(() => {\r\n            const command = this.currentCommand;\r\n            if (command) {\r\n                if (this.breakpoints.has(command.line)) {\r\n                    clearInterval(this._runTimer!);\r\n                    this._runTimer = null;\r\n                    if (this.runStateCallback !== null) {\r\n                        this.runStateCallback();\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            if (!this.stepNext(true)) {\r\n                clearInterval(this._runTimer!);\r\n                this._runTimer = null;\r\n                if (this.runStateCallback !== null) {\r\n                    this.runStateCallback();\r\n                }\r\n            }\r\n\r\n            const state = this.currentState;\r\n            if (state === parentState) {\r\n                clearInterval(this._runTimer!);\r\n                this._runTimer = null;\r\n                if (this.runStateCallback !== null) {\r\n                    this.runStateCallback();\r\n                }\r\n            }\r\n        }, 0);\r\n        if (this.runStateCallback !== null) {\r\n            this.runStateCallback();\r\n        }\r\n    }\r\n\r\n    // Returns true if execution is not finished, false if execution is complete.\r\n    stepNext(stepInto = true): boolean {\r\n        if (!this._execStack) {\r\n            this._execStack = new ExecStack();\r\n            const state = this._createState(this._exec.ast, this._exec.context);\r\n            this._execStack.states.push(state);\r\n        }\r\n\r\n        while (true) {\r\n            if (this._execStack.isEmpty) {\r\n                return false;\r\n            }\r\n\r\n            let state = this._execStack.last;\r\n            if (state === null) {\r\n                return false;\r\n            }\r\n\r\n            if (state.isAtEnd) {\r\n                this._execStack.pop();\r\n                if (this._execStack.isEmpty) {\r\n                    return false;\r\n                }\r\n                state = this._execStack.last;\r\n            }\r\n\r\n            const command = state!.getNextCommand();\r\n            if (command === null) {\r\n                continue;\r\n            }\r\n\r\n            if (stepInto && command instanceof CallExprCommand) {\r\n                const node = command.node;\r\n                const fn = state.context.getFunction(node.name);\r\n                if (!fn) {\r\n                    continue; // it's not a custom function, step over it\r\n                }\r\n                const fnState = this._createState(fn.node.body, state.context.clone(), state);\r\n\r\n                for (let ai = 0; ai < fn.node.args.length; ++ai) {\r\n                    const arg = fn.node.args[ai];\r\n                    const value = this._exec.evalExpression(node.args[ai], fnState.context);\r\n                    fnState.context.createVariable(arg.name, value, arg);\r\n                }\r\n\r\n                fnState.parentCallExpr = node;\r\n                this._execStack.states.push(fnState);\r\n                fnState.context.currentFunctionName = fn.name;\r\n\r\n                if (this._shouldExecuteNextCommand()) {\r\n                    continue;\r\n                }\r\n                return true;\r\n            } else if (command instanceof StatementCommand) {\r\n                const node = command.node;\r\n                if (stepInto && node instanceof AST.Call) {\r\n                    const fn = state.context.getFunction(node.name);\r\n                    // We want to step into custom functions, not directly execute them\r\n                    if (fn) {\r\n                        const fnState = this._createState(fn.node.body, state.context.clone(), state);\r\n\r\n                        for (let ai = 0; ai < fn.node.args.length; ++ai) {\r\n                            const arg = fn.node.args[ai];\r\n                            const value = this._exec.evalExpression(node.args[ai], fnState.context);\r\n                            fnState.context.createVariable(arg.name, value, arg);\r\n                        }\r\n\r\n                        this._execStack.states.push(fnState);\r\n                        fnState.context.currentFunctionName = fn.name;\r\n\r\n                        if (this._shouldExecuteNextCommand()) {\r\n                            continue;\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                const res = this._exec.execStatement(node, state.context);\r\n                if (res !== null && res !== undefined && !(res instanceof VoidData)) {\r\n                    let s = state;\r\n                    // Find the CallExpr to store the return value in.\r\n                    while (s) {\r\n                        if (s.parentCallExpr) {\r\n                            s.parentCallExpr.setCachedReturnValue(res);\r\n                            break;\r\n                        }\r\n                        s = s.parent;\r\n                    }\r\n                    if (s === null) {\r\n                        console.error(\"Could not find CallExpr to store return value in\");\r\n                    }\r\n                    if (this._shouldExecuteNextCommand()) {\r\n                        continue;\r\n                    }\r\n                    return true;\r\n                }\r\n            } else if (command instanceof ContinueTargetCommand) {\r\n                continue;\r\n            } else if (command instanceof BreakTargetCommand) {\r\n                continue;\r\n            } else if (command instanceof ContinueCommand) {\r\n                const targetId = command.id;\r\n                while (!this._execStack.isEmpty) {\r\n                    state = this._execStack.last;\r\n                    for (let i = state.commands.length - 1; i >= 0; --i) {\r\n                        const cmd = state.commands[i];\r\n                        if (cmd instanceof ContinueTargetCommand) {\r\n                            if (cmd.id === targetId) {\r\n                                state.current = i + 1;\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    // No Goto -1 found (loop), pop the current state and continue searching.\r\n                    this._execStack.pop();\r\n                }\r\n                // If we got here, we've reached the end of the stack and didn't find a -1.\r\n                // That means a continue was used outside of a loop, so we're done.\r\n                console.error(\"Continue statement used outside of a loop\");\r\n                return false;\r\n            } else if (command instanceof BreakCommand) {\r\n                const targetId = command.id;\r\n                // break-if conditional break \r\n                if (command.condition) {\r\n                    const res = this._exec.evalExpression(command.condition, state.context);\r\n                    if (!(res instanceof ScalarData)) {\r\n                        console.error(\"Condition must be a scalar\");\r\n                        return false;\r\n                    }\r\n                    // If the condition is false, then we should not the break.\r\n                    if (!res.value) {\r\n                        if (this._shouldExecuteNextCommand()) {\r\n                            continue;\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                while (!this._execStack.isEmpty) {\r\n                    state = this._execStack.last;\r\n                    for (let i = state.commands.length - 1; i >= 0; --i) {\r\n                        const cmd = state.commands[i];\r\n                        if (cmd instanceof BreakTargetCommand) {\r\n                            if (cmd.id === targetId) {\r\n                                state.current = i + 1;\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    // No Goto -2 found (loop), pop the current state and continue searching.\r\n                    this._execStack.pop();\r\n                }\r\n                // If we got here, we've reached the end of the stack and didn't find a BreakTarget.\r\n                // That means a break was used outside of a loop, so we're done.\r\n                console.error(\"Break statement used outside of a loop\");\r\n                return false;\r\n            } else if (command instanceof GotoCommand) {\r\n                if (command.condition) {\r\n                    const res = this._exec.evalExpression(command.condition, state.context);\r\n                    if (!(res instanceof ScalarData)) {\r\n                        console.error(\"Condition must be a scalar\");\r\n                        return false;\r\n                    }\r\n                    // If the GOTO condition value is true, then continue to the next command.\r\n                    // Otherwise, jump to the specified position.\r\n                    if (res.value) {\r\n                        if (this._shouldExecuteNextCommand()) {\r\n                            continue;\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n                state.current = command.position;\r\n                if (this._shouldExecuteNextCommand()) {\r\n                    continue;\r\n                }\r\n                return true;\r\n            } else if (command instanceof BlockCommand) {\r\n                const blockState = this._createState(command.statements, state.context.clone(), state);\r\n                this._execStack.states.push(blockState);\r\n                continue; // step into the first statement of the block\r\n            }\r\n\r\n            if (state.isAtEnd) {\r\n                this._execStack.pop();\r\n                if (this._execStack.isEmpty) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            if (this._shouldExecuteNextCommand()) {\r\n                continue;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    _dispatchWorkgroup(f: FunctionRef, workgroup_id: number[], context: ExecContext): boolean {\r\n        const workgroupSize = [1, 1, 1];\r\n        for (const attr of f.node.attributes) {\r\n            if (attr.name === \"workgroup_size\") {\r\n                if (Array.isArray(attr.value)) {\r\n                    if (attr.value.length > 0) {\r\n                        // The value could be an override constant\r\n                        const v = context.getVariableValue(attr.value[0]);\r\n                        if (v instanceof ScalarData) {\r\n                            workgroupSize[0] = v.value;\r\n                        } else {\r\n                            workgroupSize[0] = parseInt(attr.value[0]);\r\n                        }\r\n                    }\r\n                    if (attr.value.length > 1) {\r\n                        const v = context.getVariableValue(attr.value[1]);\r\n                        if (v instanceof ScalarData) {\r\n                            workgroupSize[1] = v.value;\r\n                        } else {\r\n                            workgroupSize[1] = parseInt(attr.value[1]);\r\n                        }\r\n                    }\r\n                    if (attr.value.length > 2) {\r\n                        const v = context.getVariableValue(attr.value[2]);\r\n                        if (v instanceof ScalarData) {\r\n                            workgroupSize[2] = v.value;\r\n                        } else {\r\n                            workgroupSize[2] = parseInt(attr.value[2]);\r\n                        }\r\n                    }\r\n                } else {\r\n                    const v = context.getVariableValue(attr.value);\r\n                    if (v instanceof ScalarData) {\r\n                        workgroupSize[0] = v.value;\r\n                    } else if (v instanceof VectorData) {\r\n                        workgroupSize[0] = v.data[0];\r\n                        workgroupSize[1] = v.data.length > 1 ? v.data[1] : 1;\r\n                        workgroupSize[2] = v.data.length > 2 ? v.data[2] : 1;\r\n                    } else {\r\n                        workgroupSize[0] = parseInt(attr.value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const vec3u = this._exec.typeInfo[\"vec3u\"];\r\n        const u32 = this._exec.typeInfo[\"u32\"];\r\n        context.setVariable(\"@workgroup_size\", new VectorData(workgroupSize, vec3u));\r\n\r\n        const width = workgroupSize[0];\r\n        const height = workgroupSize[1];\r\n        const depth = workgroupSize[2];\r\n\r\n        let found = false;\r\n        for (let z = 0, li = 0; z < depth && !found; ++z) {\r\n            for (let y = 0; y < height && !found; ++y) {\r\n                for (let x = 0; x < width && !found; ++x, ++li) {\r\n                    const local_invocation_id = [x, y, z];\r\n                    const global_invocation_id = [\r\n                        x + workgroup_id[0] * workgroupSize[0],\r\n                        y + workgroup_id[1] * workgroupSize[1],\r\n                        z + workgroup_id[2] * workgroupSize[2]];\r\n\r\n                    context.setVariable(\"@local_invocation_id\", new VectorData(local_invocation_id, vec3u));\r\n                    context.setVariable(\"@global_invocation_id\", new VectorData(global_invocation_id, vec3u));\r\n                    context.setVariable(\"@local_invocation_index\", new ScalarData(li, u32));\r\n\r\n                    if (global_invocation_id[0] === this._dispatchId[0] &&\r\n                        global_invocation_id[1] === this._dispatchId[1] &&\r\n                        global_invocation_id[2] === this._dispatchId[2]) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            this._dispatchExec(f, context);\r\n        }\r\n\r\n        return found;\r\n    }\r\n\r\n    _dispatchExec(f: FunctionRef, context: ExecContext) {\r\n        // Update any built-in input args.\r\n        // TODO: handle input structs.\r\n        for (const arg of f.node.args) {\r\n            for (const attr of arg.attributes) {\r\n                if (attr.name === \"builtin\") {\r\n                    const globalName = `@${attr.value}`;\r\n                    const globalVar = context.getVariable(globalName);\r\n                    if (globalVar !== null) {\r\n                        context.variables.set(arg.name, globalVar);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const state = this._createState(f.node.body, context);\r\n        this._execStack.states.push(state);\r\n    }\r\n\r\n    _createState(ast: AST.Node[], context: ExecContext, parent?: StackFrame): StackFrame {\r\n        const state = new StackFrame(context, parent ?? null);\r\n\r\n        for (const statement of ast) {\r\n            // A statement may have expressions that include function calls.\r\n            // Gather all of the internal function calls from the statement.\r\n            // We can then include them as commands to step through, storing their\r\n            // values with the call node so that when it is evaluated, it uses that\r\n            // already computed value. This allows us to step into the function\r\n            if (statement instanceof AST.Let ||\r\n                statement instanceof AST.Var ||\r\n                statement instanceof AST.Const ||\r\n                statement instanceof AST.Override ||\r\n                statement instanceof AST.Assign) {\r\n                const functionCalls = [];\r\n                this._collectFunctionCalls(statement.value, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Call) {\r\n                const functionCalls = [];\r\n                for (const arg of statement.args) {\r\n                    this._collectFunctionCalls(arg, functionCalls);\r\n                }\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Return) {\r\n                const functionCalls = [];\r\n                this._collectFunctionCalls(statement.value, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Increment) {\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Function) {\r\n                const f = new FunctionRef(statement);\r\n                state.context.functions.set(statement.name, f);\r\n                continue;\r\n            } else if (statement instanceof AST.If) {\r\n                const functionCalls = [];\r\n                this._collectFunctionCalls(statement.condition, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n\r\n                let conditionCmd = new GotoCommand(statement.condition, 0, statement.line);\r\n                state.commands.push(conditionCmd);\r\n                if (statement.body.length > 0) {\r\n                    state.commands.push(new BlockCommand(statement.body));\r\n                }\r\n                const gotoEnd = new GotoCommand(null, 0, statement.line);\r\n                state.commands.push(gotoEnd);\r\n\r\n                for (const elseIf of statement.elseif) {\r\n                    conditionCmd.position = state.commands.length;\r\n\r\n                    const functionCalls = [];\r\n                    this._collectFunctionCalls(elseIf.condition, functionCalls);\r\n                    for (const call of functionCalls) {\r\n                        state.commands.push(new CallExprCommand(call, statement));\r\n                    }\r\n\r\n                    conditionCmd = new GotoCommand(elseIf.condition, 0, elseIf.line);\r\n                    state.commands.push(conditionCmd);\r\n                    if (elseIf.body.length > 0) {\r\n                        state.commands.push(new BlockCommand(elseIf.body));\r\n                    }\r\n                    state.commands.push(gotoEnd);\r\n                }\r\n\r\n                conditionCmd.position = state.commands.length;\r\n                if (statement.else) {\r\n                    state.commands.push(new BlockCommand(statement.else));\r\n                }\r\n\r\n                gotoEnd.position = state.commands.length;\r\n            } else if (statement instanceof AST.Switch) {\r\n                const functionCalls = [];\r\n                this._collectFunctionCalls(statement.condition, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n\r\n                let defaultCase: AST.SwitchCase | null = null;\r\n                for (const c of statement.cases) {\r\n                    if (c instanceof AST.Default) {\r\n                        defaultCase = c;\r\n                        break;\r\n                    } else if (c instanceof AST.Case) {\r\n                        for (const selector of c.selectors) {\r\n                            if (selector instanceof AST.DefaultSelector) {\r\n                                defaultCase = c;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const gotoEndCommands: GotoCommand[] = [];\r\n\r\n                for (const c of statement.cases) {\r\n                    if (c === defaultCase) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!(c instanceof AST.Case)) {\r\n                        continue;\r\n                    }\r\n\r\n                    let lastCondition = null;\r\n                    for (const selector of c.selectors) {\r\n                        let conditionExpr = new AST.BinaryOperator(\"==\", statement.condition, selector);\r\n                        if (lastCondition) {\r\n                            conditionExpr = new AST.BinaryOperator(\"||\", lastCondition, conditionExpr);\r\n                        }\r\n                        lastCondition = conditionExpr;\r\n                    }\r\n\r\n                    const gotoCommand = new GotoCommand(lastCondition, 0, c.line);\r\n                    state.commands.push(gotoCommand);\r\n\r\n                    if (c.body.length > 0) {\r\n                        state.commands.push(new BlockCommand(c.body));\r\n                    }\r\n\r\n                    const gotoEndCommand = new GotoCommand(null, 0, c.line);\r\n                    gotoEndCommands.push(gotoEndCommand);\r\n                    state.commands.push(gotoEndCommand);\r\n\r\n                    gotoCommand.position = state.commands.length;\r\n                }\r\n\r\n                if (defaultCase) {\r\n                    state.commands.push(new BlockCommand(defaultCase.body));\r\n                }\r\n\r\n                state.commands.push(new BreakTargetCommand(statement.id));\r\n\r\n                const commandPos = state.commands.length;\r\n                for (let i = 0; i < gotoEndCommands.length; ++i) {\r\n                    gotoEndCommands[i].position = commandPos;\r\n                }\r\n            } else if (statement instanceof AST.While) {\r\n                const functionCalls = [];\r\n                state.commands.push(new ContinueTargetCommand(statement.id));\r\n                this._collectFunctionCalls(statement.condition, functionCalls);\r\n                for (const call of functionCalls) {\r\n                    state.commands.push(new CallExprCommand(call, statement));\r\n                }\r\n                const conditionCmd = new GotoCommand(statement.condition, 0, statement.line);\r\n                state.commands.push(conditionCmd);\r\n                let lastLine = statement.line;\r\n\r\n                if (statement.body.length > 0) {\r\n                    state.commands.push(new BlockCommand(statement.body));\r\n                    lastLine = statement.body[statement.body.length - 1].line;\r\n                }\r\n\r\n                state.commands.push(new GotoCommand(statement.condition, 0, lastLine));\r\n                state.commands.push(new BreakTargetCommand(statement.id));\r\n                conditionCmd.position = state.commands.length;\r\n            } else if (statement instanceof AST.For) {\r\n                if (statement.init) {\r\n                    state.commands.push(new StatementCommand(statement.init));\r\n                }\r\n\r\n                let conditionPos = state.commands.length;\r\n\r\n                if (statement.increment === null) {\r\n                    state.commands.push(new ContinueTargetCommand(statement.id));\r\n                }\r\n                let conditionCmd = null;\r\n                if (statement.condition) {\r\n                    const functionCalls = [];\r\n                    this._collectFunctionCalls(statement.condition!, functionCalls);\r\n                    for (const call of functionCalls) {\r\n                        state.commands.push(new CallExprCommand(call, statement));\r\n                    }\r\n                    conditionCmd = new GotoCommand(statement.condition, 0, statement.line);\r\n                    state.commands.push(conditionCmd);\r\n                }\r\n\r\n                let lastLine = statement.line;\r\n                if (statement.body.length > 0) {\r\n                    state.commands.push(new BlockCommand(statement.body));\r\n                    lastLine = statement.body[statement.body.length - 1].line;\r\n                }\r\n\r\n                if (statement.increment) {\r\n                    state.commands.push(new ContinueTargetCommand(statement.id));\r\n                    state.commands.push(new StatementCommand(statement.increment));\r\n                }\r\n                state.commands.push(new GotoCommand(null, conditionPos, lastLine));\r\n                state.commands.push(new BreakTargetCommand(statement.id));\r\n                conditionCmd.position = state.commands.length;\r\n            } else if (statement instanceof AST.Loop) {\r\n                let loopStartPos = state.commands.length;\r\n                if (!statement.continuing) {\r\n                    state.commands.push(new ContinueTargetCommand(statement.id));\r\n                }\r\n                let lastLine = statement.line;\r\n                if (statement.body.length > 0) {\r\n                    state.commands.push(new BlockCommand(statement.body));\r\n                    lastLine = statement.body[statement.body.length - 1].line;\r\n                }\r\n                state.commands.push(new GotoCommand(null, loopStartPos, lastLine));\r\n                state.commands.push(new BreakTargetCommand(statement.id));\r\n            } else if (statement instanceof AST.Continuing) {\r\n                state.commands.push(new ContinueTargetCommand(statement.loopId));\r\n                state.commands.push(new BlockCommand(statement.body));\r\n            } else if (statement instanceof AST.Continue) {\r\n                state.commands.push(new ContinueCommand(statement.loopId, statement));\r\n            } else if (statement instanceof AST.Break) {\r\n                state.commands.push(new BreakCommand(statement.loopId, statement.condition, statement));\r\n            } else if (statement instanceof AST.StaticAssert) {\r\n                state.commands.push(new StatementCommand(statement));\r\n            } else if (statement instanceof AST.Struct) {\r\n                // nothing to do\r\n            } else {\r\n                console.error(`TODO: statement type ${statement.constructor.name}`);\r\n            }\r\n        }\r\n\r\n        return state;\r\n    }\r\n\r\n    _collectFunctionCalls(node: AST.Expression, functionCalls: AST.CallExpr[]) {\r\n        if (node instanceof AST.CallExpr) {\r\n            if (node.args) {\r\n                for (const arg of node.args) {\r\n                    this._collectFunctionCalls(arg, functionCalls);\r\n                }\r\n            }\r\n            // Only collect custom function calls, not built-in functions.\r\n            if (!node.isBuiltin) {\r\n                functionCalls.push(node);\r\n            }\r\n        } else if (node instanceof AST.BinaryOperator) {\r\n            this._collectFunctionCalls(node.left, functionCalls);\r\n            this._collectFunctionCalls(node.right, functionCalls);\r\n        } else if (node instanceof AST.UnaryOperator) {\r\n            this._collectFunctionCalls(node.right, functionCalls);\r\n        } else if (node instanceof AST.CreateExpr) {\r\n            if (node.args) {\r\n                for (const arg of node.args) {\r\n                    this._collectFunctionCalls(arg, functionCalls);\r\n                }\r\n            }\r\n        } else if (node instanceof AST.BitcastExpr) {\r\n            this._collectFunctionCalls(node.value, functionCalls);\r\n        } else if (node instanceof AST.ArrayIndex) {\r\n            this._collectFunctionCalls(node.index, functionCalls);\r\n        } else if (AST.LiteralExpr) {\r\n            // nothing to do\r\n        } else {\r\n            console.error(`TODO: expression type ${node.constructor.name}`);\r\n        }\r\n    }\r\n}\r\n\r\n"],"names":["TypeInfo","constructor","name","attributes","this","size","isArray","isStruct","isTemplate","isPointer","getTypeName","MemberInfo","type","offset","align","members","format","count","stride","StructInfo","super","startLine","endLine","inUse","ArrayInfo","PointerInfo","TemplateInfo","access","ResourceType","VariableInfo","group","binding","resourceType","relations","AliasInfo","InputInfo","locationType","location","interpolation","OutputInfo","OverrideInfo","id","ArgumentInfo","FunctionInfo","stage","inputs","outputs","arguments","returnType","resources","overrides","calls","Set","EntryFunctions","vertex","fragment","compute","float16ToFloat32","float16","s","e","f","Math","pow","NaN","Infinity","float32View","Float32Array","int32View","Int32Array","buffer","float16View","Uint16Array","float32ToFloat16","float32","f32","sign","exponent","fraction","shift","uint32","Uint32Array","uint32ToFloat32","float11ToFloat32","f11","u32","getTexturePixel","imageData","x","y","z","mipLevel","height","bytesPerRow","texelByteSize","pixelValue","value","uintValue","gi","bi","f10","float10ToFloat32","numChannels","i","setPixelValue","Int16Array","f16","TextureFormatInfo","r8unorm","bytesPerBlock","blockWidth","blockHeight","isCompressed","channels","r8snorm","r8uint","r8sint","rg8unorm","rg8snorm","rg8uint","rg8sint","rgba8unorm","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","r16uint","r16sint","r16float","rg16uint","rg16sint","rg16float","rgba16uint","rgba16sint","rgba16float","r32uint","r32sint","r32float","rg32uint","rg32sint","rg32float","rgba32uint","rgba32sint","rgba32float","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","stencil8","isDepthStencil","hasDepth","hasStencil","depth16unorm","depth24plus","depthOnlyFormat","depth32float","stencilOnlyFormat","rgb9e5ufloat","Node","_id","line","isAstNode","astNodeType","search","callback","searchBlock","block","_BlockStart","instance","node","Array","_BlockEnd","constEvaluate","context","Error","constEvaluateString","toString","BuiltinFunctionNames","Statement","Function","args","body","attr","arg","StaticAssert","expression","While","condition","Continuing","loopId","For","init","increment","_a","_b","_c","Var","storage","Override","Let","Const","IncrementOperator","AssignOperator","TokenClass","parse","val","key","Increment","operator","variable","Assign","Call","isBuiltin","has","Loop","continuing","Switch","cases","If","elseif","_else","else","Return","Enable","Requires","extensions","Diagnostic","severity","rule","Alias","Discard","Break","Continue","Type","maxFormatType","t","length","tv","_priority","get","i32","x32","bool","void","Map","ForwardType","Struct","getMemberIndex","member","TemplateType","vec2f","vec3f","vec4f","vec2i","vec3i","vec4i","vec2u","vec3u","vec4u","vec2h","vec3h","vec4h","vec2b","vec3b","vec4b","mat2x2f","mat2x3f","mat2x4f","mat3x2f","mat3x3f","mat3x4f","mat4x2f","mat4x3f","mat4x4f","mat2x2h","mat2x3h","mat2x4h","mat3x2h","mat3x3h","mat3x4h","mat4x2h","mat4x3h","mat4x4h","mat2x2i","mat2x3i","mat2x4i","mat3x2i","mat3x3i","mat3x4i","mat4x2i","mat4x3i","mat4x4i","mat2x2u","mat2x3u","mat2x4u","mat3x2u","mat3x3u","mat3x4u","mat4x2u","mat4x3u","mat4x4u","PointerType","ArrayType","SamplerType","Expression","postfix","StringExpr","CreateExpr","evalExpression","CallExpr","cachedReturnValue","setCachedReturnValue","VariableExpr","ConstExpr","initializer","data","getSubData","LiteralExpr","undefined","isScalar","ScalarData","isVector","VectorData","MatrixData","scalarValue","console","error","vectorValue","BitcastExpr","TypecastExpr","ArrayIndex","index","Operator","UnaryOperator","right","BinaryOperator","left","_getPromotedType","t1","t2","SwitchCase","DefaultSelector","Case","selectors","Default","Argument","ElseIf","Member","Attribute","Data","typeInfo","parent","clone","setDataValue","exec","VoidData","PointerData","reference","floor","v","_getVectorData","values","formatName","getTypeInfo","typename","typeName","self","idx","d","byteOffset","toLowerCase","m","push","endsWith","formatSuffix","vectorData","TypedData","ArrayBuffer","cloned","Uint8Array","log","found","element","setData","byteLength","set","_i","fa","ua","toArray","TextureData","descriptor","view","width","Object","depthOrArrayLayers","sampleCount","mipLevelCount","dimension","getMipLevelSize","level","max","formatInfo","getGpuSize","getPixel","setPixel","setTexturePixel","TokenType","TokenTypes","none","reserved","eof","token","asm","bf16","do","enum","f64","handle","i8","i16","i64","mat","premerge","regardless","typedef","u8","u16","u64","unless","using","vec","keywords","array","keyword","atomic","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","ptr","sampler","sampler_comparison","struct","texture_1d","texture_2d","texture_2d_array","texture_3d","texture_cube","texture_cube_array","texture_multisampled_2d","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","texture_depth_multisampled_2d","texture_external","vec2","vec3","vec4","bitcast","break","case","continue","default","diagnostic","discard","enable","fallthrough","false","fn","for","function","if","let","const","loop","while","private","read","read_write","return","requires","switch","true","alias","uniform","var","override","workgroup","write","rgba8unorm_srgb","bgra8unorm_srgb","rg11b10float","static_assert","tokens","decimal_float_literal","hex_float_literal","int_literal","uint_literal","ident","and","and_and","arrow","forward_slash","bang","bracket_left","bracket_right","brace_left","brace_right","colon","comma","equal","equal_equal","not_equal","greater_than","greater_than_equal","shift_right","less_than","less_than_equal","shift_left","modulo","minus","minus_minus","period","plus","plus_plus","or","or_or","paren_left","paren_right","semicolon","star","tilde","underscore","xor","plus_equal","minus_equal","times_equal","division_equal","modulo_equal","and_equal","or_equal","xor_equal","shift_right_equal","shift_left_equal","simpleTokens","literalTokens","_","regexTokens","storage_class","access_mode","sampler_type","sampled_texture_type","multisampled_texture_type","storage_texture_type","depth_texture_type","texture_external_type","any_texture_type","texel_format","const_literal","literal_or_ident","element_count_expression","template_types","attribute_name","assignment_operators","increment_operators","Token","lexeme","start","end","isTemplateType","indexOf","isArrayType","isArrayOrTemplateType","WgslScanner","source","_tokens","_start","_current","_line","_source","scanTokens","_isAtEnd","scanToken","_advance","_isWhitespace","_peekAhead","commentLevel","simpleToken","_addToken","matchType","isAlpha","_isAlpha","isUnderscore","_isAlphaNumeric","nextChar","matchedType","_findType","nextLexeme","ti","foundLessThan","lookAheadLexeme","lookAhead","maxLookAhead","li","_match","match","c","_isNumeric","amount","text","substring","_f32","_f32_i32","_f32_u32","_i32","_i32_f32","_i32_u32","_u32","_u32_f32","_u32_i32","castScalar","from","to","_FunctionResources","info","_TypeSize","Reflect","uniforms","textures","samplers","aliases","structs","entry","functions","_types","_functions","_isStorageTexture","updateAST","ast","_getAliasInfo","_getAttributeNum","_isUniformVar","g","b","varInfo","Uniform","_isStorageVar","isStorageTexture","StorageTexture","Storage","_isTextureVar","Texture","_isSamplerVar","Sampler","vertexStage","_getAttribute","fragmentStage","computeStage","_getInputs","_getOutputs","_findResources","map","_addCalls","u","_markStructsInUse","getFunctionInfo","getStructInfo","getOverrideInfo","o","_getAlias","call","add","findResource","r","_findResource","_markStructsFromAST","isEntry","varStack","pop","callFn","textureArg","texture","samplerArg","getBindGroups","groups","_makeRoom","_getStructOutputs","output","_getOutputInfo","locationValue","_parseInt","_getStructInputs","input","_getInputInfo","_parseString","n","parseInt","isNaN","a","getTypeInfoByName","_updateTypeInfo","formatIsType","typeSize","_getTypeSize","_updateStructInfo","lastSize","lastOffset","structAlign","mi","ml","sizeInfo","_roundUp","explicitSize","explicitAlign","_typeInfo","divisor","arrayType","E","_textureTypes","_samplerTypes","obj","attrs","defaultValue","k","ceil","VarRef","FunctionRef","ExecContext","variables","currentFunctionName","getVariable","getFunction","createVariable","setVariable","getVariableValue","ExecInterface","getVariableName","BuiltinFunctions","All","isTrue","forEach","Any","res","some","Select","ArrayLength","arrayArg","arrayData","ta","Abs","abs","Acos","acos","Acosh","acosh","Asin","asin","Asinh","asinh","Atan","atan","Atanh","atanh","Atan2","atan2","ys","xs","Ceil","_clamp","min","Clamp","minS","maxS","Cos","cos","Cosh","cosh","CountLeadingZeros","clz32","_countOneBits","CountOneBits","_countTrailingZeros","CountTrailingZeros","Cross","l","lv","rv","Degrees","radToDeg","PI","Determinant","mv","mt","formatType","Distance","sum","sqrt","ls","rs","_dot","e1","e2","dot","Dot","Dot4U8Packed","Dot4I8Packed","Exp","exp","Exp2","ExtractBits","FaceForward","_firstLeadingBit","FirstLeadingBit","_firstTrailingBit","log2","FirstTrailingBit","Floor","Fma","av","bv","cv","Fract","Frexp","InsertBits","insert","mask","invMask","InverseSqrt","Ldexp","Length","Log","Log2","Max","Min","Mix","as","Modf","Normalize","Pow","QuantizeToF16","Radians","Refract","e3","sqrtK","ReverseBits","Round","round","Saturate","Sign","Sin","sin","Sinh","sinh","_smoothstep","edge0","edge1","SmoothStep","e0","xS","Sqrt","Step","edge","Tan","tan","Tanh","tanh","_getTransposeType","tname","Transpose","ttype","Trunc","trunc","Dpdx","DpdxCoarse","DpdxFine","Dpdy","DpdyCoarse","DpdyFine","Fwidth","FwidthCoarse","FwidthFine","TextureDimensions","textureName","textureSize","slice","TextureGather","TextureGatherCompare","TextureLoad","uv","zVal","texel","TextureNumLayers","TextureNumLevels","TextureNumSamples","TextureSample","TextureSampleBias","TextureSampleCompare","TextureSampleCompareLevel","TextureSampleGrad","TextureSampleLevel","TextureSampleBaseClampToEdge","TextureStore","AtomicLoad","AtomicStore","currentValue","AtomicAdd","originalValue","AtomicSub","AtomicMax","AtomicMin","AtomicAnd","AtomicOr","AtomicXor","AtomicExchange","AtomicCompareExchangeWeak","Pack4x8snorm","Pack4x8unorm","Pack4xI8","Pack4xU8","Pack4x8Clamp","Pack4xU8Clamp","Pack2x16snorm","Pack2x16unorm","Pack2x16float","Unpack4x8snorm","Unpack4x8unorm","Unpack4xI8","Unpack4xU8","Unpack2x16snorm","Unpack2x16unorm","Unpack2x16float","StorageBarrier","TextureBarrier","WorkgroupBarrier","WorkgroupUniformLoad","SubgroupAdd","SubgroupExclusiveAdd","SubgroupInclusiveAdd","SubgroupAll","SubgroupAnd","SubgroupAny","SubgroupBallot","SubgroupBroadcast","SubgroupBroadcastFirst","SubgroupElect","SubgroupMax","SubgroupMin","SubgroupMul","SubgroupExclusiveMul","SubgroupInclusiveMul","SubgroupOr","SubgroupShuffle","SubgroupShuffleDown","SubgroupShuffleUp","SubgroupShuffleXor","SubgroupXor","QuadBroadcast","QuadSwapDiagonal","QuadSwapX","QuadSwapY","VectorTypeSize","MatrixTypeSize","WgslExec","reflection","builtins","execute","config","_setOverrides","_execStatements","dispatchWorkgroups","kernel","dispatchCount","bindGroups","depth","kernelRefl","resource","textureData","_dispatchWorkgroup","execStatement","stmt","_breakObj","_continueObj","_let","_var","_const","_override","_function","_if","_switch","_for","_while","_loop","subContext","_assign","_increment","_call","_evalBinaryOp","_evalLiteral","_evalVariable","_evalCall","_evalCreate","_evalConst","_evalBitcast","_evalUnaryOp","constants","workgroup_id","workgroupSize","local_invocation_id","global_invocation_id","_dispatchExec","globalName","globalVar","statements","ai","_callBuiltinFunction","_getVariableData","refData","varData","assignValue","op","rNode","defType","defaultCase","selector","selectorValue","_getScalarValue","fromType","fromCast","toType","toCast","cast","castVector","_callConstructorValue","_callConstructorVec","_callConstructorMatrix","memberInfo","_maxFormatTypeInfo","_r","result","rn","_isMatrixType","startsWith","_isVectorType","_l","la","ra","ln","matrixA","matrixB","j","matrixMultiply","colsB","rowsA","matrix","vector","cols","rows","resultVec","matrixVectorMultiply","vectorMatrixMultiply","argValue","vd","fill","ParseContext","WgslParser","_currentLine","_deferArrayCountEval","_currentLoop","_context","_exec","_forwardTypeCount","tokensOrCode","_initialize","statement","_global_decl_or_directive","arrayDecl","countNode","AST.VariableExpr","constant","AST.Member","AST.PointerType","_forwardType","AST.ArrayType","AST.Var","AST.Let","AST.Const","AST.Function","AST.Argument","AST.ForwardType","ft","_getType","scanner","_updateNode","_error","message","_peek","types","_check","_consume","tk","hasNameType","_previous","_type_alias","directive","_diagnostic","_requires_directive","_enable_directive","_attribute","_global_variable_decl","_override_variable_decl","_global_let_decl","_global_const_decl","_struct","_struct_decl","_fn","_function_decl","argAttrs","typeAttrs","_type_decl","_return","_compound_statement","_statement","_if_statement","_switch_statement","_loop_statement","_for_statement","_while_statement","_continuing_statement","_static_assert_statement","_return_statement","_variable_statement","AST.Discard","breakStmt","AST.Break","_optional_paren_expression","continueStmt","AST.Continue","_increment_decrement_statement","_func_call_statement","_assignment_statement","AST.StaticAssert","whileLoop","AST.While","AST.Continuing","forLoop","AST.For","_for_init","_short_circuit_or_expression","_for_increment","_variable_decl","AST.LiteralExpr","savedPos","_unary_expression","AST.Increment","AST.IncrementOperator","decrement","AST.Assign","AST.AssignOperator","_argument_expression_list","AST.Call","AST.Loop","switchStmt","AST.Switch","_switch_body","hasDefault","_case_selectors","AST.DefaultSelector","_case_body","AST.Case","AST.Default","_shift_expression","nextStatement","_match_elseif","_elseif_statement","AST.If","AST.ElseIf","AST.Return","expr","_short_circuit_and_expr","AST.BinaryOperator","_inclusive_or_expression","_exclusive_or_expression","_and_expression","_equality_expression","_relational_expression","_additive_expression","_multiplicative_expression","AST.UnaryOperator","_singular_expression","_primary_expression","p","_postfix_expression","arrayIndex","AST.ArrayIndex","AST.StringExpr","_getStruct","AST.Type","AST.TemplateType","_validateTypeRange","AST.CreateExpr","AST.CallExpr","AST.ConstExpr","fs","isF16","parseFloat","_paren_expression","AST.BitcastExpr","memberAttrs","memberName","memberType","structNode","AST.Struct","_const_expression","_override_decl","valueExpr","constValue","AST.Override","ruleMessage","AST.Diagnostic","AST.Enable","AST.Requires","aliasType","aliasNode","AST.Alias","_texture_sampler_types","pointer","decl","countInt","AST.SamplerType","AST.Attribute","WgslReflect","code","update","Command","StatementCommand","CallExprCommand","ContinueTargetCommand","BreakTargetCommand","ContinueCommand","BreakCommand","GotoCommand","position","lineNo","BlockCommand","StackFrame","commands","current","parentCallExpr","isAtEnd","getNextCommand","command","getCurrentCommand","ExecStack","states","isEmpty","last","WgslDebug","runStateCallback","_runTimer","breakpoints","_code","reset","startDebug","_execStack","state","_createState","currentState","currentCommand","toggleBreakpoint","delete","clearBreakpoints","clear","isRunning","run","setInterval","clearInterval","stepNext","pause","debugWorkgroup","dispatchId","_dispatchId","kernelFn","_shouldExecuteNextCommand","stepInto","stepOver","stepOut","parentState","fnState","targetId","cmd","blockState","functionCalls","_collectFunctionCalls","conditionCmd","gotoEnd","elseIf","gotoEndCommands","lastCondition","conditionExpr","gotoCommand","gotoEndCommand","commandPos","lastLine","conditionPos","loopStartPos"],"mappings":"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,MACA,MACA,MACA,SACA,cACA,MACA,OACA,QACA,OACA,QACA,OACA,QACA,QACA,OACA,QACA,MACA,OACA,oBACA,eACA,qBACA,QACA,UACA,cACA,WACA,MACA,eACA,eACA,MACA,OACA,cACA,cACA,kBACA,mBACA,QACA,MACA,QACA,QACA,aACA,cACA,QACA,SACA,MACA,OACA,MACA,MACA,MACA,OACA,YACA,MACA,gBACA,UACA,UACA,UACA,cACA,QACA,WACA,OACA,MACA,OACA,aACA,OACA,OACA,MACA,OACA,YACA,QACA,OACA,aACA,WACA,OACA,aACA,WACA,SACA,eACA,aACA,oBACA,gBACA,uBACA,cACA,mBACA,mBACA,oBACA,gBACA,oBACA,uBACA,4BACA,oBACA,qBACA,+BACA,eACA,aACA,cACA,YACA,YACA,YACA,YACA,YACA,WACA,YACA,iBACA,4BACA,eACA,eACA,WACA,WACA,eACA,gBACA,gBACA,gBACA,gBACA,iBACA,iBACA,aACA,aACA,kBACA,kBACA,kBACA,iBACA,iBACA,mBACA,uBACA,cACA,uBACA,uBACA,cACA,cACA,cACA,iBACA,oBACA,yBACA,gBACA,cACA,cACA,cACA,uBACA,uBACA,aACA,kBACA,sBACA,oBACA,qBACA,cACA,gBACA,mBACA,YACA,cAQI,MAAO6H,UAAkBpB,EAC7B,WAAA5J,GACEmB,OACD,EAQG,MAAO8J,UAAiBD,EAU5B,WAAAhL,CACEC,EACAiL,EACAnI,EACAoI,EACA/J,EACAC,GAEAF,QAVFhB,KAAA+C,MAAuB,IAAIC,IAWzBhD,KAAKF,KAAOA,EACZE,KAAK+K,KAAOA,EACZ/K,KAAK4C,WAAaA,EAClB5C,KAAKgL,KAAOA,EACZhL,KAAKiB,UAAYA,EACjBjB,KAAKkB,QAAUA,CAChB,CAED,eAAI2I,GACF,MAAO,UACR,CAED,MAAAC,CAAOC,GACL,GAAI/J,KAAKD,WACP,IAAK,MAAMkL,KAAQjL,KAAKD,WACtBgK,EAASkB,GAGblB,EAAS/J,MACT,IAAK,MAAMkL,KAAOlL,KAAK+K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"}